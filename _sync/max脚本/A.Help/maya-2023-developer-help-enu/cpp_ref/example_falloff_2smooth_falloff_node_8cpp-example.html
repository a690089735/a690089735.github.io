<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
      <title>C++ API Reference: exampleFalloff/smoothFalloffNode.cpp</title>
      
	  
      
      
      
      
      
      
      
    

</head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('example_falloff_2smooth_falloff_node_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
      <div>
         <div class="head">
            <h1>C++ API Reference: exampleFalloff/smoothFalloffNode.cpp</h1>
         </div>

<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->

  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="cpp_ref/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="cpp_ref/search/close.png" alt=""></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<!-- window showing the filter options -->


<!-- iframe showing the search results (closed by default) -->


<div class="header">
  <div class="headertitle">
<div class="title">exampleFalloff/smoothFalloffNode.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;smoothFalloffNode.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnTypedAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNumericAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnFalloffData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MIndexMapper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="keyword">const</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_type_id.html">MTypeId</a> SmoothFalloffNode::id(0x0008006F);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> SmoothFalloffNode::typeName(<span class="stringliteral">&quot;exampleSmoothFalloff&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a name="_a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> SmoothFalloffNode::aSmoothFactor;</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> SmoothFalloffNode::aFalloffInput;</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> SmoothFalloffNode::aFalloffOutput;</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> SmoothFalloffNode::aIteration;</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> SmoothFalloffNode::aSyncId;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">SmoothFalloffNode::SmoothFalloffNode(){}</div>
<div class="line">SmoothFalloffNode::~SmoothFalloffNode(){}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span>* SmoothFalloffNode::creator()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> SmoothFalloffNode{};</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">Smooth Falloff takes a weighfunction in and provides an output weight function.</span></div>
<div class="line"><span class="comment">The outputweight function will smooth the weight of its input</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a name="_a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> SmoothFalloffNode::initialize()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line"></div>
<div class="line">    <a name="_a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html">MFnNumericAttribute</a> numAttrFn;</div>
<div class="line">    <a name="_a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_typed_attribute.html">MFnTypedAttribute</a> typedAttrFn;</div>
<div class="line"></div>
<div class="line">    aIteration = numAttrFn.<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">&quot;iteration&quot;</span>, <span class="stringliteral">&quot;itr&quot;</span>, <a name="a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7a9bb31be73c01d40428195449f62588ac">MFnNumericData::kInt</a>, 1 );</div>
<div class="line">    numAttrFn.<a name="a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#aba21b33176bb831de026b78605c1dcf3">setMin</a>(0);</div>
<div class="line">    numAttrFn.<a name="a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#adab95fd85497b1dad3a4ba7a842ce9d8">setMax</a>(20);</div>
<div class="line">    status = <a name="a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">MPxNode::addAttribute</a>(aIteration);</div>
<div class="line">    <a name="a11"></a><a class="code" href="#!/url=./cpp_ref/group___macros.html#ga2f3f1ac62ed663f5efd20ff99991335b">CHECK_MSTATUS_AND_RETURN_IT</a>(status);</div>
<div class="line"></div>
<div class="line">    aSyncId = numAttrFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">&quot;syncid&quot;</span>, <span class="stringliteral">&quot;sid&quot;</span>, <a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7a9bb31be73c01d40428195449f62588ac">MFnNumericData::kInt</a>, -1 );</div>
<div class="line">    numAttrFn.<a name="a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#ab8e48be1f1009a30d0e40dfcaf9e649d">setHidden</a>(<span class="keyword">true</span>);</div>
<div class="line">    status = <a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">MPxNode::addAttribute</a>(aSyncId);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/group___macros.html#ga2f3f1ac62ed663f5efd20ff99991335b">CHECK_MSTATUS_AND_RETURN_IT</a>(status);</div>
<div class="line"></div>
<div class="line">    aSmoothFactor = numAttrFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">&quot;smoothFactor&quot;</span>, <span class="stringliteral">&quot;smf&quot;</span>, <a name="a13"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7acd70f5d2b5e8c1bb8e83b0482a33e518">MFnNumericData::kDouble</a>, 0.1 );</div>
<div class="line">    numAttrFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#aba21b33176bb831de026b78605c1dcf3">setMin</a>(0.0);</div>
<div class="line">    numAttrFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#adab95fd85497b1dad3a4ba7a842ce9d8">setMax</a>(1.0);</div>
<div class="line">    status = <a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">MPxNode::addAttribute</a>(aSmoothFactor);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/group___macros.html#ga2f3f1ac62ed663f5efd20ff99991335b">CHECK_MSTATUS_AND_RETURN_IT</a>(status);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//example ho to declare a falloff function</span></div>
<div class="line">    aFalloffInput = typedAttrFn.<a name="a14"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">&quot;falloffInput&quot;</span>, <span class="stringliteral">&quot;foi&quot;</span>, <a name="a15"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7a824333d91bec0813bd494bf70a4fb91a">MFnData::kFalloffFunction</a> );</div>
<div class="line">    status = <a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">MPxNode::addAttribute</a>(aFalloffInput);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/group___macros.html#ga2f3f1ac62ed663f5efd20ff99991335b">CHECK_MSTATUS_AND_RETURN_IT</a>(status);</div>
<div class="line"></div>
<div class="line">    aFalloffOutput = typedAttrFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">&quot;falloffOutput&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>, <a class="code" href="#!/url=./cpp_ref/class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7a824333d91bec0813bd494bf70a4fb91a">MFnData::kFalloffFunction</a> );</div>
<div class="line">    typedAttrFn.<a name="a16"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a98bb3089ec3b7442383da68a5ef424c7">setWritable</a>(<span class="keyword">false</span>);</div>
<div class="line">    typedAttrFn.<a name="a17"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">false</span>);</div>
<div class="line">    status = <a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">MPxNode::addAttribute</a>(aFalloffOutput);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/group___macros.html#ga2f3f1ac62ed663f5efd20ff99991335b">CHECK_MSTATUS_AND_RETURN_IT</a>(status);</div>
<div class="line"></div>
<div class="line">    status = attributeAffects( aFalloffInput, aFalloffOutput );</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/group___macros.html#ga2f3f1ac62ed663f5efd20ff99991335b">CHECK_MSTATUS_AND_RETURN_IT</a>(status);</div>
<div class="line">    status = attributeAffects( aSmoothFactor, aFalloffOutput );</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/group___macros.html#ga2f3f1ac62ed663f5efd20ff99991335b">CHECK_MSTATUS_AND_RETURN_IT</a>(status);</div>
<div class="line">    status = attributeAffects( aIteration, aFalloffOutput );</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/group___macros.html#ga2f3f1ac62ed663f5efd20ff99991335b">CHECK_MSTATUS_AND_RETURN_IT</a>(status);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a name="a18"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> SmoothFalloffNode::uninitialize()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>SmoothFalloff: <span class="keyword">public</span> <a name="_a19"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_function.html">MFalloffFunction</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span>VertInfo{</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertId;</div>
<div class="line">            <span class="keywordtype">double</span> weight;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    SmoothFalloff(<a name="_a20"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html">MPxNode</a>* node, <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> inputFalloff, <span class="keywordtype">double</span> smoothFactor, <span class="keywordtype">int</span> iter, <span class="keywordtype">int</span> syncId)</div>
<div class="line">        :mNode(node)</div>
<div class="line">        ,mInput(inputFalloff)</div>
<div class="line">        ,mSmoothFactor(smoothFactor)</div>
<div class="line">        ,mIter(iter)</div>
<div class="line">        ,mSyncId(syncId)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">//The Actual smooth algorithm</span></div>
<div class="line">    <span class="comment">//It takes an inOutBuffer initalized to the input weights.</span></div>
<div class="line">    <span class="comment">//mesh provide the connectivity information to do a proper smooth.</span></div>
<div class="line">    <span class="comment">//Since weight function can provide weight on a subset of the total number of vert in a mesh;</span></div>
<div class="line">    <span class="comment">//the mapper will inform us how to map a weight buffer index in to the mesh vertex buffer (full Id to affect Id &quot;fullToAffect&quot;)</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> doSmooth(<a name="_a21"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a>&amp; inOut, <a name="_a22"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html">MFnMesh</a>&amp; mesh, <span class="keyword">const</span> <a name="_a23"></a><a class="code" href="#!/url=./cpp_ref/class_m_index_mapper.html">MIndexMapper</a>&amp; mapper)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> numEdges = mesh.<a name="a24"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html#a742ce017199905f06ad07c178375a2d8">numEdges</a>();</div>
<div class="line"></div>
<div class="line">        std::vector&lt;std::vector&lt;VertInfo&gt;&gt; vertConnections(mapper.<a name="a25"></a><a class="code" href="#!/url=./cpp_ref/class_m_index_mapper.html#aeb8175beaa44b2592e10c39d3e64ff54">affectCount</a>());</div>
<div class="line"></div>
<div class="line">        <span class="comment">//Gather Vertices Connection</span></div>
<div class="line">        <span class="comment">//for each vertex there is a list of VertInfo, wich hold connecting ver and invert distance to it</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numEdges; ++i){</div>
<div class="line">            int2 vs;</div>
<div class="line">            <span class="keyword">auto</span> status = mesh.<a name="a26"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html#a603d73f3637830a372ab3678d24ca6e6">getEdgeVertices</a>(i,vs);</div>
<div class="line">            <span class="keyword">auto</span> v0 = mapper.<a name="a27"></a><a class="code" href="#!/url=./cpp_ref/class_m_index_mapper.html#a761d19a48ed020ca966998a26a8a3c11">fullToAffect</a>(vs[0]); <span class="comment">//takes the vertexId and return the index in the weight buffer</span></div>
<div class="line">            <span class="keyword">auto</span> v1 = mapper.<a class="code" href="#!/url=./cpp_ref/class_m_index_mapper.html#a761d19a48ed020ca966998a26a8a3c11">fullToAffect</a>(vs[1]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span>(v0 != <a name="a28"></a><a class="code" href="#!/url=./cpp_ref/class_m_index_mapper.html#ad9f80bb353043984747206df32afc365">MIndexMapper::InvalidIndex</a> &amp;&amp; v1 !=  <a class="code" href="#!/url=./cpp_ref/class_m_index_mapper.html#ad9f80bb353043984747206df32afc365">MIndexMapper::InvalidIndex</a>){ <span class="comment">//if vertex are not art of the desired subset don&#39;t consider them</span></div>
<div class="line"></div>
<div class="line">                <a name="_a29"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> p0;</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> p1;</div>
<div class="line">                mesh.<a name="a30"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html#a71f31afb68fa92a69b114dd7f3cb12fa">getPoint</a>(v0, p0);</div>
<div class="line">                mesh.<a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html#a71f31afb68fa92a69b114dd7f3cb12fa">getPoint</a>(v1, p1);</div>
<div class="line">                <span class="keyword">auto</span> invert_d = pow(1.0/p1.<a name="a31"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(p0), 4.0);</div>
<div class="line">                vertConnections[v0].emplace_back(VertInfo{v1, invert_d});</div>
<div class="line">                vertConnections[v1].emplace_back(VertInfo{v0, invert_d});</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">//normalize inverted distance to have proper weight per vertex</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;v : vertConnections){</div>
<div class="line">            <span class="keywordtype">double</span> sumWeight = 0;</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; info: v){</div>
<div class="line">                sumWeight += info.weight;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; info: v){</div>
<div class="line">                info.weight /= sumWeight;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> OneMinusFactor = 1.0 - mSmoothFactor;</div>
<div class="line">        <span class="keywordflow">if</span> (mIter &lt; 0) mIter = 0;</div>
<div class="line">        <span class="keywordflow">if</span> (mIter &gt; 20) mIter = 20;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//simple smooth algorithm</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> initial;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iteration = 0; iteration &lt; mIter; ++iteration){</div>
<div class="line">            initial = inOut;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; initial.<a name="a32"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); ++i){</div>
<div class="line">                <span class="keywordtype">double</span> averageNeighbours = 0.0;</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vertInfo : vertConnections[i]){</div>
<div class="line">                    averageNeighbours += initial[vertInfo.vertId] * vertInfo.weight;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span>(vertConnections[i].size() &gt; 0)</div>
<div class="line">                    inOut[i] = (initial[i] * OneMinusFactor) + (mSmoothFactor * averageNeighbours);</div>
<div class="line"></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">//This is the function that will be called when the weight buffer are needed</span></div>
<div class="line">    <span class="comment">//MFalloffContext would provide the neede information to correctly compute the weight for the targeted geometry</span></div>
<div class="line">    ReturnValue operator()(<a name="_a33"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_context.html">MFalloffContext</a>&amp; accessor)<span class="keyword"> override</span>{</div>
<div class="line"></div>
<div class="line">        <span class="comment">//create an identifier for this node within the context</span></div>
<div class="line">        <span class="comment">//Since this node only require 1 buffer by context, we can have layerId = 0 as second parameter.</span></div>
<div class="line">        <span class="comment">//In case where we would have multiple function on same node (ex: using multi) we could use the multiIndex as second param.</span></div>
<div class="line">        <a name="_a34"></a><a class="code" href="#!/url=./cpp_ref/class_m_buffer_identifier.html">MBufferIdentifier</a> bufferId{mNode,0};</div>
<div class="line"></div>
<div class="line">        <span class="comment">//This is an example how to call a falloff input function with the same context</span></div>
<div class="line">        <a name="_a35"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_falloff_data.html">MFnFalloffData</a> inputFoff(mInput);</div>
<div class="line">        <span class="keyword">auto</span> rv = inputFoff.call(accessor);</div>
<div class="line">        <span class="comment">//rv now store infromation to get to the input buffer we need.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">//if the topology is dirty we always need to recompute no matter everythiong else</span></div>
<div class="line">        <span class="comment">//if the input is the same (Cached) then only recompute if this buffer is out of sync (input on this node has changes since last evaluation)</span></div>
<div class="line">        <span class="keywordflow">if</span>( !accessor.<a name="a36"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_context.html#acdcf7e10045852a41da8c29e6032a805">isTopologyDirty</a>() &amp;&amp;</div>
<div class="line">            rv.getCachedIndicator() == MFalloffFunction::ReturnValue::Cached &amp;&amp;</div>
<div class="line">            accessor.<a name="a37"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_context.html#a87b3b5abda17215beee4ee90c8cdcb14">isSync</a>(mSyncId,bufferId))</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">return</span>  ReturnValue{bufferId, rv.getRequirement(), ReturnValue::Cached};</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">//get the actual input buffer</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> initial = accessor.<a name="a38"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_context.html#a1a4fd97453ef244e85d138cc9393ebe8">getValues</a>(rv.getBufferId());</div>
<div class="line">        <span class="comment">//get the targeted geometry</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> geom = accessor.<a name="a39"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_context.html#a7e40ddf4a5e3e9a9777288f90c62efee">getGeometry</a>();</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_index_mapper.html">MIndexMapper</a> mapper = accessor.<a name="a40"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_context.html#a7bad31e9c09f8360aa7a2cb6a01f93bb">getIndexMapper</a>();</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html">MFnMesh</a> mesh(geom, &amp;status);</div>
<div class="line"></div>
<div class="line">        <span class="comment">//this smooth falloff won&#39;t work on geometry other than mesh</span></div>
<div class="line">        <span class="keywordflow">if</span>(status != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>){</div>
<div class="line">            <span class="keywordflow">return</span> rv; <span class="comment">//simply return the input if it is not a mesh</span></div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(mIter &gt; 0 &amp;&amp; mSmoothFactor &gt; 0.0)</div>
<div class="line">            doSmooth(initial, mesh, mapper); </div>
<div class="line"></div>
<div class="line">        <span class="comment">//set the computed buffer.</span></div>
<div class="line">        accessor.<a name="a41"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_context.html#ac0b3351a5dc5d651c9d78288f1882655">setValue</a>(initial,bufferId);</div>
<div class="line"></div>
<div class="line">        <span class="comment">//make sure it is sync with our captured syncId</span></div>
<div class="line">        accessor.<a name="a42"></a><a class="code" href="#!/url=./cpp_ref/class_m_falloff_context.html#a0314406bed463aa3c99db7c4b46b19c7">sync</a>(mSyncId, bufferId);</div>
<div class="line"></div>
<div class="line">        <span class="comment">//This node does not have any different requirement, returning input requirment as is.</span></div>
<div class="line">        <span class="comment">//Some falloff could require current geometry instead of the original geometry.</span></div>
<div class="line">        <span class="comment">//Current geometry requirement would cause the falloff to be computed everytime the input geometry of a deformer changes.</span></div>
<div class="line">        <span class="comment">//OriginalGeometry requirement would only trigger weight computation when original geometry of a deformer changes.</span></div>
<div class="line">        <span class="keywordflow">return</span> ReturnValue{bufferId, rv.getRequirement(), ReturnValue::NotCached};</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_px_node.html">MPxNode</a>* mNode;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> mInput;</div>
<div class="line">    <span class="keywordtype">double</span> mSmoothFactor;</div>
<div class="line">    <span class="keywordtype">int</span> mIter;</div>
<div class="line">    <span class="keywordtype">int</span> mSyncId;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> SmoothFalloffNode::compute( <span class="keyword">const</span> <a name="_a43"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp; plug, <a name="_a44"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a> &amp; block )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(plug.<a name="a45"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == aFalloffOutput){</div>
<div class="line"></div>
<div class="line">        <span class="comment">//When outputing a falloff function we must pull on all needed data at the compute stage.</span></div>
<div class="line">        <span class="keyword">auto</span> input = block.<a name="a46"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(aFalloffInput);</div>
<div class="line">        <span class="keyword">auto</span> sf = block.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(aSmoothFactor).<a name="a47"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#ac1983b7d41a8dae60dc5b1eb9f44a53c">asDouble</a>();</div>
<div class="line">        <span class="keyword">auto</span> iter = block.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(aIteration).<a name="a48"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a4c3fb2724eadb8e8a3cca8ff1af10dfd">asInt</a>();</div>
<div class="line">        <span class="keyword">auto</span> syncId = block.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(aSyncId).<a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a4c3fb2724eadb8e8a3cca8ff1af10dfd">asInt</a>();</div>
<div class="line"></div>
<div class="line">        <span class="comment">//increment sync id so that we remember that this computation id and can compare if the buffer is stale or not</span></div>
<div class="line">        block.<a name="a49"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(aSyncId).<a name="a50"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>(++syncId);</div>
<div class="line"></div>
<div class="line">        <span class="comment">//It is important to have a syncId because of the computation paradigm of the weight function.</span></div>
<div class="line">        <span class="comment">//The weight function is not evaluated a this compute stage but rather at the time where weights are needed.</span></div>
<div class="line">        <span class="comment">//For example weight function are consumed by deformer (geometryFilter)</span></div>
<div class="line">        <span class="comment">//at the compute time of the geometryfilter, the function will be invoked with a context parameter MFalloffContext.</span></div>
<div class="line">        <span class="comment">//The same function can be evaluated multiples time by different context and</span></div>
<div class="line">        <span class="comment">//could potentially be evaluated multiple times within the same context (see smoothFalloff1 example below).</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">//Take this graph example:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//  WeightFunctionProvider1   --&gt; smoothFallOff1--&gt; firstDeformer</span></div>
<div class="line">        <span class="comment">//                                            \ --&gt; blendfallof1.layer1</span></div>
<div class="line">        <span class="comment">//                                            \ --&gt; blendfallof1.layer2</span></div>
<div class="line">        <span class="comment">//                             someOtherFalloff1--&gt; blendfallof1.layer3</span></div>
<div class="line">        <span class="comment">//                                                              .outFunction ---&gt;  secondDeformer</span></div>
<div class="line">        <span class="comment">//                                                                          \---&gt;  thirdDeformer</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">//smoothFallOff1 outputFunction would be called exaclty once by firstDeformer at its compute time.</span></div>
<div class="line">        <span class="comment">//It would be called exaclty twice by secondDeformer and the twice as well for thirdDeformer</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">//For the case of the second &amp; third deformer they are call twice each since the smoothFallOff1</span></div>
<div class="line">        <span class="comment">//is connected to 2 layer of the blendfalloff.</span></div>
<div class="line">        <span class="comment">//The blendfalloff to blend each layer would ask for each input buffer.</span></div>
<div class="line">        <span class="comment">//The first time it get asked it probably need to compute if (syncId is not in sync with buffer)</span></div>
<div class="line">        <span class="comment">//the second time it will be sync then it can return Cached and skip the computation.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">//In the case where input parameters of someOtherFalloff1 change then it goes out of sync.</span></div>
<div class="line">        <span class="comment">//It provokes a dirty propagation for the entire weight function graph</span></div>
<div class="line">        <span class="comment">//In order to avoid to recompute all the layers of the blendFalloff1,</span></div>
<div class="line">        <span class="comment">//each falloff function can bail out as soon as possible by checking the syncId stored with buffer syncId.</span></div>
<div class="line">        <span class="comment">//That way only someOtherFalloff1 &amp; the blendFalloff1 would need to recompute but not WeightFunctionProvider1 and smoothFallOff1</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_fn_falloff_data.html">MFnFalloffData</a> foffData;</div>
<div class="line">        <span class="comment">//set a MSharedPtr of a callable to output falloff data</span></div>
<div class="line">        <span class="keyword">auto</span> data = foffData.<a name="a51"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_falloff_data.html#a57aeea7b4a1149ea23a622ca5a3e22c8">create</a>(<a name="_a52"></a><a class="code" href="#!/url=./cpp_ref/class_m_shared_ptr.html">MSharedPtr&lt;SmoothFalloff&gt;</a>(<span class="keyword">new</span> SmoothFalloff{<span class="keyword">this</span>,input.asFalloffFunction(), sf, iter, syncId}));</div>
<div class="line">        block.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(plug).<a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>(data);</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
