<!DOCTYPE html><html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta name="product" content="3DSMAX">
      <meta name="release" content="2023">
      <meta name="book" content="GeneralUser">
      <meta name="created" content="2022-03-27">
      <meta name="topicid" content="GUID-F46E863E-BF7C-4F29-BAD2-F91B0080DC80">
      <meta name="description" content="“输出类型”子操作符（包括“数量更改”）具有定义“优先级顺序”和“执行顺序”的选项。创建复杂设置时，请务必注意这些选项。">
      <meta name="topic-type" content="concept">
      <title>优先级和执行顺序</title><script language="javascript">var index = 'index3dsmaxhelp.html';</script></head>
   <body height="100%">
      <div class="body_content" id="body-content" dir="ltr"><a name="GUID-F46E863E-BF7C-4F29-BAD2-F91B0080DC80"></a><div class="head">
            <h1>优先级和执行顺序</h1>
         </div>
         <p class="blurb">“输出类型”子操作符（包括“数量更改”）具有定义“优先级顺序”和“执行顺序”的选项。创建复杂设置时，请务必注意这些选项。 </p>
         <div class="bodyReference"><a name="FIG_FD2B45D2893B46508D6B3F8C6DBA454F"></a><div class="figure-anchor"><img src="../images/GUID-FE4B192D-D2B2-4267-B08A-4753FBCDDAA9-low.jpg"></div>
            <p><a name="GUID-E1C488EA-7A7C-4692-BDA3-86057F744FD0"></a> 数据修改和处理的顺序由“输出”子操作符定义。“输出”子操作符使数据得到修改。“输出”子操作符从数据流中位于其上方的子操作符拉出粒子数据，并将数据设置为粒子属性。 
            </p>
            <p><a name="GUID-5E6E9AB7-B1FF-49EB-AF67-0D281615DC9B"></a>具有相同“执行顺序”值的“输出”子操作符处理相同的输入数据。当“执行顺序”值相同时，“优先级顺序”值定义“输出”子操作符从上游拉出数据的顺序。仅当拉出所有数据后，数据才会应用于粒子属性。 
            </p>
            <p><a name="GUID-E9EC30FE-0CA5-40A1-9D2F-C2F7CA4ABFCC"></a>如果子操作符具有不同的“执行顺序”值，则它们可能处理不同的输入数据，即使它们从相同的“输入”子操作符中拉出数据也是如此。这是因为执行顺序较低的“输出”子操作符可能更改某些粒子属性中的数据。当执行顺序较高的“输出”子操作符拉出数据时，这些数据已经被修改。
               
            </p>
            <p><a name="GUID-8BFC811D-527B-4A00-8E6D-F10E083CBA2F"></a>请考虑以下示例：当粒子进入某个事件时，您需要计算所有新粒子的初始值。然后需要修改每一帧中的粒子属性（无论事件中的粒子是新粒子还是旧粒子），在此修改过程中，需要设置所有粒子的初始值。 
            </p>
            <p><a name="GUID-71658C5A-8F4D-4885-A16C-A68D106F3B5D"></a>在这种情况下，您有两个数据流：第一个流用于计算初始值；第二个流用于修改粒子属性。第一个流的“输出”子操作符的“执行顺序”应为 1，且极有可能其过滤器输入将被设置为“输入标准”<img class="adsk-glyph-arrow" src="../images/ac.menuaro.gif">“事件中的新粒子”。第二个流的“输出”子操作符的“执行顺序”应为 2。 
            </p>
            <p><a name="GUID-956D9F33-5F07-4CE7-98EA-11B104F83325"></a>考虑另一种情况：您希望分析所有粒子的速度数据，然后，根据某些条件，您希望定义粒子的两个子集，每个子集的速度将以不同的方式进行修改。在这种情况下，您需要使用两个具有相同执行顺序的“输出”子操作符。这样，您就可以保证每个输出的初始输入速度值是相同的。
               
            </p>
            <p><a name="GUID-9D3241F6-9001-433E-B5C4-D1768FF71AED"></a>另外，由于“数量更改”子操作符更改了粒子的数量，所以该子操作符不能与任何其他子操作符共享“执行顺序”值。程序中的保护措施可防止您进行共享。 
            </p>
            <p><a name="GUID-D1697B1D-D775-459A-9E7F-EFAC06D0A833"></a>此外，“执行和优先级顺序”组也具有“前/正常/后”单选按钮。该选项在较高的级别上定义处理顺序。如果将顺序设置为“前”，则在执行当前事件中的任意操作符前，此输出已完成。如果将顺序设置为“正常”，则“输出”子操作符按常规顺序执行，即在同一事件中，在其他操作符之间进行。如果将顺序设置为“后”，则当该粒子系统中所有的操作符和测试完成各自在积分步长中的工作时，才处理输出。
               
            </p>
            <p><a name="GUID-1633B9B2-4705-4FB1-9AF9-7DF7269B5236"></a>有关说明“前/正常/后”用法的示例，请打开附带的文件 <em class="mild"> <span class="filePath">CollisionAsBody.max</span> </em>。 
            </p><a name="FIG_5A28097960554CFBB0818FC8DD60081F"></a><div class="figure-anchor"><img src="../images/GUID-20CCAD3C-8744-43DF-961A-FF7A17F5F61F-low.png"></div>
            <p><a name="GUID-1244DE8B-A10A-44CF-9724-802014D8C15B"></a> 此示例使用“数据”操作符来产生“开销低且快速”的全体碰撞。正如您所知，涉及到碰撞和导向器，<span class="charspan-msgph">3ds Max</span> 中的粒子系统将粒子作为点实体进行处理。因此，如果粒子图形的大小可见，图形就会穿透导向器表面，这将会破坏总体视觉效果。该示例显示了如何关联粒子数据，从而根据互相穿透的数量来偏移粒子位置。 
            </p>
            <p><a name="GUID-6C1F6B12-45CA-48BA-8F51-3C6BA4BE0BDB"></a>首先，我们创建一个自定义数据通道来存储实数值，因为需要位置偏移来避免穿透。对于所有新粒子，我们将此值的初始值设置为零（请参见数据块 01）。 
            </p>
            <p><a name="GUID-55EABD7A-D61C-43B1-9672-5EC96451D772"></a>当所有其他操作符和测试完成各自的工作后，我们会计算渗透的数量，并在“后”阶段中偏移粒子位置。这样，粒子位置进行了调整，以防止穿透，且粒子将准备好进行渲染。右侧的“输出”操作符在“后”阶段中执行各自的工作。 
            </p>
            <p><a name="GUID-D405F2F6-264D-4AC8-9110-34CA9E62D333"></a>然后，在“前”阶段，我们需要将粒子移回到它们无偏移的位置，让碰撞检测继续进行，就如同未发生偏移。 
            </p>
            <div class="section"><a name="AB1005050"></a> 
               <h2><a name="GUID-EB96ED64-74AF-4E30-8437-F22CC4AA4CF7"></a>历史依赖型
               </h2> 
               <p><a name="GUID-5B582C4B-4401-4FED-AFDE-1415BA3B1884"></a>粒子系统本质上为历史依赖型。也就是说，要能够确定粒子系统在诸如第 100 帧上的状态，该软件需要计算自第一个粒子产生后，所有先前帧的状态。这是因为粒子属性（例如，粒子的位置）所发生的更改随着其他参数（例如，速度）持续更改而不断积累。 
               </p> 
               <p><a name="GUID-D2BE7AA0-3781-4614-8194-FC4C475B2724"></a>但是，对于某些特定的设置，一些特定的属性不是历史依赖型，且可以从粒子的当前状态进行计算。例如，当粒子“注视”摄像机等物体时，粒子的方向，或跟随粒子的速度。此时，粒子的方向取决于粒子的位置（如朝向摄影机时），或粒子的速度。在这种情况下，要计算粒子当前的方向，您无需了解粒子的全部历史；只需了解它们当前的速度或位置即可。
                  
               </p> 
               <p><a name="GUID-692BB881-473C-441A-B3B0-51A25183B524"></a>在这种情况下，用于计算粒子方向的操作符不是历史依赖型。当系统为了到达当前帧而穿过之前所有帧时，操作符不需要执行任何操作。该操作符只需在最终帧上进行操作，以分析最终帧里粒子的位置/速度，并计算相应的粒子方向。 
               </p> 
               <p><a name="GUID-C15AE183-FB31-4B76-B68B-90389385660E"></a>如果您确定“输出”子操作符的结果不取决于粒子的历史，您可以禁用“历史依赖型”选项。这可以加快整体计算，因为它会使“数据”操作符仅在最后一帧上操作。 
               </p> 
            </div>
         </div>
         <div class="footer-block"><a href=".." class="comments-anchor" target="_blank"><span class="comments-link">请将您关于此页内容的评论发送给我们</span></a></div><br><p class="footer-license-block"><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank"><img alt="Creative Commons License" style="border-width: 0;" src="../images/ccLink.png"></a>&nbsp;<em>除非另有说明，否则此作品受到 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank"> Creative Commons 署名-非商业性使用-相同方式共享 3.0 未本地化版本许可证</a>的制约。请参见 <a href="http://autodesk.com/creativecommons" target="_blank">Autodesk Creative Commons 常见问题</a>(英文)以获取更多信息。</em></p><br></div>
   </body>
</html>