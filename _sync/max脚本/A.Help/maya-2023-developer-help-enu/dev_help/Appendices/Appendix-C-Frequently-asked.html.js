var topic = "<!-- saved from url=(0024)http://docs.autodesk.com -->\n\
<html>\n\
   <head>\n\
<link href=\"../../style/prettify.css\" type=\"text/css\" rel=\"stylesheet\" />\n\
<script type=\"text/javascript\" src=\"../../scripts/prettify.js\"></script><script src=\"../../scripts/lib/jquery-1.11.1.min.js\" type=\"text/javascript\"></script><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /><meta http-equiv=\"Content-Style-Type\" content=\"text/css\" /><meta name=\"generator\" content=\"pandoc\" /><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /><script type=\"text/javascript\" src=\"../../scripts/utils/adsk.redirect.js\"></script>\n\
      <title>Appendix C: Frequently asked questions</title>\n\
   </head>\n\
   <body height=\"100%\"><div class=\"body_content\" id=\"body-content\"><style type=\"text/css\">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs(\"./scripts/multireflink.js\"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id=\"reflinkdiv\"></div>\n\
      <div>\n\
         <div class=\"head\">\n\
            <h1>Appendix C: Frequently asked questions</h1>\n\
         </div>\n\
\n\
<div class=\'section\'><a id=\"appendix-c-frequently-asked-questions\"></a></div>\n\
<p>This list is a compilation of questions received from programmers using the Maya API. A set of categories has been defined (see the list below), and the questions have been organized into these categories to make the presentation more logical.</p>\n\
<p>The current list of Categories is:</p>\n\
<ul>\n\
<li><a href=\'#!/url=./dev_help/Appendices/Appendix-C-Frequently-asked.html#general-questions\' title=\'\'>General Questions</a></li>\n\
<li><a href=\'#!/url=./dev_help/Appendices/Appendix-C-Frequently-asked.html#documentation-questions\' title=\'\'>Documentation Questions</a></li>\n\
<li><a href=\'#!/url=./dev_help/Appendices/Appendix-C-Frequently-asked.html#dependency-graph-questions\' title=\'\'>Dependency Graph Questions</a></li>\n\
<li><a href=\'#!/url=./dev_help/Appendices/Appendix-C-Frequently-asked.html#gui-questions\' title=\'\'>GUI Questions</a></li>\n\
<li><a href=\'#!/url=./dev_help/Appendices/Appendix-C-Frequently-asked.html#animation-questions\' title=\'\'>Animation Questions</a></li>\n\
<li><a href=\'#!/url=./dev_help/Appendices/Appendix-C-Frequently-asked.html#windows-questions\' title=\'\'>Windows Questions</a></li>\n\
</ul>\n\
<div class=\'section\'><a id=\"general-questions\"></a><h2 id=\"general-questions\">General Questions</h2></div>\n\
<p>Q:</p>\n\
<p>How do I know what units an API method returns?</p>\n\
<p>A:</p>\n\
<p>Unless otherwise specified all API methods use Maya internal units: cm and radians.</p>\n\
<p>Q:</p>\n\
<p>Is there a stand-alone mode similar to OpenModel? Or, would a stand-alone be similar to Avid® Softimage® where the basic software package (and license) is required?</p>\n\
<p>A:</p>\n\
<p>Yes. The <em>Setting up your plug-in build environment</em> chapter in the API guide and the documentation on the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MLibrary\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_library.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MLibrary</a></span> class describe how to set this up and use it. There are also several example stand-alone applications. Descriptions of these can be found in the <em>Example Plug-ins</em> chapter in the API guide.</p>\n\
<p>Q:</p>\n\
<p>While OpenModel presents the same API interface as OpenAlias, many of the function calls (even the non-UI ones) work differently or not at all in OpenModel. The lack of render control is a prime example, where some parts of the same function set work and others don’t. This is extremely frustrating, especially since the renderer is a very likely candidate for being done in batch. I cannot tell if the same disparities will show up with Maya in batch and interactive modes, but I will be quite disappointed in they do.</p>\n\
<p>A:</p>\n\
<p>This problem should not exist in the Maya API. Of course, UI calls will not work when run in library mode, but all other calls should behave identically.</p>\n\
<p>Q:</p>\n\
<p>The use of angular units is inconsistent. In Maya’s attribute window, transform rotations are given in degrees. However, in the API, attaching to the rotation attributes requires writing out radians. When writing out values for keyframes, we want to be consistent with what we see in the UI.</p>\n\
<p>A:</p>\n\
<p>When dealing with the UI, the API uses the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MAngle\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_angle.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_angle.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MAngle</a></span> class. This class contains a method &quot;uiUnit&quot; that returns the unit the user has chosen in the UI. This value is a user preference that can be changed at any time. The <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MAngle\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_angle.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_angle.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MAngle</a></span> class defaults to radians in all cases so that plug-in code does not have to adjust to the UI preference currently in effect. You can adjust to the units that have been set by the UI user with the following code:</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\"><a href=\"javascript:void(0)\" data-symbol=\"MAngle\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_angle.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_angle.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MAngle</a> foo;\n\
foo.setInternalUnit( foo.uiUnit() );\n\
\n\
</pre></div><p>After this, all new MAngle instances will operate in the same units as the UI, until, of course, the UI user changes his/her preferences again.</p>\n\
<p>Additionally, the rotation functions in the transform class deal in doubles that represent radians for efficiency reasons, as that is what the underlying implementation demands. If you are acquiring angular data from the UI, you should access it via the asMAngle method in <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MArgList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MArgList</a></span> and use the asRadians method to extract the value required by the transform class.</p>\n\
<p>Q:</p>\n\
<p>We want to modify the blind_data example to add a multidimensional array as a dynamic attribute, but don’t know which <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnAttribute\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_attribute.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnAttribute</a></span> class is the most appropriate for this operation.</p>\n\
<p>A:</p>\n\
<p>However, you can make an attribute, of whatever type, and turn it into an array by calling the setArray method of the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnAttribute\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_attribute.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnAttribute</a></span> class. If you need a multidimensional array, you will have to build it on top of this using some form of index conversion.</p>\n\
<p>If this is not sufficient, another option is to derive a whole new data type off <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxData\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_data.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPxData</a></span> that can directly store a multidimensional array. This is more work however, and you will need to implement the readASCII, writeASCII, readBinary, and writeBinary virtual methods derived from <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxData\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_data.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPxData</a></span> in order for the new data type to save and restore correctly. There are 3 example plugins provided that demonstrate how this is accomplished: blindShortDataCmd.cc, blindDoubleDataCmd.cc and blindComplexDataCmd.cc.</p>\n\
<p>Q:</p>\n\
<p>How can we get notified when an attribute of a node changes?</p>\n\
<p>A:</p>\n\
<p>There is a hierarchy of classes rooted at the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MMessage\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_message.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_message.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MMessage</a></span> class in the API that provide a way for you do register callback functions that will be invoked when a particular Maya event occurs. There is a large set of message that, among other things, allow you to find out when an attribute changes.</p>\n\
<p>Q:</p>\n\
<p>How to we bake data via the API?</p>\n\
<p>A:</p>\n\
<p>The &quot;bakeResults&quot; command can be used to bake animation data. All expressions, motionPaths, animCurves, and so on, are replaced in the dependency graph with a single animCurve that will produce the same motion. You can access this functionality via the &quot;<span class=\'code\'>MGlobal::executeCommand</span>&quot; method.</p>\n\
<p>As well, the MEL command delete (-ch option) removes construction history for an object. From the API, you will also have to access this via the <span class=\'code\'>MGlobal::executeCommand</span> method. Access to this functionality is also available from the UI under Edit &gt; Delete by Type &gt; History menu item.</p>\n\
<p>Q:</p>\n\
<p>The <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsSurface::cv()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_surface.html#a5515c447151ff822c987916fc5ab9abd&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_surface.html#a985f287ca0c8f74062817356fe3dfbb7&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsSurface::cv()</a></span> method returns an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MObject\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MObject</a></span>, but it is unclear what function set can be used to access the returned information. A function set that operates on a class that represents CVs or that operates on <span class=\'code\'>MPoints</span> does not exist.</p>\n\
<p>A:</p>\n\
<p>Use the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSurfaceCV\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_surface_c_v.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_surface_c_v.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSurfaceCV</a></span> function set. While this might be a little counter-intuitive, the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MObject\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MObject</a></span> returned by the CV method actually returns a component structure that can contain multiple CVs of an object, and so the CV iterator is required to unpack it and get at the CV data.</p>\n\
<p>Q:</p>\n\
<p>When a group node is selected, all objects in the group are highlighted as if they are selected, but the global selection list only has the group node in it. Is this the way it’s supposed to be? It seems to me that everything in the group would be in the list, since they are all selected. (I’m constructing an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSelectionList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSelectionList</a></span> from the global active selection list and using <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFn::kInvalid\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a94dd08feda7b2cf0ff8262312c4fcc09&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFn::kInvalid</a></span> as the filter...)</p>\n\
<p>A:</p>\n\
<p>This is indeed the way it works. This is not an issue with the API or <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSelectionList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSelectionList</a></span>, but rather the way Maya works. You can see identical behavior by starting the Hypergraph ( Window &gt; Hypergraph: Hierarchy) and then:</p>\n\
<ul>\n\
<li>create two or three primitives</li>\n\
<li>select them all</li>\n\
<li>select Edit &gt; Group</li>\n\
</ul>\n\
<p>Notice in the Hypergraph that only the group transform, &quot;group1&quot; is &quot;selected&quot;, even though all the primitives in the group are &quot;highlighted&quot;. As far as Maya is concerned, only the one node is selected, and so that single node is the only one returned by <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSelectionList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSelectionList</a></span>. You certainly can select the individual primitives in the Hypergraph, or by name using MEL, but the UI only selects the group transform.</p>\n\
<p>However, you can get the list of objects that are &quot;highlighted&quot; when the transform is selected via the API call <span class=\'code\'>MGlobal::getHiliteList</span>.</p>\n\
<p>Q:</p>\n\
<p>This question concerns simple API array structures, like the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPointArray\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_point_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_point_array.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPointArray</a></span>. Is the data stored in an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPointArray\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_point_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_point_array.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPointArray</a></span> contiguous, or is it stored as a linked list?</p>\n\
<p>In other words, does the append() method just add another element on (as in a linked list) or is it doing the equivalent of a realloc() function (allocates a new contiguous block of data plus one element, and then copies the old data over)?</p>\n\
<p>A:</p>\n\
<p>It is not a linked list, however, neither does it do a realloc on each append (or insert either). Instead, it manages a logical/physical space model, and expands the physical space by a user-configurable number of elements when more is needed.</p>\n\
<p>All the &quot;*Array&quot; should contain the methods &quot;sizeIncrement&quot;, and &quot;setSizeIncrement&quot;. The former tells you by how many elements the array will grow when it needs to, and the later allows you to change that value.</p>\n\
<p>As of Maya 2.0, the constructors for all the array classes accept an initial size parameter. So if you know the size of your array in advance, you can completely avoid any growing/copying overhead in the array.</p>\n\
<p>Q:</p>\n\
<p>Why is a new instance of a command created every time it is invoked from the command window? Is this somehow related to Maya’s undo capability? When do these instances of the command object get deleted?</p>\n\
<p>A:</p>\n\
<p>Maya implements its infinite undo capability as follows:</p>\n\
<p>When a command or tool is invoked, the creator function for that object will be called to create a new instance. That instance must contain local data members sufficient to retain state so that when its doIt method is called, it can save enough state to:</p>\n\
<ul>\n\
<li>undo what it is about to do</li>\n\
<li>redo what it is about to do</li>\n\
</ul>\n\
<p>Typically, a command’s doIt method will just save the current state of what it is about to change for undo, then cache the parameters of the &quot;about to be performed&quot; operation and call redoIt.</p>\n\
<p>redoIt operates off the cached parameters, and if called from the undo manager, can &quot;redo&quot; the operation without any further user interaction.</p>\n\
<p>undo also operates off the cached data, and can also work without any further user interaction.</p>\n\
<p>Additionally, when a tool is &quot;finished&quot;, its virtual method &quot;finalize&quot; (that is provided in the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxToolCommand\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPxToolCommand</a></span> base class) will be called. This routine is responsible for constructing an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MArgList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MArgList</a></span> containing a command that will &quot;redo&quot; the operation. This command string is written in to the Maya Journal to record all the operations that have taken place.</p>\n\
<p>If the virtual method <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxCommand::isUndoable()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px_command.html#a2f6c567cc02d575ab14006d9c5e37761&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_command.html#a31978f979fb290149f118d3bcba9e9d6&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPxCommand::isUndoable()</a></span> is overridden and made to return &quot;false&quot; (it defaults in the base class to &quot;true&quot;), then right after the doIt method is called, Maya will call the destructor for the command instance. Otherwise, the instance is passed to the undo manager which will call its undoIt and redoIt members to implement undo and redo requests. When the undo queue is flushed, all the instances of the commands or tools are destroyed, thus freeing the local memory that is caching the parameters needed for undo or redo.</p>\n\
<p>Q:</p>\n\
<p>Regardless of whether a single CV or multiple CVs are selected via the UI, the MItSelectionList iterator will only return one selection item. If multiple CVs were selected, how can I find which ones?</p>\n\
<p>A:</p>\n\
<p>If you select a multiple CVs, and then use the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSelectionList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSelectionList</a></span> iterator class of the API, all the selected CVs will be returned in a single component.</p>\n\
<p>To access the individual CVs you must use the getDagPath method of <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSelectionList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSelectionList</a></span>, which returns both a <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDagPath\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MDagPath</a></span> and a <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MObject\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MObject</a></span>, then pass these as arguments to the constructor of an iterator. For NURBS surfaces, the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSurfaceCV\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_surface_c_v.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_surface_c_v.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSurfaceCV</a></span> class would be used to extract the individual surface CVs. The iterators: <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItCurveCV\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_curve_c_v.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_curve_c_v.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItCurveCV</a></span>, <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItMeshVertex\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_mesh_vertex.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_mesh_vertex.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItMeshVertex</a></span>, <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItMeshEdge\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_mesh_edge.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_mesh_edge.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItMeshEdge</a></span> and <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItMeshPolygon\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_mesh_polygon.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_mesh_polygon.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItMeshPolygon</a></span> can be used to perform similar operations on NURBS curve, and the various components of polygonal objects. The lassoTool plug-in provides a good example of how this is done.</p>\n\
<p>Q:</p>\n\
<p>What is the meaning of the value that <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSurfaceCV::index()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_surface_c_v.html#ae85767d1d26fc7491279d1f2c277b499&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_surface_c_v.html#a2f521d9aa9ae0274a6ffcdd99f5471af&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSurfaceCV::index()</a></span> returns?</p>\n\
<p>A:</p>\n\
<p>One of the components of a NURBS surface is an array of CVs. The index method returns the position of the given CV in the array maintained by the surface. The UI represents this as a 2D array of CVs with rows and columns of CVs corresponding to U and V indices. Internally this is stored as a 1D array (row1, row2, row3, etc.) and index returns the position of the CV in this data structure. (Incidentally, if you created the surface via <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsSurface::create()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_surface.html#a6a3e914fe9c070228f4df8f4a593b4c8&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_surface.html#a86e0eb07dd4f21967d289e42043cf6af&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsSurface::create()</a></span>, this is the way you had to provide the CV array). You can convert this to a pair of 2D indices via:</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\">sizeInV = MFnNurbsSurfaceInstance.numCVsInV();\n\
indexU = index() / sizeInV;\n\
indexV = index() % sizeInV;\n\
\n\
</pre></div><p>The method getIndex of the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSurfaceCV\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_surface_c_v.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_surface_c_v.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSurfaceCV</a></span> class returns the indexU and indexV values using exactly this calculation</p>\n\
<p>Q:</p>\n\
<p>How can I compare two components of a object to see if they are the same? Specifically, I need to compare two CVs on a NURBS surface, but this problem appears to apply to all types components of both NURBS and polygonal objects.</p>\n\
<p>A:</p>\n\
<p>There is no simple mechanism for doing this. Components are identical if the are members of the same Dag path (the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDagPath\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MDagPath</a></span> class defines an == operator to perform this comparison), and if their indices, returned by the index methods of the various component iterators, are also the same.</p>\n\
<p>Q:</p>\n\
<p>I created an instance of an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsSurface\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsSurface</a></span> function set, and got good data out of it, however, I then called <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MGlobal::viewFrame()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_global.html#ac919b5ecda7f12015e94792c0712726f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_global.html#a8c4bf809056c4203f9d45a0b694bad42&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MGlobal::viewFrame()</a></span>, to move the animation to another frame. I know the surface moved, but I got the same data out of the function set as I did the first time. How can I make this work?</p>\n\
<p>A:</p>\n\
<p>You will have to restructure your code a little to make this work.</p>\n\
<p>After a call to <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MGlobal::viewFrame()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_global.html#ac919b5ecda7f12015e94792c0712726f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_global.html#a8c4bf809056c4203f9d45a0b694bad42&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MGlobal::viewFrame()</a></span>, is it necessary to rebind your function sets to the objects they are accessing. This can be handled by code that looks like the following:</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\"> <a href=\"javascript:void(0)\" data-symbol=\"MDagPath\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MDagPath</a> path;\n\
 // initialize path somehow to refer to the object in question\n\
 <a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsSurface\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsSurface</a> surf;\n\
 for (int i = 1; i &lt;= maxFrames; ++i) {\n\
     <a href=\"javascript:void(0)\" data-symbol=\"MGlobal::viewFrame\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_global.html#ac919b5ecda7f12015e94792c0712726f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MGlobal::viewFrame</a>(i);\n\
     surf.setObject(path);\n\
 }\n\
\n\
</pre></div><p>The <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDagPath\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MDagPath</a></span> will remain valid across frames, and thus can be used to rebind the function set to the object in each frame.</p>\n\
<div class=\'section\'><a id=\"documentation-questions\"></a><h2 id=\"documentation-questions\">Documentation Questions</h2></div>\n\
<p>Q:</p>\n\
<p>We would like to have full documentation on all the transformations on a CV as it is positioned in world space. For example, CVs end up in their global position via a number of matrices, clusters, functions, animations etc. Documentation of these transforms explicitly and exactly would be very useful.</p>\n\
<p>A:</p>\n\
<p>We believe that the set of possible transforms is both too complex and too dynamic to document in the general case. Take clusters for example. Clusters in Maya are implemented as deformers. This means that a deformer is put between the original surface and the new output surface.</p>\n\
<p>It is therefore possible to get the world transformation information from the deformed CV up to the world through the DAG shape that holds the deformation result. So, it is trivial to query the world space location of a point. We get that for free from our current implementation.</p>\n\
<p>However, the local to world transformation of any point is arbitrarily complex. Nodes can easily implement procedural transformations that don’t involve matrices at all. Conceptually, the architecture is one in which a point in local space is passed through a series of &quot;black boxes&quot; each of which affect its position and we simply don’t know what is in all of the boxes.</p>\n\
<p>This implies that we can’t set the position of a point (or CV) exactly in world space either. To do so would require computing the inverse of the local to world space transformation, and I have just been busy telling you we don’t know how to define that transform in general.</p>\n\
<p>That being said, if you are just interested in the order in which Maya’s transform node applies scale, rotation, translation and other transformations from its attributes to an object, this is described in detail in the documentation for the transform node in the Commands online documentation.</p>\n\
<div class=\'section\'><a id=\"dependency-graph-questions\"></a><h2 id=\"dependency-graph-questions\">Dependency Graph Questions</h2></div>\n\
<p>Q:</p>\n\
<p>Can we derive our own custom classes/nodes from the standard classes/nodes such that they will be correctly processed in the DG? This capability has been inferred to in the past and we just want to get the most recent confirmation on this capability.</p>\n\
<p>A:</p>\n\
<p>Maya maintains ownership of the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MObject\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MObject</a></span>s which it presents as opaque data. So it is not possible to derive from these objects.</p>\n\
<p>Additionally it isn’t possible to derive from Maya’s internal nodes. For example, let’s say you wanted to derive something from the internal revolve node. The revolve node, like all nodes, is simply a compute function on a set of attributes. To make modifications to this node you would require the source code to the compute method - which we can’t give you. Instead what can be done is to connect new (user-written) nodes (see the next paragraph) to the attributes of the Maya revolve node and use these new nodes to modify the input and output of that node. Alternatively, in this case, a new revolve node could be written and used in place of the system defined one.</p>\n\
<p>Maya Proxy objects are designed expressly for derivation, and allow new user nodes to be added to Maya.</p>\n\
<p>As well, it is possible to derive from the function sets to create new operations on the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MObject\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MObject</a></span>s (limited only by the fact that the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MObject\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MObject</a></span>s are opaque, and the source for the implementation of the function set members is unavailable).</p>\n\
<p>So, in summary, you can’t derive directly from Maya nodes, but you can create your own nodes, insert them into the dependency graph and have them either replace an existing Maya node, or modify the input or output parameters of Maya nodes.</p>\n\
<p>Q:</p>\n\
<p>It looks like the user-defined nodes are fundamentally different from the already existing nodes. If you look at something like <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsCurve\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsCurve</a></span>, you see that eventually, it is derived from <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnBase\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_base.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_base.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnBase</a></span>, but if you look in the circle example, you see that the &quot;circle&quot; is derived from <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxNode\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPxNode</a></span>.</p>\n\
<p>A:</p>\n\
<p>There is a fundamental difference between &quot;function sets&quot; and &quot;maya objects&quot;. Maya internal objects (which include dependency nodes) are encapsulated in <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MObject\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MObject</a></span>s and function sets, which are indeed derived from <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnBase\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_base.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_base.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnBase</a></span>, are initialized &quot;with&quot; an MObject and then act upon it. This is sort of an &quot;outward &gt; in&quot; kind of paradigm in which user written code is allowed to affect the internals of Maya objects.</p>\n\
<p>To create a user-defined dependency node, we have to do something completely different, which is why the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxNode\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPxNode</a></span> classes are necessary. Effectively, what we do is create a new internal Maya node, and &quot;hook up&quot; its methods to the ones defined in the customer generated node. For example, if during the evaluation of the dependency graph it is necessary to &quot;recompute&quot; a user defined node, what happens is:</p>\n\
<ul>\n\
<li>dependency graph evaluator calls the compute method for our &quot;internal node&quot;</li>\n\
<li>its compute function calls out to the compute function of the user written node, gets the result, and</li>\n\
<li>passes the result on.</li>\n\
</ul>\n\
<p>This is repeated for any of the attributes of the node that require recomputation. This is sort of an &quot;inward &gt; out&quot; kind of paradigm in which internal Maya objects have to call a user written compute function.</p>\n\
<p>So, yes there are fundamental differences, but that is intentional and caused by the fact that the problems are fundamentally different.</p>\n\
<p>Q:</p>\n\
<p>It is also unclear if we can accomplish a &quot;persistent&quot; effect through the API. That is, if the CV gets altered, the arclen will change. So anything that is attached to our arclen attribute would need to be moved or sized accordingly.</p>\n\
<p>A:</p>\n\
<p>As long as the propagation of values is done through connections in the dependency graph, this is taken care of automatically. For example:</p>\n\
<p>MayaNodeA.cvSet &gt; customerNode.input &gt; CustomerNode.output(computes scale from arclen) &gt; MayaNodeB.scale</p>\n\
<p>A change in a CV in MayaNodeA automatically forces a recompute in CustomerNode and MayaNodeB, and the object is moved or sized accordingly.</p>\n\
<p>Q:</p>\n\
<p>We want to be able to drive an attribute of one object by a derivable value of another object. For example, we may want to drive the scale of one object by the arclen of a curve. Or we may want to translate an object according to the evaluated value of a curve at a particular parametric value. The examples show how to instantiate a dependency node that allows us to tie together attributes of objects, but can we take it one step further and have the driving value be an evaluated value, e.g. myNurbsCurve.arclen() or myNurbsCurve.point(0.5)?</p>\n\
<p>Additionally when creating your own node, can you create an input attribute that takes a node or <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MObject\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MObject</a></span> as its input, rather than a float or a string? This would allow us to jump back into the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsCurve\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsCurve</a></span> and use whatever derived methods we want.</p>\n\
<p>A:</p>\n\
<p>Such a construct is fairly easily handed in the Maya architecture by writing a node that has an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnTypedAttribute\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_typed_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_typed_attribute.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnTypedAttribute</a></span>. One parameter of the declaration of such an attribute is the &quot;type&quot; it accepts as input. It is quite possible to specify it as taking a nurbsCurve by using the type &quot;<span class=\'code\'>kNurbsCurve</span>&quot;. Since your node will then have the actual curve, you can compute anything you want based upon it.</p>\n\
<p>So the node I think you want to write would have a nurbsCurve input attribute, and three double (scale) output parameters. All you need to do is connect this node to a node that produces a curve in the input, connect its outputs to the scale inputs of the node you want to animate, and the dependency graph will do the rest. Any change in the curve node will automatically propagate through the graph and update the scale of the final object. The example plug-in called arcLenNode demonstrates how to do this.</p>\n\
<p>Furthermore, inside your node, you will really have a nurbsCurve object, and thus you can attach a <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsCurve\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsCurve</a></span> function set to that object. Then you can use any of its methods that compute values you need. The &quot;length&quot; function will compute the arclen of the curve, and the &quot;pointAtParm&quot; method will return a point at a particular parameter value.</p>\n\
<p>As well, a similar result can be obtained by simply hooking together existing dependency nodes. For example, the subCurve and curveInfo nodes allow you compute the arclen of a subcurve as shown below:</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\">global float $arclen;\n\
// Create a curve\n\
curve -p -5 0 8 -p -9 0 2 -p -3 0 5 -p -6 0 -2\n\
 -p 1 0 3 -p -4 0 -5 -p 4 0 1;\n\
 // Create a node to extract part of a curve,\n\
 // set the parts to keep, and attach it to\n\
 // the curve created above.\n\
 createNode -n subCurve1 subCurve;\n\
 setAttr subCurve1.minValue 0.4;\n\
 setAttr subCurve1.maxValue 1.4;\n\
 connectAttr curveShape1.local subCurve1.inputCurve;\n\
 // Create a curveInfo node, and connect\n\
 // it to the output of the subcurve.\n\
 createNode -n curveInfo1 curveInfo;\n\
 connectAttr subCurve1.outputCurve curveInfo1.inputCurve;\n\
 // Get the arclen of the subcurve from the\n\
 // curveInfo node and print it.\n\
 $arclen =`getAttr curveInfo1.arcLength`;\n\
 print(&quot;curve[0.4:1.4] has arclen &quot; + $arclen + &quot;\\n&quot;);\n\
 // Change the part of the curve extracted by the\n\
 // subCurve node and print the new arclen\n\
 setAttr subCurve1.minValue 0.0;\n\
 setAttr subCurve1.maxValue 5.0;\n\
 $arclen =`getAttr curveInfo1.arcLength`;\n\
 print(&quot;curve[0.0:5.0] has arclen &quot; + $arclen + &quot;\\n&quot;);\n\
\n\
</pre></div><p>Q:</p>\n\
<p>I need a better understanding of the differences between DagNodes and Dependency Nodes and how these relate to the API object classes. In particular, how do I know when to use the getDagPath method from the MItSelectionList iterator, and when do I use getDependNode?</p>\n\
<p>A:</p>\n\
<p>A DAG nodes describe how an instance of an object is constructed from a piece of geometry. For example, when you create a sphere, you create both a geometry node (the sphere itself) and a Transform Node that allows you to specify where the sphere is located, its scaling, etc. It is quite possible to have multiple transform nodes attached to the same piece of geometry. For example:</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/comp_Transform06.png\' title=\'\' /></div>\n\
<p>The dependency graph, however, is something new. All DAG nodes are also dependency nodes, but not vice-versa. For example there is a &quot;time1&quot; dependency node that can produce the frame number of the current animation. The &quot;circleNode&quot; and &quot;sineNode&quot; types created by the &quot;circle.cc&quot; and &quot;sine.cc&quot; plug-in examples are dependency nodes, however, they are not part of the DAG. Instead dependency nodes can be wired together to provide a dynamic evaluation graph that can end up affecting DAG nodes (and thus affecting what is drawn). For example,</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/comp_Transform07.png\' title=\'\' /></div>\n\
<p>In this example the x, y, and z scale parameters of Transform3 are driven by the frame number. Thus as the animation is run, the 2 instances of the sphere will grow.</p>\n\
<p>So, now from the API, how do you know when to used getDagPath and when to use getDependNode?</p>\n\
<p>Well, if you pick something on the screen with the mouse then you will always be picking an instance and thus you will always have a DAG node available, and you should use getDagPath.</p>\n\
<p>If you pick something by name, then you might or might not get a DAG node. The right thing to do in this case is ask. The <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MItSelectionList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MItSelectionList</a></span> iterator’s &quot;itemType&quot; method will return an element of an enum that will differentiate between the two node types, you can then call getDagPath or getDependNode as appropriate.</p>\n\
<p>Yet another important thing to understand in Maya is that geometry DAG nodes do not have transformation matrices. They rely on the transform nodes above them for their transformation information. Because of this, selection of geometry in 3D views always causes the transform node above the geometry be selected rather than the actual geometry node. This allows all of the transformation tools to work properly.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/comp_Transform08.png\' title=\'\' /></div>\n\
<p>So, in the above diagram, clicking on Sphere1 in a 3D view will cause Transform2 to be selected.</p>\n\
<p>For instance, if you are iterating through the selection list looking for the sphere and you want to perform an operation upon the sphere’s CVs, in the iteration, you will eventually come to Transform2.</p>\n\
<p>If you get Transform2 as a dependency node (via getDependNode), then you have a transform node. From this transform node, you will not be able to find either the sphere or its CVs. Additionally, if your object is instanced (as in the first diagram), then you will have lost the information about which instance was selected.</p>\n\
<p>If you get Transform2 as a DAG node, you will get a DAG path object. The DAG path object is more intelligent. It knows where the transform resides in the DAG. If you give the DAG path to the NURBS surface function set (or the iterator), then the sphere node under the transform will be found automatically and the CVs will be available for modification.</p>\n\
<p>Q:</p>\n\
<p>I can’t figure out how to get the transform matrix of an object. I have played around with attaching the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnTransform\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_transform.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_transform.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnTransform</a></span> function set to dependency node and dag paths, but can’t quite seem to get it right.</p>\n\
<p>A:</p>\n\
<p>You were close. To accomplish this you must first get a DAG path structure for the object, then attach the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnTransform\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_transform.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_transform.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnTransform</a></span> function set to it. You can use that to get a <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MTransformationMatrix\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_transformation_matrix.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_transformation_matrix.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MTransformationMatrix</a></span> object, which can access and update the transform for the object in numerous ways, including returning the entire matrix. To solve your problem you would include code like:</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\"> <a href=\"javascript:void(0)\" data-symbol=\"MDagPath\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MDagPath</a> mdagPath;\n\
 <a href=\"javascript:void(0)\" data-symbol=\"MStatus\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MStatus</a> status;\n\
 <a href=\"javascript:void(0)\" data-symbol=\"MTransformationMatrix\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_transformation_matrix.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_transformation_matrix.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MTransformationMatrix</a> transform;\n\
 <a href=\"javascript:void(0)\" data-symbol=\"MMatrix\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_matrix.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MMatrix</a> matrix;\n\
 if ( mdagPath.hasFn(<a href=\"javascript:void(0)\" data-symbol=\"MFn::kTransform\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7adafa274206df602835f0f22ae887e126&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFn::kTransform</a>) ) {\n\
     // Get the transform matrix via the Dag path.\n\
     <a href=\"javascript:void(0)\" data-symbol=\"MFnTransform\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_transform.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_transform.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnTransform</a> transformNode(mdagPath,&amp;status);\n\
     // Get the transform matrix via the function set\n\
     transform = transformNode.transformation(&amp;status);\n\
     matrix = transform.asMatrix();\n\
     ...\n\
 }\n\
\n\
</pre></div><p>Q:</p>\n\
<p>How can I create a revolve-like plug-in, and have it take a curve, create a surface from it, and when the curve is modified, regenerate the surface?</p>\n\
<p>A:</p>\n\
<p>In order to implement this &quot;history&quot; functionality, you must write your own &quot;revolve&quot; node. It will take the curve as input (using the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnTypedAttribute\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_typed_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_typed_attribute.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnTypedAttribute</a></span> - see the arcLenNode plug-in) and output a surface. The output attribute of this node should then be connected to the create attribute of a nurbsSurface node which will draw it. In MEL the typical way to hook this up would be:</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\"> createNode transform -n revolvedSurface1;\n\
 createNode nurbsSurface -n revolvedSurfaceShape1 -p revolvedSurface1;\n\
 createNode yourRevolveNode -n yourRevolveNode1;\n\
 connectAttr yourRevolveNode1.outputSurface revolvedSurfaceShape1.create\n\
\n\
</pre></div><p>The simpleLoftNode example plug-in and provides a good example of how to do this.</p>\n\
<p>Q:</p>\n\
<p>If I set up a deformation in Maya, and then traverse the DAG tree from a plug-in, under the transform node for the deformed surface I see two shape nodes, both of which can be interpreted as <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsSurface\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsSurface</a></span> - one is the deformed shape, and one is the shape in some neutral position. I need a flag to indicate which is the neutral position, so I know that it’s not really there, and don’t need to operate on it.</p>\n\
<p>A:</p>\n\
<p>The 2 surfaces are differentiated by their boolean intermediateObject attributes. If value of the attribute is TRUE, then this node is the input surface for the deformation and can be ignored.</p>\n\
<p>You can check the value of this attribute by creating a plug for this attribute on for each of the two nodes, and then get the value of the attribute from the plug. Alternatively, the convenience routine isIntermediateObject in the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnDagNode\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_dag_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_dag_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnDagNode</a></span> function set performs this operation.</p>\n\
<p>Q:</p>\n\
<p>How can one use Maya multi attributes to implement an array of a user defined data type?</p>\n\
<p>A:</p>\n\
<p>This is not how you implement arrays of a user defined data type. When dealing with user defined data, Maya doesn’t know or care what the data looks like. As you point out, it is tempting to create one data type and then attempt to create multiple instances of it via multi-plugs, but multi-plugs were designed for multiple connections in the DG rather than data storage, so this won’t work.</p>\n\
<p>Instead, to implement an array of data, one must create the array inside a user defined data type and use the method outlined in the blindComplexDataCmd example to access that array. For example,</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\">class blindComplexData : class <a href=\"javascript:void(0)\" data-symbol=\"MPxData\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_data.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPxData</a> {\n\
    public:\n\
        // override methods like readBinary()....\n\
        // define any data you want, for example, an array of integers\n\
        int a[12];\n\
};\n\
\n\
</pre></div><p>After adding the above user-defined data as a dynamic attribute, access the data by attaching a plug to it the usual way and do a getValue() to get a handle to the data. Once you have the handle, convert it to a pointer to an instance of your custom data type.</p>\n\
<p>Q:</p>\n\
<p>Given a NURBS surface that is implemented via a cluster, moving the CVs of this surface via the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsSurface\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsSurface</a></span> function set seems to have no effect. Why is this, and how can this be done?</p>\n\
<p>A:</p>\n\
<p>If clusters are present, then you have a deformer network which is computing the shape of the surface that appears in the Dag. If you move a CV on that &quot;final &amp; visible&quot; surface, the deformer will simply move it back since the deformer is creating that surface. There are two ways to cope with this. First, find the &quot;intermediate object&quot; that is the input surface to the deformer and move the CV there. The problem with this approach is that it is difficult to predict what effect moving an input CV will have on its position on the output surface.</p>\n\
<p>The other approach is via tweaks which provide the capability to move (or tweak) a CV after a deformer has determined its position. There is no specific API in <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnNurbsSurface\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnNurbsSurface</a></span> for handling tweaks (and there won’t be for Maya 1.0) but you can create a tweak by directly modifying the attributes of the nurbsSurface dependency node. To do a tweak you must:</p>\n\
<ul>\n\
<li>set the boolean attribute &quot;tweak&quot; to true.</li>\n\
<li>Create a CV array with the same dimensions as the input surface to the nurbsSurface node, and</li>\n\
<li>initialize all the CVs in that array to [0,0,0].</li>\n\
<li>For the CVs you want to tweak, set the corresponding element in the CV data structure and then use setCVs to update the array.</li>\n\
</ul>\n\
<p>If the boolean attribute &quot;relativeTweak&quot; is true, the values in the CV array are used to move the corresponding CV relative to the position in which the deformer puts it, otherwise they are absolute positions of the CVs.</p>\n\
<div class=\'section\'><a id=\"gui-questions\"></a><h2 id=\"gui-questions\">GUI Questions</h2></div>\n\
<p>Q:</p>\n\
<p>Can a plug-in open its own graphics window (via winopen(), for example) and do graphics without interfering with the rest of Maya? If so, should it use OpenGL? How does it handle events (such as mouse movements within its own window) and still work with the rest of Maya? Does Maya provide an event handling mechanism that the plug-in can use and be compatible with the rest of Maya?</p>\n\
<p>A:</p>\n\
<p>Yes. In fact the helixMotifCmd example plug-in (not available on Windows) shows how to open a Motif window. You can also use OpenGL in such a window. There is one restriction however, Maya must retain control of the event loop. This should not be a problem however as your window simply needs to register callbacks for its UI elements, and Maya will happily invoke them for you.</p>\n\
<p>A question for you however is &quot;why do you really want to do this?&quot; As there are several other ways to create windows that you might prefer.</p>\n\
<p>First of all, the MEL scripting language in Maya allows you to create new windows and access virtually all Maya features. If you need a window for a dialog box, doing this in MEL is both easy and far and away the most efficient method of implementing such a feature.</p>\n\
<p>Maya also contains a new class called <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxLocatorNode\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px_locator_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_locator_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPxLocatorNode</a></span> that allows you to create DAG objects and provide a draw routine for them implemented with OpenGL calls. These objects are called locators because they do not render. So, you can use them for screen feedback, but not to create renderable objects. The example plug-ins footPrintNode and cvColorNode provide examples of how to create and use locators.</p>\n\
<p>As for input events, we currently supply an API class called MPxContext that allows you to handle such events. The example plug-ins marqueeTool, helixTool and lassoTool all demonstrate how to implement this.</p>\n\
<p>Q:</p>\n\
<p>How does one tell when both left and mid buttons are pressed at the same time? Right now only one is reported (I think).</p>\n\
<p>A:</p>\n\
<p>When you press a second button it does not generate an event but instead it is stuffed into the modifier for the hold event for the first button. For example, say the user presses the left mouse button. To see if the user has pressed the middle mouse button while the left is still down, check the modifier for the doHold event using <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MEvent::isModifierMiddleMouseButton()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html#aa5eabc07edb0d3568a4c9a6157a07fe7&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_event.html#a32c580030cdff12d91f4bc46e3c16cbe&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MEvent::isModifierMiddleMouseButton()</a></span>.</p>\n\
<p>Q:</p>\n\
<p>How can I tell which 3D window is active? I thought of using the camera name to do this, but this will fail if the user changes the camera name. I need a function returning which window the 3dview is (XY, XZ, YZ, pers).</p>\n\
<p>A:</p>\n\
<p>This is a little difficult. Because any view can be arbitrarily tumbled or changed into a perspective view, a general solution to this problem requires a bit of work.</p>\n\
<p><span class=\'code\'>M3dView::active3dView</span> will give you the active view from which you can get the camera. You can then use <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnCamera\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_camera.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_camera.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnCamera</a></span> methods upDirection and rightDirection to get the respective vectors, and compare them against <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MVector::xAxis\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_vector.html#a92793094b76cce4b93744104f691ec51&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MVector::xAxis</a></span>, <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MVector::xNegAxis\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_vector.html#a0cf1aaae54745b4295fc0047f3c4bcff&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MVector::xNegAxis</a></span>, etc. in order to determine the view that the user is seeing.</p>\n\
<p>Q:</p>\n\
<p>The viewToWorld method in <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"M3dView\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m3d_view.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">M3dView</a></span> correctly maps 2D coordinates to 3D coordinates in orthographic windows, but returns bogus value in its cursor argument in the perspective window.</p>\n\
<p>A:</p>\n\
<p>For the perspective view, you must use the version of viewToWorld which returns points on both the near and far clipping planes given a point in the 2D view. Any point on the line segment connecting those points is a valid solution to the mapping, and you will have to determine on your own which of these points you wish to use.</p>\n\
<div class=\'section\'><a id=\"animation-questions\"></a><h2 id=\"animation-questions\">Animation Questions</h2></div>\n\
<p>Q:</p>\n\
<p>Animation &quot;created&quot; in the DG via a user-defined node does not show up in the animation curve graphs, i.e. there is no way to see the results of procedurally generated animation.</p>\n\
<p>Only animation generated via keyframe animation shows up in the animation curve graphs.</p>\n\
<p>A:</p>\n\
<p>Unfortunately, this is unlikely to change. For a keyframed animation, we need only to check whether the node connected to an attribute is an animCurve node, if so, it is quite simple to extract the keyframed attribute values for display in the graph.</p>\n\
<p>For any other type of animation, we only know if it is an animation if somewhere in the graph connected to a particular attribute we find a time node.</p>\n\
<p>For a node which performs a procedural animation, we would actually have to run the entire animation, and save the output attribute values at each frame for display. This has the potential to be extremely computationally intensive. As well, the resulting curves would not be editable as they would be displaying only output values with no access to the knowledge on how they are computed.</p>\n\
<p>Q:</p>\n\
<p>I need in some way to be able to query any data at any animation frame. In OM/OA I do this by doing a viewFrame(x) and then checking the data. This is very slow however, and really what I might want to know is the position of this particular node at time x. In OM if you do a viewframe on a sub node it usually returns an incorrect value depending on how the animation has been set up.</p>\n\
<p>A:</p>\n\
<p>This should be better in Maya as the dependency graph will make sure that the &quot;subnode&quot; kind of information is always accurate.</p>\n\
<p>You can query the data you are interested in a manner quite similar to that in OM/OA: perform a viewframe, to set the time, then query the attributes (like tx, ty, tz, etc.) of the node you are interested in via the getValue methods of the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPlug\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_plug.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_plug.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPlug</a></span> class. As you point out however, this is somewhat slow, since viewframe changes the global time.</p>\n\
<p>In the Maya API you have another option however. You can create an instance of the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDGContext\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_d_g_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_d_g_context.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MDGContext</a></span> class initialized to the time you are interested in. This can be passed to the getValue method of the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPlug\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_plug.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_plug.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MPlug</a></span> class and the attribute you are interested in will be evaluated at the specified time. As much or as little of the dependencies as necessary will be reevaluated in order to ensure you get an accurate answer. Lots of dependencies on other nodes will make the evaluation slow. Otherwise it should be fast.</p>\n\
<p>You should also be aware that Maya does not maintain the state of animated objects at all possible keyframes so the only way to determine an object’s animation state at any particular time is by querying it at a particular time using one of the two methods described above.</p>\n\
<p>Q:</p>\n\
<p>Can time be set randomly with <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MGlobal::viewFrame()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_global.html#ac919b5ecda7f12015e94792c0712726f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_global.html#a8c4bf809056c4203f9d45a0b694bad42&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MGlobal::viewFrame()</a></span>? Are particles and IK stuff properly updated in all cases?</p>\n\
<p>A:</p>\n\
<p>You can set the time randomly, and everything will always be updated properly. However, the underlying mechanism is highly optimized towards monotonically increasing time. You can incur a large performance penalty when jumping time around randomly.</p>\n\
<p>Q:</p>\n\
<p>The method by which <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MFnMotionPath\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_motion_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MFnMotionPath</a></span> does its movement is unclear. In particular, how it interacts with the DAG tree. Suppose you have a Transform parenting a child shape. You can set keyframes and animate the translate channels and they turn green. Or you can do MotionPath and it doesn’t affect translate channels.</p>\n\
<p>Note that if you do have both MotionPath and translate, the MotionPath overrides the translate, and translate is ignored.</p>\n\
<p>What is the mechanism by which MotionPath affects the movement?</p>\n\
<p>Can you read the value at any given time? How?</p>\n\
<p>If I’m traversing a DAG tree, how can I tell an object’s position?</p>\n\
<p>A:</p>\n\
<p>Keyframes are provided by anim curve dependency nodes, and similarly, motion paths are implemented as dependency nodes. These nodes function because they are connected to the transformation attributes of the parent transform in the DAG. When the transform needs a value, it gets it from the anim curve or motion path node.</p>\n\
<p>So, when you connect the motion path node, the anim curve node gets disconnected, and so no longer affects the transform. You can only have one of these positional nodes connected to a transform at a time, and the last one connected wins.</p>\n\
<p>Regardless of whether or not the transform is connect to an anim curve or motion path node, you can always ask the transform node for its transformation information and get the right values.</p>\n\
<p>Q:</p>\n\
<p>I haven&#39;t been able to find any documentation or sample code describing the interpolation system used by Maya for the quaternion curves. Could you tell me where I can find the details on it?</p>\n\
<p>A:</p>\n\
<p>For the spline interpolation, we use squad which is described in the first two references below.</p>\n\
<ul>\n\
<li>Shoemake, K. &quot;Animating Rotation with Quaternion Curves.&quot; SIGGRAPH 85 Proceedings, pp 245-254, 1985.</li>\n\
<li>Shoemake, K. &quot;Quaternion Calculus for Animation.&quot; SIGGRAPH 91 course notes for &quot;Math for SIGGRAPH&quot;.</li>\n\
<li>Eberly, David. &quot;Quaternion Algebra and Calculus.&quot; (This paper contains a derivation for squad.)</li>\n\
<li>Ramamoorthi, Ravi. &quot;Fast Construction of Accurate Quaternion Splines.&quot; SIGGRAPH 97 Proceedings, 1997. (This paper discusses an alternate interpolation method).</li>\n\
</ul>\n\
<div class=\'section\'><a id=\"windows-questions\"></a><h2 id=\"windows-questions\">Windows Questions</h2></div>\n\
<p>Q:</p>\n\
<p>How do I add Windows-specific code to my plug-in?</p>\n\
<p>A:</p>\n\
<p>Use <span class=\'code\'>#ifdef _WIN32</span> around the Windows-specific code.</p>\n\
<p>Q:</p>\n\
<p>How do I debug my plug-in?</p>\n\
<p>A:</p>\n\
<p>Select Project &gt; Settings, then select the Debug tab. In the Executable for debug session field, type the full pathname to the Maya executable, for example:</p>\n\
<p>C:\\Program Files\\Autodesk\\Maya2016\\bin\\Maya.exe</p>\n\
<p>Use the F9 function key to toggle breakpoints in your plug-in source code. When you are ready to begin debugging, select Build &gt; Start Debug &gt; Go.</p>\n\
<p>Q:</p>\n\
<p>How do I get the handle to the application instance (the HINSTANCE) for my plug-in?</p>\n\
<p>A:</p>\n\
<p>We have saved the HINSTANCE for the plug-in in a global variable, MhInstPlugin, which should be available if you have included the standard set of plug-in include files. Specifically, the variable is defined in the MfnPlugin.h include file.</p>\n\
<p>Q:</p>\n\
<p>What do I do if I get the following warning?</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\">warning C4190: ’initializePlugin’ has C-linkage specified, but returns UDT ’<a href=\"javascript:void(0)\" data-symbol=\"MStatus\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]\">MStatus</a>’ which is incompatible with C\n\
\n\
</pre></div><p>A:</p>\n\
<p>Nothing. The compiler will complain about this, but it will do the right thing. The warning is harmless.</p>\n\
<p>Q:</p>\n\
<p>Why do I get compiler errors when I use the variables &quot;near&quot; and &quot;far&quot;?</p>\n\
<p>A:</p>\n\
<p>These are reserved keywords in the Microsoft compiler. You will need to change the variable names to, for example, nearClip and farClip.</p>\n\
<p>Q:</p>\n\
<p>What do I do if I get the following error?</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\">error C2065: ’uint’ : undeclared identifier\n\
\n\
</pre></div><p>A:</p>\n\
<p>The Windows equivalent for this is UINT. We have added a define to MTypes.h to solve this problem.</p>\n\
<p>Q:</p>\n\
<p>What do I do if I get the following error?</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\">error C2065: ’alloca’ : undeclared identifier\n\
\n\
</pre></div><p>A:</p>\n\
<p>Add the following to your source code.</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\">#ifdef _WIN32\n\
#include &quot;malloc.h&quot;\n\
#endif\n\
</pre></div>      <div class=\"footer-block\"><a href=\"../html/ac.cmtdialog.htm\" class=\"comments-anchor\" target=\"_blank\"><span class=\"comments-link\">Please send us your comment about this page</span></a></div></div>\n\
   </div></body>\n\
</html>\n\
";