<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
      <title>C++ API Reference: gpuCache/CacheReaderAlembic.cpp</title>
      
	  
      
      
      
      
      
      
      
    

</head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2_cache_reader_alembic_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
      <div>
         <div class="head">
            <h1>C++ API Reference: gpuCache/CacheReaderAlembic.cpp</h1>
         </div>

<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->

  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="cpp_ref/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="cpp_ref/search/close.png" alt=""></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<!-- window showing the filter options -->


<!-- iframe showing the search results (closed by default) -->


<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/CacheReaderAlembic.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;CacheReaderAlembic.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;CacheAlembicUtil.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheUtil.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheStrings.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcCoreFactory/IFactory.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcGeom/Visibility.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcGeom/ArchiveBounds.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MStringArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAnimControl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MString.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNurbsCurve.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNurbsCurveData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MTrimBoundaryArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatVector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPointArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatPointArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatVectorArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MUintArray.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> std::pair&lt; int, int &gt; TEdge;</div>
<div class="line"><span class="keyword">namespace </span>std</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>hash&lt;TEdge&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">size_t</span> operator()(TEdge <span class="keyword">const</span>&amp; v)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            std::size_t h = std::hash&lt;int&gt;()(v.first);</div>
<div class="line">            GPUCache::hash_combine&lt;int&gt;(h, v.second);</div>
<div class="line">            <span class="keywordflow">return</span> h;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>CacheAlembicUtil;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"><span class="keyword">namespace </span>CacheReaderAlembicPrivate {</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicArray</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayProperty&gt;</div>
<div class="line"><span class="keyword">struct </span>AlembicArray&lt;ArrayProperty&gt;::MakeSharedEnabler: <span class="keyword">public</span> AlembicArray&lt;ArrayProperty&gt; {</div>
<div class="line">    MakeSharedEnabler(<span class="keyword">const</span> ArraySamplePtr&amp; arraySamplePtr, <span class="keyword">const</span> Digest&amp; digest)</div>
<div class="line">            : AlembicArray&lt;ArrayProperty&gt;(arraySamplePtr,digest){}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayProperty&gt;</div>
<div class="line">std::shared_ptr&lt;ReadableArray&lt;typename AlembicArray&lt;ArrayProperty&gt;::T&gt; &gt;</div>
<div class="line">AlembicArray&lt;ArrayProperty&gt;::create(</div>
<div class="line">    <span class="keyword">const</span> ArraySamplePtr&amp; arraySamplePtr, <span class="keyword">const</span> Digest&amp; digest ) </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = (arraySamplePtr-&gt;size() *</div>
<div class="line">                         ArrayProperty::traits_type::dataType().getExtent());</div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">    <span class="comment">// Compute the Murmur3 cryptographic hash-key and make sure</span></div>
<div class="line">    <span class="comment">// that the digest found in the Alembic file is correct.</span></div>
<div class="line">    Digest checkDigest;</div>
<div class="line">    Alembic::Util::MurmurHash3_x64_128(</div>
<div class="line">        arraySamplePtr-&gt;get(), size * <span class="keyword">sizeof</span>(T), <span class="keyword">sizeof</span>(T), checkDigest.words);</div>
<div class="line">    assert(digest == checkDigest);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        </div>
<div class="line">    <span class="comment">// We first look if a similar array already exists in the</span></div>
<div class="line">    <span class="comment">// cache. If so, we return the cached array to promote sharing as</span></div>
<div class="line">    <span class="comment">// much as possible.</span></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; ret;</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(ArrayRegistry&lt;T&gt;::mutex());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Only accept arrays which contain data we own.  This array may happen on a</span></div>
<div class="line">        <span class="comment">// worker thread, so non-readable arrays can&#39;t be converted to readable.</span></div>
<div class="line">        ret = ArrayRegistry&lt;T&gt;::lookupReadable(digest, size);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (!ret) {</div>
<div class="line">            ret = std::make_shared&lt;MakeSharedEnabler&gt;(</div>
<div class="line">                arraySamplePtr, digest);</div>
<div class="line">            ArrayRegistry&lt;T&gt;::insert(ret);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayProperty&gt;</div>
<div class="line">AlembicArray&lt;ArrayProperty&gt;::~AlembicArray() {}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayProperty&gt;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> AlembicArray&lt;ArrayProperty&gt;::T*</div>
<div class="line">AlembicArray&lt;ArrayProperty&gt;::get()<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>T*<span class="keyword">&gt;</span>(fArraySamplePtr-&gt;get());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ArrayPropertyCacheWithConverter</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PROPERTY&gt;</div>
<div class="line"><span class="keyword">typename</span> ArrayPropertyCacheWithConverter&lt;PROPERTY&gt;::ConvertionMap</div>
<div class="line">ArrayPropertyCacheWithConverter&lt;PROPERTY&gt;::fsConvertionMap;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ArrayPropertyCacheWithConverter&lt;</div>
<div class="line">    Alembic::Abc::IInt32ArrayProperty&gt;;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ScopedUnlockAlembic</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>ScopedUnlockAlembic</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ScopedUnlockAlembic()</div>
<div class="line">    {</div>
<div class="line">        gsAlembicMutex.unlock();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~ScopedUnlockAlembic()</div>
<div class="line">    {</div>
<div class="line">        gsAlembicMutex.lock();</div>
<div class="line">    }</div>
<div class="line">    ScopedUnlockAlembic(<span class="keyword">const</span> ScopedUnlockAlembic&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    ScopedUnlockAlembic&amp; operator=(<span class="keyword">const</span> ScopedUnlockAlembic&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// This function is the checkpoint of the worker thread&#39;s interrupt and pause state.</span></div>
<div class="line"><span class="keywordtype">void</span> CheckInterruptAndPause(<span class="keyword">const</span> <span class="keywordtype">char</span>* state)</div>
<div class="line">{</div>
<div class="line">    GlobalReaderCache&amp; readerCache = GlobalReaderCache::theCache();</div>
<div class="line">    <span class="keywordflow">if</span> (readerCache.isInterrupted()) {</div>
<div class="line">        <span class="comment">// Interrupted. Throw an exception to terminate this reader.</span></div>
<div class="line">        <span class="keywordflow">throw</span> CacheReaderInterruptException(state);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (readerCache.isPaused()) {</div>
<div class="line">        <span class="comment">// Paused. Unlock the Alembic lock and return the control.</span></div>
<div class="line">        ScopedUnlockAlembic unlock;</div>
<div class="line">        readerCache.pauseUntilNotified();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS DataProvider</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> INFO&gt;</div>
<div class="line">DataProvider::DataProvider(</div>
<div class="line">        Alembic::AbcGeom::IGeomBaseSchema&lt;INFO&gt;&amp; abcGeom,</div>
<div class="line">        Alembic::Abc::TimeSamplingPtr            timeSampling,</div>
<div class="line">        <span class="keywordtype">size_t</span> numSamples,</div>
<div class="line">        <span class="keywordtype">bool</span>   needUVs)</div>
<div class="line">    : fAnimTimeRange(TimeInterval::kInvalid),</div>
<div class="line">      fBBoxAndVisValidityInterval(TimeInterval::kInvalid),</div>
<div class="line">      fValidityInterval(TimeInterval::kInvalid),</div>
<div class="line">      fNeedUVs(needUVs)</div>
<div class="line">{</div>
<div class="line">    Alembic::Abc::IObject shapeObject = abcGeom.getObject();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// shape visibility</span></div>
<div class="line">    Alembic::AbcGeom::IVisibilityProperty visibility = </div>
<div class="line">                    Alembic::AbcGeom::GetVisibilityProperty(shapeObject);</div>
<div class="line">    <span class="keywordflow">if</span> (visibility) {</div>
<div class="line">        fVisibilityCache.init(visibility);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// bounding box</span></div>
<div class="line">    fBoundingBoxCache.init(abcGeom.getSelfBoundsProperty());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find parent IObjects</span></div>
<div class="line">    std::vector&lt;Alembic::Abc::IObject&gt; parents;</div>
<div class="line">    Alembic::Abc::IObject current = shapeObject.getParent();</div>
<div class="line">    <span class="keywordflow">while</span> (current.valid()) {</div>
<div class="line">        parents.push_back(current);</div>
<div class="line">        current = current.getParent();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// parent visibility</span></div>
<div class="line">    fParentVisibilityCache.resize(parents.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; fParentVisibilityCache.size(); i++) {</div>
<div class="line">        Alembic::AbcGeom::IVisibilityProperty visibilityProp = </div>
<div class="line">            Alembic::AbcGeom::GetVisibilityProperty(parents[i]);</div>
<div class="line">        <span class="keywordflow">if</span> (visibilityProp) {</div>
<div class="line">            fParentVisibilityCache[i].init(visibilityProp);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// exact animation time range</span></div>
<div class="line">    fAnimTimeRange = TimeInterval(</div>
<div class="line">        timeSampling-&gt;getSampleTime(0),</div>
<div class="line">        timeSampling-&gt;getSampleTime(numSamples &gt; 0 ? numSamples-1 : 0)</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">DataProvider::~DataProvider()</div>
<div class="line">{</div>
<div class="line">    fValidityInterval = TimeInterval::kInvalid;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// free the property readers</span></div>
<div class="line">    fVisibilityCache.reset();</div>
<div class="line">    fBoundingBoxCache.reset();</div>
<div class="line">    fParentVisibilityCache.clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> DataProvider::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fBoundingBoxCache.valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;const ShapeSample&gt; </div>
<div class="line">DataProvider::getBBoxPlaceHolderSample(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;ShapeSample&gt; sample = </div>
<div class="line">        ShapeSample::createBoundingBoxPlaceHolderSample(</div>
<div class="line">            seconds,</div>
<div class="line">            getBoundingBox(),</div>
<div class="line">            isVisible()</div>
<div class="line">        );</div>
<div class="line">    <span class="keywordflow">return</span> sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> DataProvider::fillBBoxAndVisSample(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    fBBoxAndVisValidityInterval = updateBBoxAndVisCache(time);</div>
<div class="line">    assert(fBBoxAndVisValidityInterval.valid());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> DataProvider::fillTopoAndAttrSample(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    fValidityInterval = updateCache(time);</div>
<div class="line">    assert(fValidityInterval.valid());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval DataProvider::updateBBoxAndVisCache(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Notes:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// When possible, we try to reuse the samples from the previously</span></div>
<div class="line">    <span class="comment">// read sample.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// update caches</span></div>
<div class="line">    <span class="keywordflow">if</span> (fVisibilityCache.valid()) {</div>
<div class="line">        fVisibilityCache.setTime(time);</div>
<div class="line">    }</div>
<div class="line">    fBoundingBoxCache.setTime(time);</div>
<div class="line">    <span class="keywordflow">for</span>(ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt;&amp; </div>
<div class="line">            parentVisPropCache : fParentVisibilityCache) {</div>
<div class="line">        <span class="keywordflow">if</span> (parentVisPropCache.valid()) { </div>
<div class="line">            parentVisPropCache.setTime(time);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// return the new cache valid interval</span></div>
<div class="line">    TimeInterval validityInterval(TimeInterval::kInfinite);</div>
<div class="line">    <span class="keywordflow">if</span> (fVisibilityCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fVisibilityCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line">    validityInterval &amp;= fBoundingBoxCache.getValidityInterval();</div>
<div class="line">    <span class="keywordflow">for</span>(ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt;&amp; </div>
<div class="line">            parentVisPropCache : fParentVisibilityCache) {</div>
<div class="line">        <span class="keywordflow">if</span> (parentVisPropCache.valid()) { </div>
<div class="line">            validityInterval &amp;= parentVisPropCache.getValidityInterval();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval DataProvider::updateCache(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> updateBBoxAndVisCache(time);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> DataProvider::isVisible()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// shape invisible</span></div>
<div class="line">    <span class="keywordflow">if</span> (fVisibilityCache.valid() &amp;&amp; </div>
<div class="line">            fVisibilityCache.getValue() == char(Alembic::AbcGeom::kVisibilityHidden)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// parent invisible</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt;&amp; </div>
<div class="line">            parentVisPropCache : fParentVisibilityCache) {</div>
<div class="line">        <span class="keywordflow">if</span> (parentVisPropCache.valid() &amp;&amp; </div>
<div class="line">                parentVisPropCache.getValue() == char(Alembic::AbcGeom::kVisibilityHidden)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// visible</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS PolyDataProvider</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> SCHEMA&gt;</div>
<div class="line">PolyDataProvider::PolyDataProvider(</div>
<div class="line">    SCHEMA&amp;                         abcMesh,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>                      needUVs)</div>
<div class="line">  : DataProvider(abcMesh, abcMesh.getTimeSampling(), </div>
<div class="line">                 abcMesh.getNumSamples(), needUVs)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// polygon counts</span></div>
<div class="line">    fFaceCountsCache.init(abcMesh.getFaceCountsProperty());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// positions</span></div>
<div class="line">    fPositionsCache.init(abcMesh.getPositionsProperty());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">PolyDataProvider::~PolyDataProvider()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// free the property readers</span></div>
<div class="line">    fFaceCountsCache.reset();</div>
<div class="line">    fPositionsCache.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PolyDataProvider::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> DataProvider::valid() &amp;&amp;</div>
<div class="line">            fFaceCountsCache.valid() &amp;&amp;</div>
<div class="line">            fPositionsCache.valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval</div>
<div class="line">PolyDataProvider::updateCache(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    TimeInterval validityInterval(DataProvider::updateCache(time));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update caches</span></div>
<div class="line">    fFaceCountsCache.setTime(time);</div>
<div class="line">    fPositionsCache.setTime(time);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// return the new cache valid interval</span></div>
<div class="line">    validityInterval &amp;= fFaceCountsCache.getValidityInterval();</div>
<div class="line">    validityInterval &amp;= fPositionsCache.getValidityInterval();</div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS RawDataProvider</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">RawDataProvider::RawDataProvider(</div>
<div class="line">    Alembic::AbcGeom::IPolyMeshSchema&amp; abcMesh,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">    : PolyDataProvider(abcMesh, needUVs),</div>
<div class="line">      fFaceIndicesCache(correctPolygonWinding)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// triangle indices</span></div>
<div class="line">    fFaceIndicesCache.init(abcMesh.getFaceIndicesProperty());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// custom reader for wireframe indices</span></div>
<div class="line">    <span class="keywordflow">if</span> (abcMesh.getPropertyHeader(kCustomPropertyWireIndices) != NULL) {</div>
<div class="line">        fWireIndicesCache.init(</div>
<div class="line">            Alembic::Abc::IInt32ArrayProperty(abcMesh.getPtr(), kCustomPropertyWireIndices));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abcMesh.getPropertyHeader(kCustomPropertyWireIndicesOld) != NULL) {</div>
<div class="line">        fWireIndicesCache.init(</div>
<div class="line">            Alembic::Abc::IInt32ArrayProperty(abcMesh.getPtr(), kCustomPropertyWireIndicesOld));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// custom reader for group info</span></div>
<div class="line">    <span class="keywordflow">if</span> (abcMesh.getPropertyHeader(kCustomPropertyShadingGroupSizes) != NULL) {</div>
<div class="line">        fGroupSizesCache.init(</div>
<div class="line">            Alembic::Abc::IInt32ArrayProperty(abcMesh.getPtr(), kCustomPropertyShadingGroupSizes));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// custom reader for diffuse color</span></div>
<div class="line">    <span class="keywordflow">if</span> (abcMesh.getPropertyHeader(kCustomPropertyDiffuseColor) != NULL) {</div>
<div class="line">        fDiffuseColorCache.init(</div>
<div class="line">            Alembic::Abc::IC4fProperty(abcMesh.getPtr(), kCustomPropertyDiffuseColor));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// normals, we do not support indexed/facevarying normals</span></div>
<div class="line">    Alembic::AbcGeom::IN3fGeomParam normals = abcMesh.getNormalsParam();</div>
<div class="line">    <span class="keywordflow">if</span> (normals.valid()) {</div>
<div class="line">        assert(!normals.isIndexed());</div>
<div class="line">        assert(normals.getScope() == Alembic::AbcGeom::kVertexScope);</div>
<div class="line">        fNormalsCache.init(normals.getValueProperty());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fNeedUVs) {</div>
<div class="line">        <span class="comment">// UVs, we do not support indexed/facevarying UVs</span></div>
<div class="line">        Alembic::AbcGeom::IV2fGeomParam UVs = abcMesh.getUVsParam();</div>
<div class="line">        <span class="keywordflow">if</span> (UVs.valid()) {</div>
<div class="line">            assert(!UVs.isIndexed());</div>
<div class="line">            assert(UVs.getScope() == Alembic::AbcGeom::kVertexScope);</div>
<div class="line">            fUVsCache.init(UVs.getValueProperty());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">RawDataProvider::~RawDataProvider()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// free the property readers</span></div>
<div class="line">    fFaceIndicesCache.reset();</div>
<div class="line">    fWireIndicesCache.reset();</div>
<div class="line">    fGroupSizesCache.reset();</div>
<div class="line">    fDiffuseColorCache.reset();</div>
<div class="line">    fNormalsCache.reset();</div>
<div class="line">    fUVsCache.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> RawDataProvider::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> PolyDataProvider::valid() &amp;&amp;</div>
<div class="line">            fFaceIndicesCache.valid() &amp;&amp;</div>
<div class="line">            fWireIndicesCache.valid() &amp;&amp;</div>
<div class="line">            fDiffuseColorCache.valid() &amp;&amp;</div>
<div class="line">            fNormalsCache.valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;const ShapeSample&gt; </div>
<div class="line">RawDataProvider::getSample(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;IndexBuffer&gt; &gt; triangleVertIndices;</div>
<div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; indexBuffer =</div>
<div class="line">        fFaceIndicesCache.getValue();</div>
<div class="line">    <span class="keywordflow">if</span> (fGroupSizesCache.valid()) {</div>
<div class="line">        <span class="keyword">const</span> std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; groupSizes =</div>
<div class="line">            fGroupSizesCache.getValue();</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> IndexBuffer::index_t* groupSizesPtr = groupSizes-&gt;get();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0, offset=0; i&lt;groupSizes-&gt;size(); offset+=3*groupSizesPtr[i], ++i) {</div>
<div class="line">            triangleVertIndices.push_back(</div>
<div class="line">                IndexBuffer::create(</div>
<div class="line">                    indexBuffer, offset, offset+3*groupSizesPtr[i]));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        triangleVertIndices.push_back(IndexBuffer::create(indexBuffer));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Alembic::Abc::C4f diffuseColor = fDiffuseColorCache.getValue();</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ShapeSample&gt; sample = ShapeSample::create(</div>
<div class="line">        seconds,                                                   <span class="comment">// time (in seconds)</span></div>
<div class="line">        fWireIndicesCache.getValue()-&gt;size() / 2,                  <span class="comment">// number of wireframes</span></div>
<div class="line">        fPositionsCache.getValue()-&gt;size() / 3,                    <span class="comment">// number of vertices</span></div>
<div class="line">        IndexBuffer::create(fWireIndicesCache.getValue()),         <span class="comment">// wireframe indices</span></div>
<div class="line">        triangleVertIndices,                                       <span class="comment">// triangle indices</span></div>
<div class="line">        VertexBuffer::createPositions(fPositionsCache.getValue()), <span class="comment">// position</span></div>
<div class="line">        getBoundingBox(),                                          <span class="comment">// bounding box</span></div>
<div class="line">        <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>(diffuseColor.r, diffuseColor.g, diffuseColor.b, diffuseColor.a),</div>
<div class="line">        isVisible()</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fNormalsCache.valid()) {</div>
<div class="line">        sample-&gt;setNormals(</div>
<div class="line">            VertexBuffer::createNormals(fNormalsCache.getValue()));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        sample-&gt;setUVs(</div>
<div class="line">            VertexBuffer::createUVs(fUVsCache.getValue()));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt;</div>
<div class="line">    RawDataProvider::correctPolygonWinding(<span class="keyword">const</span> Alembic::Abc::Int32ArraySamplePtr&amp; indices)</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> count = (*indices).size();</div>
<div class="line">    GPUCache::shared_array&lt;IndexBuffer::index_t&gt; faceIndicesCCW(</div>
<div class="line">        <span class="keyword">new</span> IndexBuffer::index_t[count]);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; i += 3) {</div>
<div class="line">        faceIndicesCCW[i + 2] = (*indices)[i + 0];</div>
<div class="line">        faceIndicesCCW[i + 1] = (*indices)[i + 1];</div>
<div class="line">        faceIndicesCCW[i + 0] = (*indices)[i + 2];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> SharedArray&lt;IndexBuffer::index_t&gt;::create(</div>
<div class="line">        faceIndicesCCW, count);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval RawDataProvider::updateCache(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    TimeInterval validityInterval(PolyDataProvider::updateCache(time));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update caches</span></div>
<div class="line">    fFaceIndicesCache.setTime(time);</div>
<div class="line">    fWireIndicesCache.setTime(time);</div>
<div class="line">    <span class="keywordflow">if</span> (fGroupSizesCache.valid()) {</div>
<div class="line">        fGroupSizesCache.setTime(time);</div>
<div class="line">    }</div>
<div class="line">    fNormalsCache.setTime(time);</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        fUVsCache.setTime(time);</div>
<div class="line">    }</div>
<div class="line">    fDiffuseColorCache.setTime(time);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// return the new cache valid interval</span></div>
<div class="line">    validityInterval &amp;= fFaceIndicesCache.getValidityInterval();</div>
<div class="line">    validityInterval &amp;= fWireIndicesCache.getValidityInterval();</div>
<div class="line">    <span class="keywordflow">if</span> (fGroupSizesCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fGroupSizesCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line">    validityInterval &amp;= fNormalsCache.getValidityInterval();</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fUVsCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line">    validityInterval &amp;= fDiffuseColorCache.getValidityInterval();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check sample consistency</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numVerts     = fPositionsCache.getValue()-&gt;size() / 3;</div>
<div class="line">    <span class="keywordtype">size_t</span> numTriangles = fFaceIndicesCache.getValue()-&gt;size() / 3;</div>
<div class="line">    <span class="keywordflow">if</span> (fFaceCountsCache.getValue()-&gt;size() != numTriangles) {</div>
<div class="line">        assert(fFaceCountsCache.getValue()-&gt;size() == numTriangles);</div>
<div class="line">        <span class="keywordflow">return</span> TimeInterval::kInvalid;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (fNormalsCache.getValue()-&gt;size() / 3 != numVerts) {</div>
<div class="line">        assert(fNormalsCache.getValue()-&gt;size() / 3 == numVerts);</div>
<div class="line">        <span class="keywordflow">return</span> TimeInterval::kInvalid;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        <span class="keywordflow">if</span> (fUVsCache.getValue()-&gt;size() / 2 != numVerts) {</div>
<div class="line">            assert(fUVsCache.getValue()-&gt;size() / 2 == numVerts);</div>
<div class="line">            <span class="keywordflow">return</span> TimeInterval::kInvalid;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS Triangulator</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">Triangulator::Triangulator(</div>
<div class="line">    Alembic::AbcGeom::IPolyMeshSchema&amp; abcMesh,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">    : PolyDataProvider(abcMesh, needUVs),</div>
<div class="line">    fNormalsScope(Alembic::AbcGeom::kUnknownScope), fUVsScope(Alembic::AbcGeom::kUnknownScope)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// polygon indices</span></div>
<div class="line">    fFaceIndicesCache.init(abcMesh.getFaceIndicesProperty());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// optional normals</span></div>
<div class="line">    Alembic::AbcGeom::IN3fGeomParam normals = abcMesh.getNormalsParam();</div>
<div class="line">    <span class="keywordflow">if</span> (normals.valid()) {</div>
<div class="line">        fNormalsScope = normals.getScope();</div>
<div class="line">        <span class="keywordflow">if</span> (fNormalsScope == Alembic::AbcGeom::kVaryingScope ||</div>
<div class="line">                fNormalsScope == Alembic::AbcGeom::kVertexScope ||</div>
<div class="line">                fNormalsScope == Alembic::AbcGeom::kFacevaryingScope) {</div>
<div class="line">            fNormalsCache.init(normals.getValueProperty());</div>
<div class="line">            <span class="keywordflow">if</span> (normals.isIndexed()) {</div>
<div class="line">                fNormalIndicesCache.init(normals.getIndexProperty());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// optional UVs</span></div>
<div class="line">    <span class="keywordflow">if</span> (fNeedUVs) {</div>
<div class="line">        Alembic::AbcGeom::IV2fGeomParam UVs = abcMesh.getUVsParam();</div>
<div class="line">        <span class="keywordflow">if</span> (UVs.valid()) {</div>
<div class="line">            fUVsScope = UVs.getScope();</div>
<div class="line">            <span class="keywordflow">if</span> (fUVsScope == Alembic::AbcGeom::kVaryingScope ||</div>
<div class="line">                fUVsScope == Alembic::AbcGeom::kVertexScope ||</div>
<div class="line">                fUVsScope == Alembic::AbcGeom::kFacevaryingScope) {</div>
<div class="line">                fUVsCache.init(UVs.getValueProperty());</div>
<div class="line">                <span class="keywordflow">if</span> (UVs.isIndexed()) {</div>
<div class="line">                    fUVIndicesCache.init(UVs.getIndexProperty());</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">Triangulator::~Triangulator()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// free the property readers</span></div>
<div class="line">    fFaceIndicesCache.reset();</div>
<div class="line"></div>
<div class="line">    fNormalsScope = Alembic::AbcGeom::kUnknownScope;</div>
<div class="line">    fNormalsCache.reset();</div>
<div class="line">    fNormalIndicesCache.reset();</div>
<div class="line"></div>
<div class="line">    fUVsScope = Alembic::AbcGeom::kUnknownScope;</div>
<div class="line">    fUVsCache.reset();</div>
<div class="line">    fUVIndicesCache.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> Triangulator::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> PolyDataProvider::valid() &amp;&amp;</div>
<div class="line">            fFaceIndicesCache.valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;const ShapeSample&gt; </div>
<div class="line">Triangulator::getSample(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// empty mesh</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fWireIndices || !fTriangleIndices) {</div>
<div class="line">        std::shared_ptr&lt;ShapeSample&gt; sample =</div>
<div class="line">            ShapeSample::createEmptySample(seconds);</div>
<div class="line">        <span class="keywordflow">return</span> sample;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// triangle indices</span></div>
<div class="line">    <span class="comment">// Currently, we only have 1 group</span></div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;IndexBuffer&gt; &gt; triangleVertIndices;</div>
<div class="line">    triangleVertIndices.push_back(IndexBuffer::create(fTriangleIndices));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ShapeSample&gt; sample = ShapeSample::create(</div>
<div class="line">        seconds,                                           <span class="comment">// time (in seconds)</span></div>
<div class="line">        fWireIndices-&gt;size() / 2,                          <span class="comment">// number of wireframes</span></div>
<div class="line">        fMappedPositions-&gt;size() / 3,                      <span class="comment">// number of vertices</span></div>
<div class="line">        IndexBuffer::create(fWireIndices),                 <span class="comment">// wireframe indices</span></div>
<div class="line">        triangleVertIndices,                               <span class="comment">// triangle indices (1 group)</span></div>
<div class="line">        VertexBuffer::createPositions(fMappedPositions),   <span class="comment">// position</span></div>
<div class="line">        getBoundingBox(),                                  <span class="comment">// bounding box</span></div>
<div class="line">        Config::kDefaultGrayColor,                         <span class="comment">// diffuse color</span></div>
<div class="line">        isVisible()</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fMappedNormals) {</div>
<div class="line">        sample-&gt;setNormals(</div>
<div class="line">            VertexBuffer::createNormals(fMappedNormals));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fMappedUVs) {</div>
<div class="line">        sample-&gt;setUVs(</div>
<div class="line">            VertexBuffer::createUVs(fMappedUVs));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval Triangulator::updateCache(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// update faceCounts/position cache here so that we can detect topology/position change.</span></div>
<div class="line">    <span class="comment">// next setTime() in DataProvider::updateCache() simply returns early</span></div>
<div class="line">    <span class="keywordtype">bool</span> topologyChanged = fFaceCountsCache.setTime(time);</div>
<div class="line">    <span class="keywordtype">bool</span> positionChanged = fPositionsCache.setTime(time);</div>
<div class="line"></div>
<div class="line">    TimeInterval validityInterval(PolyDataProvider::updateCache(time));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update caches</span></div>
<div class="line">    topologyChanged = fFaceIndicesCache.setTime(time) || topologyChanged;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fNormalsCache.valid()) {</div>
<div class="line">        fNormalsCache.setTime(time);</div>
<div class="line">        <span class="keywordflow">if</span> (fNormalIndicesCache.valid()) {</div>
<div class="line">            fNormalIndicesCache.setTime(time);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        fUVsCache.setTime(time);</div>
<div class="line">        <span class="keywordflow">if</span> (fUVIndicesCache.valid()) {</div>
<div class="line">            fUVIndicesCache.setTime(time);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// return the new cache valid interval</span></div>
<div class="line">    validityInterval &amp;= fFaceIndicesCache.getValidityInterval();</div>
<div class="line">    <span class="keywordflow">if</span> (fNormalsCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fNormalsCache.getValidityInterval();</div>
<div class="line">        <span class="keywordflow">if</span> (fNormalIndicesCache.valid()) {</div>
<div class="line">            validityInterval &amp;= fNormalIndicesCache.getValidityInterval();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fUVsCache.getValidityInterval();</div>
<div class="line">        <span class="keywordflow">if</span> (fUVIndicesCache.valid()) {</div>
<div class="line">            validityInterval &amp;= fUVIndicesCache.getValidityInterval();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// do a minimal check for the consistency</span></div>
<div class="line">    check();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// convert the mesh to display-friend format</span></div>
<div class="line">    <span class="keywordflow">if</span> (positionChanged || topologyChanged || !fComputedNormals) {</div>
<div class="line">        <span class="comment">// recompute normals on position/topology change</span></div>
<div class="line">        computeNormals();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (topologyChanged || !fVertAttribsIndices) {</div>
<div class="line">        <span class="comment">// convert multi-indexed streams on topology change</span></div>
<div class="line">        convertMultiIndexedStreams();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    remapVertAttribs();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (topologyChanged || !fWireIndices) {</div>
<div class="line">        <span class="comment">// recompute wireframe indices on topology change</span></div>
<div class="line">        computeWireIndices();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (topologyChanged || !fTriangleIndices) {</div>
<div class="line">        <span class="comment">// recompute triangulation on topology change</span></div>
<div class="line">        triangulate();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> SIZE&gt;</div>
<div class="line">std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt; Triangulator::convertMultiIndexedStream(</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt; attribArray,</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; indexArray)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// map the indexed array to direct array</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numVerts                                 = indexArray-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* srcAttribs                         = attribArray-&gt;get();</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* srcIndices          = indexArray-&gt;get();</div>
<div class="line"></div>
<div class="line">    GPUCache::shared_array&lt;float&gt; mappedAttribs(<span class="keyword">new</span> <span class="keywordtype">float</span>[numVerts * SIZE]);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numVerts; i++) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; SIZE; j++) {</div>
<div class="line">            mappedAttribs[i * SIZE + j] = srcAttribs[srcIndices[i] * SIZE + j];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> SharedArray&lt;float&gt;::create(mappedAttribs, numVerts * SIZE);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Triangulator::check()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keywordtype">size_t</span> numVerts       = fPositionsCache.getValue()-&gt;size() / 3;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Normals</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numExpectedNormals = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (fNormalsScope == Alembic::AbcGeom::kVaryingScope ||</div>
<div class="line">            fNormalsScope == Alembic::AbcGeom::kVertexScope) {</div>
<div class="line">        numExpectedNormals = numVerts;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fNormalsScope == Alembic::AbcGeom::kFacevaryingScope) {</div>
<div class="line">        numExpectedNormals = numFaceIndices;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numActualNormals = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (fNormalsCache.valid()) {</div>
<div class="line">        <span class="keywordflow">if</span> (fNormalIndicesCache.valid()) {</div>
<div class="line">            numActualNormals = fNormalIndicesCache.getValue()-&gt;size();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            numActualNormals = fNormalsCache.getValue()-&gt;size() / 3;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// clear previous result</span></div>
<div class="line">    fCheckedNormalsScope = Alembic::AbcGeom::kUnknownScope;</div>
<div class="line">    fCheckedNormals.reset();</div>
<div class="line">    fCheckedNormalIndices.reset();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward </span></div>
<div class="line">    <span class="keywordflow">if</span> (numExpectedNormals == numActualNormals) {</div>
<div class="line">        <span class="keywordflow">if</span> (fNormalsCache.valid()) {</div>
<div class="line">            fCheckedNormalsScope = fNormalsScope;</div>
<div class="line">            fCheckedNormals      = fNormalsCache.getValue();</div>
<div class="line">            <span class="keywordflow">if</span> (fNormalIndicesCache.valid()) {</div>
<div class="line">                fCheckedNormalIndices = fNormalIndicesCache.getValue();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        DisplayWarning(kBadNormalsMsg);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// UVs</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numExpectedUVs = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsScope == Alembic::AbcGeom::kVaryingScope ||</div>
<div class="line">        fUVsScope == Alembic::AbcGeom::kVertexScope) {</div>
<div class="line">            numExpectedUVs = numVerts;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fUVsScope == Alembic::AbcGeom::kFacevaryingScope) {</div>
<div class="line">        numExpectedUVs = numFaceIndices;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numActualUVs = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        <span class="keywordflow">if</span> (fUVIndicesCache.valid()) {</div>
<div class="line">            numActualUVs = fUVIndicesCache.getValue()-&gt;size();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            numActualUVs = fUVsCache.getValue()-&gt;size() / 2;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// clear previous result</span></div>
<div class="line">    fCheckedUVsScope = Alembic::AbcGeom::kUnknownScope;</div>
<div class="line">    fCheckedUVs.reset();</div>
<div class="line">    fCheckedUVIndices.reset();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward </span></div>
<div class="line">    <span class="keywordflow">if</span> (numExpectedUVs == numActualUVs) {</div>
<div class="line">        <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">            fCheckedUVsScope = fUVsScope;</div>
<div class="line">            fCheckedUVs      = fUVsCache.getValue();</div>
<div class="line">            <span class="keywordflow">if</span> (fUVIndicesCache.valid()) {</div>
<div class="line">                fCheckedUVIndices = fUVIndicesCache.getValue();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        DisplayWarning(kBadUVsMsg);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Triangulator::computeNormals()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// compute normals if the normals are missing</span></div>
<div class="line">    <span class="comment">// later on, we can safely assume that the normals always exist</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (fCheckedNormals &amp;&amp; (fCheckedNormalsScope == Alembic::AbcGeom::kVaryingScope</div>
<div class="line">            || fCheckedNormalsScope == Alembic::AbcGeom::kVertexScope</div>
<div class="line">            || fCheckedNormalsScope == Alembic::AbcGeom::kFacevaryingScope)) {</div>
<div class="line">        <span class="comment">// the normals exist and we recognize these normals</span></div>
<div class="line">        fComputedNormals      = fCheckedNormals;</div>
<div class="line">        fComputedNormalsScope = fCheckedNormalsScope;</div>
<div class="line">        fComputedNormalIndices.reset();</div>
<div class="line">        <span class="keywordflow">if</span> (fCheckedNormalIndices) {</div>
<div class="line">            fComputedNormalIndices = fCheckedNormalIndices;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numFaceCounts           = fFaceCountsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* faceCounts = fFaceCountsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>    numPositions = fPositionsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* positions = fPositionsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numVerts = numPositions / 3;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (numVerts == 0) {</div>
<div class="line">        fComputedNormalsScope = Alembic::AbcGeom::kUnknownScope;</div>
<div class="line">        fComputedNormals.reset();</div>
<div class="line">        fComputedNormalIndices.reset();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// allocate buffers for the new normals</span></div>
<div class="line">    GPUCache::shared_array&lt;float&gt; computedFaceNormals(<span class="keyword">new</span> <span class="keywordtype">float</span>[numFaceCounts * 3]);</div>
<div class="line">    GPUCache::shared_array&lt;float&gt; computedNormals(<span class="keyword">new</span> <span class="keywordtype">float</span>[numVerts * 3]);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute the face normals</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, polyVertOffset = 0; i &lt; numFaceCounts; polyVertOffset += faceCounts[i], i++) {</div>
<div class="line">        <span class="keywordtype">size_t</span> numPoints = faceCounts[i];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Newell&#39;s Method</span></div>
<div class="line">        <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> faceNormal(0.0f, 0.0f, 0.0f);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numPoints; j++) {</div>
<div class="line">            <span class="keywordtype">size_t</span> thisJ = numPoints - j - 1;</div>
<div class="line">            <span class="keywordtype">size_t</span> nextJ = numPoints - ((j + 1) % numPoints) - 1;</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>* thisPoint = &amp;positions[faceIndices[polyVertOffset + thisJ] * 3];</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>* nextPoint = &amp;positions[faceIndices[polyVertOffset + nextJ] * 3];</div>
<div class="line">            faceNormal.x += (thisPoint[1] - nextPoint[1]) * (thisPoint[2] + nextPoint[2]);</div>
<div class="line">            faceNormal.y += (thisPoint[2] - nextPoint[2]) * (thisPoint[0] + nextPoint[0]);</div>
<div class="line">            faceNormal.z += (thisPoint[0] - nextPoint[0]) * (thisPoint[1] + nextPoint[1]);</div>
<div class="line">        }</div>
<div class="line">        faceNormal.normalize();</div>
<div class="line"></div>
<div class="line">        computedFaceNormals[i * 3 + 0] = faceNormal.x;</div>
<div class="line">        computedFaceNormals[i * 3 + 1] = faceNormal.y;</div>
<div class="line">        computedFaceNormals[i * 3 + 2] = faceNormal.z;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute the normals</span></div>
<div class="line">    memset(&amp;computedNormals[0], 0, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * numVerts * 3);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, polyVertOffset = 0; i &lt; numFaceCounts; polyVertOffset += faceCounts[i], i++) {</div>
<div class="line">        <span class="keywordtype">size_t</span> numPoints = faceCounts[i];</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span>* faceNormal = &amp;computedFaceNormals[i * 3];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// accumulate the face normal</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numPoints; j++) {</div>
<div class="line">            <span class="keywordtype">float</span>* normal = &amp;computedNormals[faceIndices[polyVertOffset + j] * 3];</div>
<div class="line">            normal[0] += faceNormal[0];</div>
<div class="line">            normal[1] += faceNormal[1];</div>
<div class="line">            normal[2] += faceNormal[2];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// normalize normals, MFloatVector functions are inline functions</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numVerts; i++) {</div>
<div class="line">        <span class="keywordtype">float</span>* normal = &amp;computedNormals[i * 3];</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> vector(normal[0], normal[1], normal[2]);</div>
<div class="line">        vector.normalize();</div>
<div class="line"></div>
<div class="line">        normal[0] = vector.x;</div>
<div class="line">        normal[1] = vector.y;</div>
<div class="line">        normal[2] = vector.z;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fComputedNormalsScope = Alembic::AbcGeom::kVertexScope;</div>
<div class="line">    fComputedNormals      = SharedArray&lt;float&gt;::create(computedNormals, numVerts * 3);</div>
<div class="line">    fComputedNormalIndices.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Triangulator::convertMultiIndexedStreams()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// convert multi-indexed streams to single-indexed streams</span></div>
<div class="line">    <span class="comment">// assume the scope is kVarying/kVertex/kFacevarying</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// input polygons data</span></div>
<div class="line">    <span class="keywordtype">size_t</span>                      numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input normals</span></div>
<div class="line">    <span class="keywordtype">bool</span>                        normalFaceVarying = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* normalIndices     = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (fComputedNormals) {</div>
<div class="line">        normalFaceVarying = (fComputedNormalsScope == Alembic::AbcGeom::kFacevaryingScope);</div>
<div class="line">        <span class="keywordflow">if</span> (fComputedNormalIndices) {</div>
<div class="line">            normalIndices = fComputedNormalIndices-&gt;get();</div>
<div class="line">            assert(fComputedNormalIndices-&gt;size() == numFaceIndices);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input UV indices</span></div>
<div class="line">    <span class="keywordtype">bool</span>                        uvFaceVarying = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* uvIndices     = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (fCheckedUVs) {</div>
<div class="line">        uvFaceVarying = (fCheckedUVsScope == Alembic::AbcGeom::kFacevaryingScope);</div>
<div class="line">        <span class="keywordflow">if</span> (fCheckedUVIndices) {</div>
<div class="line">            uvIndices = fCheckedUVIndices-&gt;get();</div>
<div class="line">            assert(fCheckedUVIndices-&gt;size() == numFaceIndices);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// determine the number of multi-indexed streams</span></div>
<div class="line">    MultiIndexedStreamsConverter&lt;IndexBuffer::index_t&gt; converter(</div>
<div class="line">            numFaceIndices, faceIndices);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (normalFaceVarying) {</div>
<div class="line">        converter.addMultiIndexedStream(normalIndices);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (uvFaceVarying) {</div>
<div class="line">        converter.addMultiIndexedStream(uvIndices);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// only one multi-indexed streams, no need to convert it</span></div>
<div class="line">    <span class="keywordflow">if</span> (converter.numStreams() == 1) {</div>
<div class="line">        fVertAttribsIndices.reset();</div>
<div class="line">        fMappedFaceIndices = fFaceIndicesCache.getValue();</div>
<div class="line">        fNumVertices       = fPositionsCache.getValue()-&gt;size() / 3;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// convert the multi-indexed streams</span></div>
<div class="line">    converter.compute();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the mapped face indices</span></div>
<div class="line">    fMappedFaceIndices = SharedArray&lt;IndexBuffer::index_t&gt;::create(</div>
<div class="line">        converter.mappedFaceIndices(), numFaceIndices);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// indices to remap streams</span></div>
<div class="line">    fVertAttribsIndices = converter.vertAttribsIndices();</div>
<div class="line">    fNumVertices        = converter.numVertices();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Triangulator::remapVertAttribs()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// remap vertex attribute streams according to the result of convertMultiIndexedStreams()</span></div>
<div class="line">    <span class="comment">// assume the scope is kVarying/kVertex/kFacevarying</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// no multi-index streams, just drop indices</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fVertAttribsIndices) {</div>
<div class="line">        <span class="comment">// positions is the only stream, just use it</span></div>
<div class="line">        fMappedPositions = fPositionsCache.getValue();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// get rid of normal indices</span></div>
<div class="line">        <span class="keywordflow">if</span> (fComputedNormals) {</div>
<div class="line">            <span class="keywordflow">if</span> (fComputedNormalIndices) {</div>
<div class="line">                fMappedNormals = convertMultiIndexedStream&lt;3&gt;(</div>
<div class="line">                    fComputedNormals, fComputedNormalIndices);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                fMappedNormals = fComputedNormals;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// get rid of UV indices</span></div>
<div class="line">        <span class="keywordflow">if</span> (fCheckedUVs) {</div>
<div class="line">            <span class="keywordflow">if</span> (fCheckedUVIndices) {</div>
<div class="line">                fMappedUVs = convertMultiIndexedStream&lt;2&gt;(</div>
<div class="line">                    fCheckedUVs, fCheckedUVIndices);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                fMappedUVs = fCheckedUVs;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input polygons data</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>*                positions   = fPositionsCache.getValue()-&gt;get();</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input normals</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>*                normals       = NULL;</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* normalIndices = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (fComputedNormals) {</div>
<div class="line">        normals = fComputedNormals-&gt;get();</div>
<div class="line">        <span class="keywordflow">if</span> (fComputedNormalIndices) {</div>
<div class="line">            normalIndices = fComputedNormalIndices-&gt;get();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input UV indices</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>*                UVs       = NULL;</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* uvIndices = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (fCheckedUVs) {</div>
<div class="line">        UVs = fCheckedUVs-&gt;get();</div>
<div class="line">        <span class="keywordflow">if</span> (fCheckedUVIndices) {</div>
<div class="line">            uvIndices = fCheckedUVIndices-&gt;get();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// set up multi-indexed streams remapper</span></div>
<div class="line">    MultiIndexedStreamsRemapper&lt;IndexBuffer::index_t&gt; remapper(</div>
<div class="line">        faceIndices, fNumVertices, fVertAttribsIndices.get());</div>
<div class="line"></div>
<div class="line">    remapper.addMultiIndexedStream(positions, NULL, <span class="keyword">false</span>, 3);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (normals) {</div>
<div class="line">        remapper.addMultiIndexedStream(normals, normalIndices,</div>
<div class="line">            fComputedNormalsScope == Alembic::AbcGeom::kFacevaryingScope, 3);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (UVs) {</div>
<div class="line">        remapper.addMultiIndexedStream(UVs, uvIndices, </div>
<div class="line">            fCheckedUVsScope == Alembic::AbcGeom::kFacevaryingScope, 2);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// remap streams</span></div>
<div class="line">    remapper.compute();</div>
<div class="line"></div>
<div class="line">    fMappedPositions = SharedArray&lt;float&gt;::create(</div>
<div class="line">        remapper.mappedVertAttribs(0), fNumVertices * 3);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> streamIndex = 1;</div>
<div class="line">    <span class="keywordflow">if</span> (normals) {</div>
<div class="line">        fMappedNormals = SharedArray&lt;float&gt;::create(</div>
<div class="line">            remapper.mappedVertAttribs(streamIndex++), fNumVertices * 3);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (UVs) {</div>
<div class="line">        fMappedUVs = SharedArray&lt;float&gt;::create(</div>
<div class="line">            remapper.mappedVertAttribs(streamIndex++), fNumVertices * 2);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Triangulator::computeWireIndices()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// compute the wireframe indices</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span>           numFaceCounts = fFaceCountsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* faceCounts = fFaceCountsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>                   numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* mappedFaceIndices = fMappedFaceIndices-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute wireframe indices</span></div>
<div class="line">    WireIndicesGenerator&lt;IndexBuffer::index_t&gt; wireIndicesGenerator(</div>
<div class="line">            numFaceCounts, faceCounts, numFaceIndices, faceIndices, mappedFaceIndices);</div>
<div class="line">    wireIndicesGenerator.compute();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (wireIndicesGenerator.numWires() == 0) {</div>
<div class="line">        fWireIndices.reset();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fWireIndices = SharedArray&lt;IndexBuffer::index_t&gt;::create(</div>
<div class="line">        wireIndicesGenerator.wireIndices(), wireIndicesGenerator.numWires() * 2);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Triangulator::triangulate()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// triangulate the polygons</span></div>
<div class="line">    <span class="comment">// assume that there are no holes</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span>           numFaceCounts = fFaceCountsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* faceCounts = fFaceCountsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* faceIndices = fMappedFaceIndices-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* positions = fMappedPositions-&gt;get();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* normals   = fMappedNormals ? fMappedNormals-&gt;get() : NULL;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (numFaceCounts == 0) {</div>
<div class="line">        fTriangleIndices.reset();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Triangulate polygons</span></div>
<div class="line">    PolyTriangulator&lt;IndexBuffer::index_t&gt; polyTriangulator(</div>
<div class="line">        numFaceCounts, faceCounts, faceIndices, <span class="keyword">true</span>, positions, normals);</div>
<div class="line"></div>
<div class="line">    polyTriangulator.compute();</div>
<div class="line">    </div>
<div class="line">    fTriangleIndices = SharedArray&lt;IndexBuffer::index_t&gt;::create(</div>
<div class="line">        polyTriangulator.triangleIndices(), polyTriangulator.numTriangles() * 3);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS NurbsTessellator</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">NurbsTessellator::NurbsTessellator(</div>
<div class="line">    Alembic::AbcGeom::INuPatchSchema&amp; abcNurbs,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">    : DataProvider(abcNurbs, abcNurbs.getTimeSampling(),</div>
<div class="line">                   abcNurbs.getNumSamples(), needUVs),</div>
<div class="line">    fSurfaceValid(false)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Control point positions</span></div>
<div class="line">    fPositionsCache.init(abcNurbs.getPositionsProperty());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Number of control points</span></div>
<div class="line">    fNumUCache.init(Alembic::Abc::IInt32Property(abcNurbs.getPtr(), <span class="stringliteral">&quot;nu&quot;</span>));</div>
<div class="line">    fNumVCache.init(Alembic::Abc::IInt32Property(abcNurbs.getPtr(), <span class="stringliteral">&quot;nv&quot;</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Order (Degree + 1)</span></div>
<div class="line">    fUOrderCache.init(Alembic::Abc::IInt32Property(abcNurbs.getPtr(), <span class="stringliteral">&quot;uOrder&quot;</span>));</div>
<div class="line">    fVOrderCache.init(Alembic::Abc::IInt32Property(abcNurbs.getPtr(), <span class="stringliteral">&quot;vOrder&quot;</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Knots</span></div>
<div class="line">    fUKnotCache.init(abcNurbs.getUKnotsProperty());</div>
<div class="line">    fVKnotCache.init(abcNurbs.getVKnotsProperty());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Control point weights</span></div>
<div class="line">    Alembic::AbcGeom::IFloatArrayProperty positionWeights = abcNurbs.getPositionWeightsProperty();</div>
<div class="line">    <span class="keywordflow">if</span> (positionWeights.valid()) {</div>
<div class="line">        fPositionWeightsCache.init(positionWeights);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Trim curves</span></div>
<div class="line">    <span class="keywordflow">if</span> (abcNurbs.hasTrimCurve()) {</div>
<div class="line">        <span class="comment">// Number of loops</span></div>
<div class="line">        fTrimNumLoopsCache.init(</div>
<div class="line">            Alembic::Abc::IInt32Property(abcNurbs.getPtr(), <span class="stringliteral">&quot;trim_nloops&quot;</span>));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Number of curves</span></div>
<div class="line">        fTrimNumCurvesCache.init(</div>
<div class="line">            Alembic::Abc::IInt32ArrayProperty(abcNurbs.getPtr(), <span class="stringliteral">&quot;trim_ncurves&quot;</span>));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Number of control points</span></div>
<div class="line">        fTrimNumVerticesCache.init(</div>
<div class="line">            Alembic::Abc::IInt32ArrayProperty(abcNurbs.getPtr(), <span class="stringliteral">&quot;trim_n&quot;</span>));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Curve Orders</span></div>
<div class="line">        fTrimOrderCache.init(</div>
<div class="line">            Alembic::Abc::IInt32ArrayProperty(abcNurbs.getPtr(), <span class="stringliteral">&quot;trim_order&quot;</span>));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Curve Knots</span></div>
<div class="line">        fTrimKnotCache.init(</div>
<div class="line">            Alembic::Abc::IFloatArrayProperty(abcNurbs.getPtr(), <span class="stringliteral">&quot;trim_knot&quot;</span>));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Curve U</span></div>
<div class="line">        fTrimUCache.init(</div>
<div class="line">            Alembic::Abc::IFloatArrayProperty(abcNurbs.getPtr(), <span class="stringliteral">&quot;trim_u&quot;</span>));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Curve V</span></div>
<div class="line">        fTrimVCache.init(</div>
<div class="line">            Alembic::Abc::IFloatArrayProperty(abcNurbs.getPtr(), <span class="stringliteral">&quot;trim_v&quot;</span>));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Curve W</span></div>
<div class="line">        fTrimWCache.init(</div>
<div class="line">            Alembic::Abc::IFloatArrayProperty(abcNurbs.getPtr(), <span class="stringliteral">&quot;trim_w&quot;</span>));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">NurbsTessellator::~NurbsTessellator()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// free the property readers</span></div>
<div class="line">    fPositionsCache.reset();</div>
<div class="line">    fNumUCache.reset();</div>
<div class="line">    fNumVCache.reset();</div>
<div class="line">    fUOrderCache.reset();</div>
<div class="line">    fVOrderCache.reset();</div>
<div class="line">    fUKnotCache.reset();</div>
<div class="line">    fVKnotCache.reset();</div>
<div class="line"></div>
<div class="line">    fPositionWeightsCache.reset();</div>
<div class="line"></div>
<div class="line">    fTrimNumLoopsCache.reset();</div>
<div class="line">    fTrimNumCurvesCache.reset();</div>
<div class="line">    fTrimNumVerticesCache.reset();</div>
<div class="line">    fTrimOrderCache.reset();</div>
<div class="line">    fTrimKnotCache.reset();</div>
<div class="line">    fTrimUCache.reset();</div>
<div class="line">    fTrimVCache.reset();</div>
<div class="line">    fTrimWCache.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> NurbsTessellator::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> DataProvider::valid() &amp;&amp;</div>
<div class="line">            fPositionsCache.valid() &amp;&amp;</div>
<div class="line">            fNumUCache.valid() &amp;&amp;</div>
<div class="line">            fNumVCache.valid() &amp;&amp;</div>
<div class="line">            fUOrderCache.valid() &amp;&amp;</div>
<div class="line">            fVOrderCache.valid() &amp;&amp;</div>
<div class="line">            fUKnotCache.valid() &amp;&amp;</div>
<div class="line">            fVKnotCache.valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;const ShapeSample&gt; </div>
<div class="line">NurbsTessellator::getSample(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// empty mesh</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fWireIndices || !fTriangleIndices) {</div>
<div class="line">        std::shared_ptr&lt;ShapeSample&gt; sample =</div>
<div class="line">            ShapeSample::createEmptySample(seconds);</div>
<div class="line">        <span class="keywordflow">return</span> sample;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// triangle indices</span></div>
<div class="line">    <span class="comment">// Currently, we only have 1 group</span></div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;IndexBuffer&gt; &gt; triangleVertIndices;</div>
<div class="line">    triangleVertIndices.push_back(IndexBuffer::create(fTriangleIndices));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ShapeSample&gt; sample = ShapeSample::create(</div>
<div class="line">        seconds,                                     <span class="comment">// time (in seconds)</span></div>
<div class="line">        fWireIndices-&gt;size() / 2,                    <span class="comment">// number of wireframes</span></div>
<div class="line">        fPositions-&gt;size() / 3,                      <span class="comment">// number of vertices</span></div>
<div class="line">        IndexBuffer::create(fWireIndices),           <span class="comment">// wireframe indices</span></div>
<div class="line">        triangleVertIndices,                         <span class="comment">// triangle indices (1 group)</span></div>
<div class="line">        VertexBuffer::createPositions(fPositions),   <span class="comment">// position</span></div>
<div class="line">        getBoundingBox(),                            <span class="comment">// bounding box</span></div>
<div class="line">        Config::kDefaultGrayColor,                   <span class="comment">// diffuse color</span></div>
<div class="line">        isVisible()</div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (fNormals) {</div>
<div class="line">        sample-&gt;setNormals(</div>
<div class="line">            VertexBuffer::createNormals(fNormals));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fUVs) {</div>
<div class="line">        sample-&gt;setUVs(</div>
<div class="line">            VertexBuffer::createUVs(fUVs));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval NurbsTessellator::updateCache(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    TimeInterval validityInterval(DataProvider::updateCache(time));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update caches</span></div>
<div class="line">    <span class="keywordtype">bool</span> positionsChanged = fPositionsCache.setTime(time);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> topologyChanged = fNumUCache.setTime(time);</div>
<div class="line">    topologyChanged      = fNumVCache.setTime(time)   || topologyChanged;</div>
<div class="line">    topologyChanged      = fUOrderCache.setTime(time) || topologyChanged;</div>
<div class="line">    topologyChanged      = fVOrderCache.setTime(time) || topologyChanged;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> knotChanged = fUKnotCache.setTime(time);</div>
<div class="line">    knotChanged      = fVKnotCache.setTime(time) || knotChanged;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fPositionWeightsCache.valid()) {</div>
<div class="line">        positionsChanged = fPositionWeightsCache.setTime(time) || positionsChanged;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> trimCurvesChanged = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (fTrimNumLoopsCache.valid()) {</div>
<div class="line">        trimCurvesChanged = fTrimNumLoopsCache.setTime(time)    || trimCurvesChanged;</div>
<div class="line">        trimCurvesChanged = fTrimNumCurvesCache.setTime(time)   || trimCurvesChanged;</div>
<div class="line">        trimCurvesChanged = fTrimNumVerticesCache.setTime(time) || trimCurvesChanged;</div>
<div class="line">        trimCurvesChanged = fTrimOrderCache.setTime(time)       || trimCurvesChanged;</div>
<div class="line">        trimCurvesChanged = fTrimKnotCache.setTime(time)        || trimCurvesChanged;</div>
<div class="line">        trimCurvesChanged = fTrimUCache.setTime(time)           || trimCurvesChanged;</div>
<div class="line">        trimCurvesChanged = fTrimVCache.setTime(time)           || trimCurvesChanged;</div>
<div class="line">        trimCurvesChanged = fTrimWCache.setTime(time)           || trimCurvesChanged;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// return the new cache valid interval</span></div>
<div class="line">    validityInterval &amp;= fPositionsCache.getValidityInterval();</div>
<div class="line">    validityInterval &amp;= fNumUCache.getValidityInterval();</div>
<div class="line">    validityInterval &amp;= fNumVCache.getValidityInterval();</div>
<div class="line">    validityInterval &amp;= fUOrderCache.getValidityInterval();</div>
<div class="line">    validityInterval &amp;= fVOrderCache.getValidityInterval();</div>
<div class="line">    validityInterval &amp;= fUKnotCache.getValidityInterval();</div>
<div class="line">    validityInterval &amp;= fVKnotCache.getValidityInterval();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fPositionWeightsCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fPositionWeightsCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fTrimNumLoopsCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fTrimNumLoopsCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fTrimNumCurvesCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fTrimNumVerticesCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fTrimOrderCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fTrimKnotCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fTrimUCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fTrimVCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fTrimWCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// do a minimal check for the consistency</span></div>
<div class="line">    check();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// set Alembic INuPatch to Maya MFnNurbsSurface</span></div>
<div class="line">    <span class="keywordtype">bool</span> rebuild = topologyChanged || knotChanged || </div>
<div class="line">                   trimCurvesChanged || fNurbsData.object().isNull();</div>
<div class="line">    setNurbs(rebuild, positionsChanged);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// tessellate Maya NURBS and convert to poly</span></div>
<div class="line">    <span class="keywordflow">if</span> (rebuild || positionsChanged) {</div>
<div class="line">        tessellate();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isVisible()) {</div>
<div class="line">        convertToPoly();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> NurbsTessellator::check()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// reset valid flag</span></div>
<div class="line">    <a name="_a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    fSurfaceValid = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// numKnots = numCV + degree + 1</span></div>
<div class="line">    <span class="keywordtype">int</span> uDegree   = fUOrderCache.getValue() - 1;</div>
<div class="line">    <span class="keywordtype">int</span> vDegree   = fVOrderCache.getValue() - 1;</div>
<div class="line">    <span class="keywordtype">int</span> numUCV    = fNumUCache.getValue();</div>
<div class="line">    <span class="keywordtype">int</span> numVCV    = fNumVCache.getValue();</div>
<div class="line">    <span class="keywordtype">int</span> numUKnots = (int)fUKnotCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keywordtype">int</span> numVKnots = (int)fVKnotCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keywordflow">if</span> (numUKnots != numUCV + uDegree + 1 || numVKnots != numVCV + vDegree + 1) {</div>
<div class="line">        fSurfaceValid = <span class="keyword">false</span>;</div>
<div class="line">        DisplayWarning(kBadNurbsMsg);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// numCV = numU * numV</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numCVs = numUCV * numVCV;</div>
<div class="line">    <span class="keywordflow">if</span> (numCVs * 3 != fPositionsCache.getValue()-&gt;size()) {</div>
<div class="line">        fSurfaceValid = <span class="keyword">false</span>;</div>
<div class="line">        DisplayWarning(kBadNurbsMsg);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// numCV = numWeight</span></div>
<div class="line">    <span class="keywordflow">if</span> (fPositionWeightsCache.valid() &amp;&amp;</div>
<div class="line">            numCVs != fPositionWeightsCache.getValue()-&gt;size()) {</div>
<div class="line">        fSurfaceValid = <span class="keyword">false</span>;</div>
<div class="line">        DisplayWarning(kBadNurbsMsg);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> NurbsTessellator::setNurbs(<span class="keywordtype">bool</span> rebuild, <span class="keywordtype">bool</span> positionsChanged)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!fSurfaceValid) {</div>
<div class="line">        <span class="comment">// invalid NURBS</span></div>
<div class="line">        fNurbsData.setObject(<a name="a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">        fNurbs.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Number of control points in U/V direction</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numU = 0;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numV = 0;</div>
<div class="line"></div>
<div class="line">    <a name="_a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_point_array.html">MPointArray</a> mayaPositions;</div>
<div class="line">    <span class="keywordflow">if</span> (rebuild || positionsChanged) {</div>
<div class="line">        numU = fNumUCache.getValue();</div>
<div class="line">        numV = fNumVCache.getValue();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Positions and their weights</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span>* positions = fPositionsCache.getValue()-&gt;<a name="a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#aab050cd677ada1564ca558d3840628cd">get</a>();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span>* positionWeights = NULL;</div>
<div class="line">        <span class="keywordflow">if</span> (fPositionWeightsCache.valid()) {</div>
<div class="line">            positionWeights = fPositionWeightsCache.getValue()-&gt;get();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// allocate memory for positions</span></div>
<div class="line">        mayaPositions.<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>(numU * numV);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Maya is U-major and has inversed V</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0; u &lt; numU; u++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; numV; v++) {</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> alembicIndex = v * numU + u;</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mayaIndex    = u * numV + (numV - v - 1);</div>
<div class="line"></div>
<div class="line">                <a name="_a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> point(positions[alembicIndex * 3 + 0],</div>
<div class="line">                             positions[alembicIndex * 3 + 1],</div>
<div class="line">                             positions[alembicIndex * 3 + 2],</div>
<div class="line">                             1.0);</div>
<div class="line">                <span class="keywordflow">if</span> (positionWeights) {</div>
<div class="line">                    point.w = positionWeights[alembicIndex];</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                mayaPositions[mayaIndex] = point;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (rebuild) {</div>
<div class="line">        <span class="comment">// Nurbs degree</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uDegree = fUOrderCache.getValue() - 1;</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vDegree = fVOrderCache.getValue() - 1;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Nurbs form</span></div>
<div class="line">        <span class="comment">// Alemblic file does not record the form of nurb surface, we get the form</span></div>
<div class="line">        <span class="comment">// by checking the CV data. If the first degree number CV overlap the last</span></div>
<div class="line">        <span class="comment">// degree number CV, then the form is kPeriodic. If only the first CV overlaps</span></div>
<div class="line">        <span class="comment">// the last CV, then the form is kClosed.</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66">MFnNurbsSurface::Form</a> uForm = <a name="a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a0ed9d38a35a60087a093558dad96d882">MFnNurbsSurface::kPeriodic</a>;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66">MFnNurbsSurface::Form</a> vForm = <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a0ed9d38a35a60087a093558dad96d882">MFnNurbsSurface::kPeriodic</a>;</div>
<div class="line">        <span class="comment">// Check all curves</span></div>
<div class="line">        <span class="keywordtype">bool</span> notOpen = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; notOpen &amp;&amp; v &lt; numV; v++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0; u &lt; uDegree; u++) {</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> firstIndex = u * numV + (numV - v - 1);</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastPeriodicIndex = (numU - uDegree + u) * numV + (numV - v - 1);</div>
<div class="line">                <span class="keywordflow">if</span> (!mayaPositions[firstIndex].isEquivalent(mayaPositions[lastPeriodicIndex])) {</div>
<div class="line">                    uForm = <a name="a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">MFnNurbsSurface::kOpen</a>;</div>
<div class="line">                    notOpen = <span class="keyword">false</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (uForm == <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">MFnNurbsSurface::kOpen</a>) {</div>
<div class="line">            uForm = <a name="a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a44be8f61450ed22be5adcc881a95570f">MFnNurbsSurface::kClosed</a>;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; numV; v++) {</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastUIndex = (numU - 1) * numV + (numV - v - 1);</div>
<div class="line">                <span class="keywordflow">if</span> (!mayaPositions[numV-v-1].isEquivalent(mayaPositions[lastUIndex])) {</div>
<div class="line">                    uForm = <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">MFnNurbsSurface::kOpen</a>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        notOpen = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0; notOpen &amp;&amp; u &lt; numU; u++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; vDegree; v++) {</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> firstIndex = u * numV + (numV - v - 1);</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastPeriodicIndex =  u * numV + (vDegree - v - 1); <span class="comment">//numV - (numV - vDegree + v) - 1;</span></div>
<div class="line">                <span class="keywordflow">if</span> (!mayaPositions[firstIndex].isEquivalent(mayaPositions[lastPeriodicIndex])) {</div>
<div class="line">                    vForm = <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">MFnNurbsSurface::kOpen</a>;</div>
<div class="line">                    notOpen = <span class="keyword">false</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (vForm == <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">MFnNurbsSurface::kOpen</a>) {</div>
<div class="line">            vForm = <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a44be8f61450ed22be5adcc881a95570f">MFnNurbsSurface::kClosed</a>;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0; u &lt; numU; u++) {</div>
<div class="line">                <span class="keywordflow">if</span> (!mayaPositions[u*numV+(numV-1)].isEquivalent(mayaPositions[u*numV])) {</div>
<div class="line">                    vForm = <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">MFnNurbsSurface::kOpen</a>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line"></div>
<div class="line">        <span class="comment">// Knots</span></div>
<div class="line">        <span class="comment">//   Dispose the leading and trailing knots</span></div>
<div class="line">        <span class="comment">//   Alembic duplicate CVs if the form is not kOpen</span></div>
<div class="line">        <span class="comment">//   For more information, refer to MFnNurbsSurface</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numUKnot = (<span class="keywordtype">unsigned</span> int)fUKnotCache.getValue()-&gt;size();</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numVKnot = (<span class="keywordtype">unsigned</span> int)fVKnotCache.getValue()-&gt;size();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span>* uKnot    = fUKnotCache.getValue()-&gt;get();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span>* vKnot    = fVKnotCache.getValue()-&gt;get();</div>
<div class="line">        <a name="_a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> mayaUKnots(uKnot + 1, numUKnot - 2);</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> mayaVKnots(vKnot + 1, numVKnot - 2);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Create the Nurbs</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">        <a name="_a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> nurbsData = fNurbsData.create();</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> nurbs     = fNurbs.create(mayaPositions,</div>
<div class="line">                                          mayaUKnots, mayaVKnots,</div>
<div class="line">                                          uDegree, vDegree,</div>
<div class="line">                                          uForm,</div>
<div class="line">                                          vForm,</div>
<div class="line">                                          <span class="keyword">true</span>,</div>
<div class="line">                                          nurbsData,</div>
<div class="line">                                          &amp;status);</div>
<div class="line">        <span class="keywordflow">if</span> (status != MS::kSuccess || nurbs.<a name="a13"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>()) {</div>
<div class="line">            <span class="comment">// creation failure</span></div>
<div class="line">            fNurbsData.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">            fNurbs.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Trim Nurbs</span></div>
<div class="line">        <span class="keywordflow">if</span> (fTrimNumLoopsCache.valid()) {</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> trimNumLoops = fTrimNumLoopsCache.getValue();</div>
<div class="line">            <span class="comment">// mayaV = offsetV - alembicV</span></div>
<div class="line">            <span class="keywordtype">double</span> startU, endU, startV, endV;</div>
<div class="line">            fNurbs.getKnotDomain(startU, endU, startV, endV);</div>
<div class="line">            <span class="keywordtype">double</span> offsetV = startV + endV;</div>
<div class="line"></div>
<div class="line">            <a name="_a14"></a><a class="code" href="#!/url=./cpp_ref/class_m_trim_boundary_array.html">MTrimBoundaryArray</a> boundaryArray;</div>
<div class="line"></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* trimNumCurves = </div>
<div class="line">                    fTrimNumCurvesCache.getValue()-&gt;<a name="a15"></a><a class="code" href="#!/url=./cpp_ref/class_m_trim_boundary_array.html#af99b4425d90f73b88634ec50327ae48a">get</a>();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* trimNumVertices =</div>
<div class="line">                    fTrimNumVerticesCache.getValue()-&gt;<a name="a16"></a><a class="code" href="#!/url=./cpp_ref/class_m_object_array.html#a8223a66b2c37fdf38b8a95b53566a7a7">get</a>();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* trimOrder =</div>
<div class="line">                    fTrimOrderCache.getValue()-&gt;get();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>* trimKnot = fTrimKnotCache.getValue()-&gt;get();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>* trimU    = fTrimUCache.getValue()-&gt;get();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>* trimV    = fTrimVCache.getValue()-&gt;get();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>* trimW    = fTrimWCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; trimNumLoops; i++) {</div>
<div class="line">                <span class="comment">// Set up curves for each boundary</span></div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numCurves = *trimNumCurves;</div>
<div class="line">                <a name="_a17"></a><a class="code" href="#!/url=./cpp_ref/class_m_object_array.html">MObjectArray</a> boundary(numCurves);</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numCurves; j++) {</div>
<div class="line">                    <span class="comment">// Set up one curve</span></div>
<div class="line">                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numVertices = *trimNumVertices;</div>
<div class="line">                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree      = *trimOrder - 1;</div>
<div class="line">                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numKnots    = numVertices + degree + 1;</div>
<div class="line"></div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_point_array.html">MPointArray</a> controlPoints;</div>
<div class="line">                    controlPoints.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>(numVertices);</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; numVertices; k++) {</div>
<div class="line">                        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> point(trimU[k], offsetV - trimV[k], 0, trimW[k]);</div>
<div class="line">                        controlPoints[k] = point;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> knots(trimKnot + 1, numKnots - 2);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Create the curve</span></div>
<div class="line">                    <a name="_a18"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_curve_data.html">MFnNurbsCurveData</a> curveData;</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> curveDataObject = curveData.<a name="a19"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_curve_data.html#af1adb4abaf5243c6c0749bcca7b5c418">create</a>();</div>
<div class="line"></div>
<div class="line">                    <a name="_a20"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_curve.html">MFnNurbsCurve</a> curve;</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> curveObject  = curve.<a name="a21"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_curve.html#a4b11e346021c91845e781e9d7d06859f">create</a>(controlPoints, knots, degree,</div>
<div class="line">                            <a name="a22"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_curve.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">MFnNurbsCurve::kOpen</a>, <span class="keyword">true</span>, <span class="keyword">true</span>, curveDataObject, &amp;status);</div>
<div class="line">                    <span class="keywordflow">if</span> (status == MS::kSuccess &amp;&amp; !curveObject.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>()) {</div>
<div class="line">                        boundary[j] = curveDataObject;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// next curve</span></div>
<div class="line">                    trimNumVertices++;</div>
<div class="line">                    trimOrder++;</div>
<div class="line">                    trimKnot += numKnots;</div>
<div class="line">                    trimU    += numVertices;</div>
<div class="line">                    trimV    += numVertices;</div>
<div class="line">                    trimW    += numVertices;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                boundaryArray.<a name="a23"></a><a class="code" href="#!/url=./cpp_ref/class_m_trim_boundary_array.html#a58aa0ffd87a8ca32834b827e1452f23e">append</a>(boundary);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// next loop</span></div>
<div class="line">                trimNumCurves++;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_trim_boundary_array.html">MTrimBoundaryArray</a> oneRegion;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; boundaryArray.<a name="a24"></a><a class="code" href="#!/url=./cpp_ref/class_m_trim_boundary_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++) {</div>
<div class="line">                <span class="keywordflow">if</span> (i &gt; 0) {</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> loopData = boundaryArray.<a name="a25"></a><a class="code" href="#!/url=./cpp_ref/class_m_trim_boundary_array.html#a8c5c9d056371db0b771e14526c08b520">getMergedBoundary</a>(i, &amp;status);</div>
<div class="line">                    <span class="keywordflow">if</span> (status != MS::kSuccess) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_curve.html">MFnNurbsCurve</a> loop(loopData, &amp;status);</div>
<div class="line">                    <span class="keywordflow">if</span> (status != MS::kSuccess) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Check whether this loop is an outer boundary.</span></div>
<div class="line">                    <span class="keywordtype">bool</span> isOuterBoundary = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordtype">double</span>       length  = loop.length();</div>
<div class="line">                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> segment = std::max(loop.numCVs(), 10);</div>
<div class="line"></div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_point_array.html">MPointArray</a> curvePoints;</div>
<div class="line">                    curvePoints.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>(segment);</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; segment; j++) {</div>
<div class="line">                        <span class="keywordtype">double</span> param = loop.findParamFromLength(length * j / segment);</div>
<div class="line">                        loop.getPointAtParam(param, curvePoints[j]);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Find the right most curve point</span></div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>       rightMostPoint = curvePoints[0];</div>
<div class="line">                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rightMostIndex = 0;</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; curvePoints.length(); j++) {</div>
<div class="line">                        <span class="keywordflow">if</span> (rightMostPoint.<a name="a26"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> &lt; curvePoints[j].x) {</div>
<div class="line">                            rightMostPoint = curvePoints[j];</div>
<div class="line">                            rightMostIndex = j;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Find the vertex just before and after the right most vertex</span></div>
<div class="line">                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> beforeIndex = (rightMostIndex == 0) ? curvePoints.length() - 1 : rightMostIndex - 1;</div>
<div class="line">                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> afterIndex  = (rightMostIndex == curvePoints.length() - 1) ? 0 : rightMostIndex + 1;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; curvePoints.length(); j++) {</div>
<div class="line">                        <span class="keywordflow">if</span> (fabs(curvePoints[beforeIndex].x - curvePoints[rightMostIndex].x) &lt; 1e-5) {</div>
<div class="line">                            beforeIndex = (beforeIndex == 0) ? curvePoints.length() - 1 : beforeIndex - 1;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; curvePoints.length(); j++) {</div>
<div class="line">                        <span class="keywordflow">if</span> (fabs(curvePoints[afterIndex].x - curvePoints[rightMostIndex].x) &lt; 1e-5) {</div>
<div class="line">                            afterIndex = (afterIndex == curvePoints.length() - 1) ? 0 : afterIndex + 1;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// failed. not a closed curve.</span></div>
<div class="line">                    <span class="keywordflow">if</span> (fabs(curvePoints[afterIndex].x - curvePoints[rightMostIndex].x) &lt; 1e-5 &amp;&amp;</div>
<div class="line">                        fabs(curvePoints[beforeIndex].x - curvePoints[rightMostIndex].x) &lt; 1e-5) {</div>
<div class="line">                        <span class="keywordflow">continue</span>;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Compute the cross product</span></div>
<div class="line">                    <a name="_a27"></a><a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> vector1 = curvePoints[beforeIndex] - curvePoints[rightMostIndex];</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> vector2 = curvePoints[afterIndex]  - curvePoints[rightMostIndex];</div>
<div class="line">                    <span class="keywordflow">if</span> ((vector1 ^ vector2).z &lt; 0) {</div>
<div class="line">                        isOuterBoundary = <span class="keyword">true</span>;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Trim the NURBS surface. An outer boundary starts a new region.</span></div>
<div class="line">                    <span class="keywordflow">if</span> (isOuterBoundary) {</div>
<div class="line">                        status = fNurbs.trimWithBoundaries(oneRegion, <span class="keyword">false</span>, 1e-3, 1e-5, <span class="keyword">true</span>);</div>
<div class="line">                        <span class="keywordflow">if</span> (status != MS::kSuccess) {</div>
<div class="line">                            fNurbsData.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">                            fNurbs.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">                            <span class="keywordflow">return</span>;</div>
<div class="line">                        }</div>
<div class="line">                        oneRegion.<a name="a28"></a><a class="code" href="#!/url=./cpp_ref/class_m_trim_boundary_array.html#ad5522f028dde0080b753279426415a4a">clear</a>();</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                oneRegion.<a class="code" href="#!/url=./cpp_ref/class_m_trim_boundary_array.html#a58aa0ffd87a8ca32834b827e1452f23e">append</a>(boundaryArray[i]);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            status = fNurbs.trimWithBoundaries(oneRegion, <span class="keyword">false</span>, 1e-3, 1e-5, <span class="keyword">true</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (status != MS::kSuccess) {</div>
<div class="line">                fNurbsData.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">                fNurbs.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        assert(!fNurbsData.object().isNull());</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (positionsChanged) {</div>
<div class="line">            fNurbs.setCVs(mayaPositions);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> NurbsTessellator::tessellate()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!fSurfaceValid || fNurbsData.object().isNull()) {</div>
<div class="line">        fPolyMeshData.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">        fPolyMesh.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create the mesh data to own the mesh</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> polyMeshData = fPolyMeshData.create();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set up parameters</span></div>
<div class="line">    <a name="_a29"></a><a class="code" href="#!/url=./cpp_ref/class_m_tesselation_params.html">MTesselationParams</a> params(</div>
<div class="line">        <a name="a30"></a><a class="code" href="#!/url=./cpp_ref/class_m_tesselation_params.html#a5b2a7c1776e72b64f6b50fc95871c146a0d4e0874a457fb879a20aa067222b65b">MTesselationParams::kStandardFitFormat</a>, <a name="a31"></a><a class="code" href="#!/url=./cpp_ref/class_m_tesselation_params.html#a05266719b7393f22777306c9b4faf514aa2c70dd76c8172a9298334473c914304">MTesselationParams::kTriangles</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Tess the NURBS to triangles</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> polyObject = fNurbs.tesselate(params, polyMeshData, &amp;status);</div>
<div class="line">    <span class="keywordflow">if</span> (status != MS::kSuccess || !polyObject.<a name="a32"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a33"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62">MFn::kMesh</a>)) {</div>
<div class="line">        <span class="comment">// tessellation failed</span></div>
<div class="line">        fPolyMeshData.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">        fPolyMesh.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    status = fPolyMesh.setObject(polyObject);</div>
<div class="line">    assert(status == MS::kSuccess);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> NurbsTessellator::convertToPoly()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!fSurfaceValid || fPolyMeshData.object().isNull() ||</div>
<div class="line">            fPolyMesh.numVertices() == 0 || fPolyMesh.numFaceVertices() == 0) {</div>
<div class="line">        fTriangleIndices.reset();</div>
<div class="line">        fWireIndices.reset();</div>
<div class="line">        fPositions.reset();</div>
<div class="line">        fNormals.reset();</div>
<div class="line">        fUVs.reset();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    MayaMeshExtractor&lt;IndexBuffer::index_t&gt; extractor(fPolyMeshData.object());</div>
<div class="line">    extractor.setWantUVs(fNeedUVs);</div>
<div class="line">    extractor.compute();</div>
<div class="line"></div>
<div class="line">    fTriangleIndices = extractor.triangleIndices();</div>
<div class="line">    fWireIndices     = extractor.wireIndices();</div>
<div class="line">    fPositions       = extractor.positions();</div>
<div class="line">    fNormals         = extractor.normals();</div>
<div class="line">    fUVs.reset();</div>
<div class="line">    <span class="keywordflow">if</span> (fNeedUVs) {</div>
<div class="line">        fUVs         = extractor.uvs();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubDSmoother</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">SubDSmoother::SubDSmoother(</div>
<div class="line">        Alembic::AbcGeom::ISubDSchema&amp;  abcSubD,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span>                      needUVs)</div>
<div class="line">    : PolyDataProvider(abcSubD, needUVs)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Face Indices</span></div>
<div class="line">    fFaceIndicesCache.init(abcSubD.getFaceIndicesProperty());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Crease Edges</span></div>
<div class="line">    Alembic::Abc::IInt32ArrayProperty creaseIndicesProp =</div>
<div class="line">            abcSubD.getCreaseIndicesProperty();</div>
<div class="line">    Alembic::Abc::IInt32ArrayProperty creaseLengthsProp =</div>
<div class="line">            abcSubD.getCreaseLengthsProperty();</div>
<div class="line">    Alembic::Abc::IFloatArrayProperty creaseSharpnessesProp = </div>
<div class="line">            abcSubD.getCreaseSharpnessesProperty();</div>
<div class="line">    <span class="keywordflow">if</span> (creaseIndicesProp.valid() &amp;&amp;</div>
<div class="line">            creaseLengthsProp.valid() &amp;&amp;</div>
<div class="line">            creaseSharpnessesProp.valid()) {</div>
<div class="line">        fCreaseIndicesCache.init(creaseIndicesProp);</div>
<div class="line">        fCreaseLengthsCache.init(creaseLengthsProp);</div>
<div class="line">        fCreaseSharpnessesCache.init(creaseSharpnessesProp);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Crease Vertices</span></div>
<div class="line">    Alembic::Abc::IInt32ArrayProperty cornerIndicesProp = </div>
<div class="line">            abcSubD.getCornerIndicesProperty();</div>
<div class="line">    Alembic::Abc::IFloatArrayProperty cornerSharpnessesProp =</div>
<div class="line">            abcSubD.getCornerSharpnessesProperty();</div>
<div class="line">    <span class="keywordflow">if</span> (cornerIndicesProp.valid() &amp;&amp; cornerSharpnessesProp.valid()) {</div>
<div class="line">        fCornerIndicesCache.init(cornerIndicesProp);</div>
<div class="line">        fCornerSharpnessesCache.init(cornerSharpnessesProp);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Invisible Faces</span></div>
<div class="line">    Alembic::Abc::IInt32ArrayProperty holesProp =</div>
<div class="line">            abcSubD.getHolesProperty();</div>
<div class="line">    <span class="keywordflow">if</span> (holesProp.valid()) {</div>
<div class="line">        fHolesCache.init(holesProp);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// UVs</span></div>
<div class="line">    <span class="keywordflow">if</span> (fNeedUVs) {</div>
<div class="line">        Alembic::AbcGeom::IV2fGeomParam UVs = abcSubD.getUVsParam();</div>
<div class="line">        <span class="keywordflow">if</span> (UVs.valid()) {</div>
<div class="line">            fUVsScope = UVs.getScope();</div>
<div class="line">            <span class="keywordflow">if</span> (fUVsScope == Alembic::AbcGeom::kVaryingScope ||</div>
<div class="line">                    fUVsScope == Alembic::AbcGeom::kVertexScope ||</div>
<div class="line">                    fUVsScope == Alembic::AbcGeom::kFacevaryingScope) {</div>
<div class="line">                fUVsCache.init(UVs.getValueProperty());</div>
<div class="line">                <span class="keywordflow">if</span> (UVs.isIndexed()) {</div>
<div class="line">                    fUVIndicesCache.init(UVs.getIndexProperty());</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">SubDSmoother::~SubDSmoother()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// free the property readers</span></div>
<div class="line">    fFaceIndicesCache.reset();</div>
<div class="line"></div>
<div class="line">    fCreaseIndicesCache.reset();</div>
<div class="line">    fCreaseLengthsCache.reset();</div>
<div class="line">    fCreaseSharpnessesCache.reset();</div>
<div class="line"></div>
<div class="line">    fCornerIndicesCache.reset();</div>
<div class="line">    fCornerSharpnessesCache.reset();</div>
<div class="line"></div>
<div class="line">    fHolesCache.reset();</div>
<div class="line"></div>
<div class="line">    fUVsScope = Alembic::AbcGeom::kUnknownScope;</div>
<div class="line">    fUVsCache.reset();</div>
<div class="line">    fUVIndicesCache.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> SubDSmoother::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> PolyDataProvider::valid() &amp;&amp;</div>
<div class="line">            fFaceIndicesCache.valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;const ShapeSample&gt; </div>
<div class="line">SubDSmoother::getSample(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// empty mesh</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fWireIndices || !fTriangleIndices) {</div>
<div class="line">        std::shared_ptr&lt;ShapeSample&gt; sample =</div>
<div class="line">            ShapeSample::createEmptySample(seconds);</div>
<div class="line">        <span class="keywordflow">return</span> sample;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// triangle indices</span></div>
<div class="line">    <span class="comment">// Currently, we only have 1 group</span></div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;IndexBuffer&gt; &gt; triangleVertIndices;</div>
<div class="line">    triangleVertIndices.push_back(IndexBuffer::create(fTriangleIndices));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ShapeSample&gt; sample = ShapeSample::create(</div>
<div class="line">        seconds,                                     <span class="comment">// time (in seconds)</span></div>
<div class="line">        fWireIndices-&gt;size() / 2,                    <span class="comment">// number of wireframes</span></div>
<div class="line">        fPositions-&gt;size() / 3,                      <span class="comment">// number of vertices</span></div>
<div class="line">        IndexBuffer::create(fWireIndices),           <span class="comment">// wireframe indices</span></div>
<div class="line">        triangleVertIndices,                         <span class="comment">// triangle indices (1 group)</span></div>
<div class="line">        VertexBuffer::createPositions(fPositions),   <span class="comment">// position</span></div>
<div class="line">        getBoundingBox(),                            <span class="comment">// bounding box</span></div>
<div class="line">        Config::kDefaultGrayColor,                   <span class="comment">// diffuse color</span></div>
<div class="line">        isVisible()</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fNormals) {</div>
<div class="line">        sample-&gt;setNormals(</div>
<div class="line">            VertexBuffer::createNormals(fNormals));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fUVs) {</div>
<div class="line">        sample-&gt;setUVs(</div>
<div class="line">            VertexBuffer::createUVs(fUVs));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">TimeInterval SubDSmoother::updateCache(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// update faceCounts/position cache here so that we can detect topology/position change.</span></div>
<div class="line">    <span class="comment">// next setTime() in DataProvider::updateCache() simply returns early</span></div>
<div class="line">    <span class="keywordtype">bool</span> topologyChanged = fFaceCountsCache.setTime(time);</div>
<div class="line">    <span class="keywordtype">bool</span> positionChanged = fPositionsCache.setTime(time);</div>
<div class="line"></div>
<div class="line">    TimeInterval validityInterval(PolyDataProvider::updateCache(time));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update caches</span></div>
<div class="line">    topologyChanged = fFaceIndicesCache.setTime(time) || topologyChanged;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> creaseEdgeChanged = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (fCreaseSharpnessesCache.valid()) {</div>
<div class="line">        creaseEdgeChanged = fCreaseIndicesCache.setTime(time) || creaseEdgeChanged;</div>
<div class="line">        creaseEdgeChanged = fCreaseLengthsCache.setTime(time) || creaseEdgeChanged;</div>
<div class="line">        creaseEdgeChanged = fCreaseSharpnessesCache.setTime(time) || creaseEdgeChanged;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> creaseVertexChanged = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (fCornerSharpnessesCache.valid()) {</div>
<div class="line">        creaseVertexChanged = fCornerIndicesCache.setTime(time) || creaseVertexChanged;</div>
<div class="line">        creaseVertexChanged = fCornerSharpnessesCache.setTime(time) || creaseVertexChanged;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> invisibleFaceChanged = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (fHolesCache.valid()) {</div>
<div class="line">        invisibleFaceChanged = fHolesCache.setTime(time);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> uvChanged = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        uvChanged = fUVsCache.setTime(time);</div>
<div class="line">        <span class="keywordflow">if</span> (fUVIndicesCache.valid()) {</div>
<div class="line">            uvChanged = fUVIndicesCache.setTime(time) || uvChanged;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// return the new cache valid interval</span></div>
<div class="line">    validityInterval &amp;= fFaceIndicesCache.getValidityInterval();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fCreaseSharpnessesCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fCreaseIndicesCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fCreaseLengthsCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fCreaseSharpnessesCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fCornerSharpnessesCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fCornerIndicesCache.getValidityInterval();</div>
<div class="line">        validityInterval &amp;= fCornerSharpnessesCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fHolesCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fHolesCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fUVsCache.getValidityInterval();</div>
<div class="line">        <span class="keywordflow">if</span> (fUVIndicesCache.valid()) {</div>
<div class="line">            validityInterval &amp;= fUVIndicesCache.getValidityInterval();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// do a minimal check for the consistency</span></div>
<div class="line">    check();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (topologyChanged || creaseEdgeChanged || creaseVertexChanged ||</div>
<div class="line">            invisibleFaceChanged || fSubDData.object().isNull()) {</div>
<div class="line">        rebuildSubD();</div>
<div class="line">        setCreaseEdges();</div>
<div class="line">        setCreaseVertices();</div>
<div class="line">        setInvisibleFaces();</div>
<div class="line">        setUVs();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (positionChanged) {</div>
<div class="line">            setPositions();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (uvChanged) {</div>
<div class="line">            setUVs();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isVisible()) {</div>
<div class="line">        convertToPoly();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubDSmoother::check()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keywordtype">size_t</span> numVerts       = fPositionsCache.getValue()-&gt;size() / 3;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// UVs</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numExpectedUVs = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsScope == Alembic::AbcGeom::kVaryingScope ||</div>
<div class="line">            fUVsScope == Alembic::AbcGeom::kVertexScope) {</div>
<div class="line">        numExpectedUVs = numVerts;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fUVsScope == Alembic::AbcGeom::kFacevaryingScope) {</div>
<div class="line">        numExpectedUVs = numFaceIndices;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numActualUVs = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">        <span class="keywordflow">if</span> (fUVIndicesCache.valid()) {</div>
<div class="line">            numActualUVs = fUVIndicesCache.getValue()-&gt;size();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            numActualUVs = fUVsCache.getValue()-&gt;size() / 2;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// clear previous result</span></div>
<div class="line">    fCheckedUVsScope = Alembic::AbcGeom::kUnknownScope;</div>
<div class="line">    fCheckedUVs.reset();</div>
<div class="line">    fCheckedUVIndices.reset();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward </span></div>
<div class="line">    <span class="keywordflow">if</span> (numExpectedUVs == numActualUVs) {</div>
<div class="line">        <span class="keywordflow">if</span> (fUVsCache.valid()) {</div>
<div class="line">            fCheckedUVsScope = fUVsScope;</div>
<div class="line">            fCheckedUVs      = fUVsCache.getValue();</div>
<div class="line">            <span class="keywordflow">if</span> (fUVIndicesCache.valid()) {</div>
<div class="line">                fCheckedUVIndices = fUVIndicesCache.getValue();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        DisplayWarning(kBadUVsMsg);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubDSmoother::rebuildSubD()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numFaceCounts           = fFaceCountsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* faceCounts = fFaceCountsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numFaceIndices                   = fFaceIndicesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numPositions    = fPositionsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* positions = fPositionsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numVertices = numPositions / 3;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Build Maya data structure</span></div>
<div class="line">    <a name="_a34"></a><a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> mayaCounts, mayaConnects;</div>
<div class="line">    mayaCounts.<a name="a35"></a><a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numFaceCounts);</div>
<div class="line">    mayaConnects.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numFaceIndices);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0, polyVertOffset = 0; i &lt; numFaceCounts; i++) {</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceCount = mayaCounts[i] = faceCounts[i];</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; faceCount; j++) {</div>
<div class="line">            <span class="comment">// Alembic&#39;s polygon winding is CW</span></div>
<div class="line">            mayaConnects[polyVertOffset + j] = faceIndices[polyVertOffset + faceCount - j - 1];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        polyVertOffset += faceCount;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    </div>
<div class="line">    <a name="_a36"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point_array.html">MFloatPointArray</a> mayaPositions;</div>
<div class="line">    mayaPositions.<a name="a37"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numVertices);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numVertices; i++) {</div>
<div class="line">        mayaPositions[i] = <a name="_a38"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point.html">MFloatPoint</a>(positions[i * 3 + 0],</div>
<div class="line">                                       positions[i * 3 + 1],</div>
<div class="line">                                       positions[i * 3 + 2]);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create Maya mesh</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> subdData = fSubDData.create(&amp;status);</div>
<div class="line">    assert(status == MS::kSuccess);</div>
<div class="line"></div>
<div class="line">    fSubD.setCheckSamePointTwice(<span class="keyword">false</span>);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> subd = fSubD.create((<span class="keywordtype">int</span>)numVertices, (<span class="keywordtype">int</span>)numFaceCounts,</div>
<div class="line">            mayaPositions, mayaCounts, mayaConnects, subdData, &amp;status);</div>
<div class="line">    <span class="keywordflow">if</span> (status != MS::kSuccess || subd.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>()) {</div>
<div class="line">        fSubDData.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">        fSubD.setObject(<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubDSmoother::setPositions()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (fSubDData.object().isNull()) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numPositions    = fPositionsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* positions = fPositionsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numVertices = numPositions / 3;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set vertex positions only</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_float_point_array.html">MFloatPointArray</a> mayaPositions;</div>
<div class="line">    mayaPositions.<a class="code" href="#!/url=./cpp_ref/class_m_float_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numVertices);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numVertices; i++) {</div>
<div class="line">        mayaPositions[i] = <a class="code" href="#!/url=./cpp_ref/class_m_float_point.html">MFloatPoint</a>(positions[i * 3 + 0],</div>
<div class="line">            positions[i * 3 + 1],</div>
<div class="line">            positions[i * 3 + 2]);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fSubD.setPoints(mayaPositions);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubDSmoother::setCreaseEdges()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (fSubDData.object().isNull() ||</div>
<div class="line">            !fCreaseIndicesCache.valid() ||</div>
<div class="line">            !fCreaseLengthsCache.valid() ||</div>
<div class="line">            !fCreaseSharpnessesCache.valid()) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span>           numCreaseIndices = fCreaseIndicesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* creaseIndices = fCreaseIndicesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>           numCreaseLengths = fCreaseLengthsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* creaseLengths = fCreaseLengthsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>    numCreaseSharpnesses = fCreaseSharpnessesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* creaseSharpnesses = fCreaseSharpnessesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (numCreaseSharpnesses == 0) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare (startVertex, endVertex) =&gt; (edgeId) lookup map</span></div>
<div class="line">    <span class="keyword">typedef</span> std::unordered_map&lt;TEdge,int&gt; EdgeMap;</div>
<div class="line">    EdgeMap edgeMap(<span class="keywordtype">size_t</span>(fSubD.numEdges() / 0.75f));</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> numEdges = fSubD.numEdges();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numEdges; i++) {</div>
<div class="line">        int2 vertexList;</div>
<div class="line">        fSubD.getEdgeVertices(i, vertexList);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (vertexList[0] &gt; vertexList[1]) {</div>
<div class="line">            std::swap(vertexList[0], vertexList[1]);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        edgeMap.insert(std::make_pair(std::make_pair(vertexList[0], vertexList[1]), i));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fill Maya crease edges</span></div>
<div class="line">    <a name="_a39"></a><a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html">MUintArray</a>   mayaEdgeIds;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> mayaCreaseData;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, index = 0; i &lt; numCreaseLengths &amp;&amp; i &lt; numCreaseSharpnesses; i++) {</div>
<div class="line">        <span class="comment">// length should always be 2</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length    = creaseLengths[i];</div>
<div class="line">        <span class="keywordtype">float</span>        sharpness = creaseSharpnesses[i];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (length == 2 &amp;&amp; index + length &lt;= numCreaseIndices) {</div>
<div class="line">            <span class="comment">// find the edge ID from vertex ID</span></div>
<div class="line">            std::pair&lt;int,int&gt; edge = std::make_pair(creaseIndices[index],creaseIndices[index+1]);</div>
<div class="line">            <span class="keywordflow">if</span> (edge.first &gt; edge.second) {</div>
<div class="line">                std::swap(edge.first, edge.second);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            EdgeMap::iterator iter = edgeMap.find(edge);</div>
<div class="line">            <span class="keywordflow">if</span> (iter != edgeMap.end() &amp;&amp; iter-&gt;second &lt; numEdges) {</div>
<div class="line">                <span class="comment">// edge found, store it crease data</span></div>
<div class="line">                mayaEdgeIds.<a name="a40"></a><a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html#a29ccefc020c96f15e099924ebe83eb07">append</a>(iter-&gt;second);</div>
<div class="line">                mayaCreaseData.<a name="a41"></a><a class="code" href="#!/url=./cpp_ref/class_m_double_array.html#aafcfe8ff7afecc2dee4defccbdfb8e55">append</a>(sharpness);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        index += length;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set Maya crease edges</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    status = fSubD.setCreaseEdges(mayaEdgeIds, mayaCreaseData);</div>
<div class="line">    assert(status == MS::kSuccess);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubDSmoother::setCreaseVertices()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (fSubDData.object().isNull() ||</div>
<div class="line">            !fCornerIndicesCache.valid() ||</div>
<div class="line">            !fCornerSharpnessesCache.valid()) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span>           numCornerIndices = fCornerIndicesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* cornerIndices = fCornerIndicesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>    numCornerSharpnesses = fCornerSharpnessesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cornerSharpnesses = fCornerSharpnessesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (cornerSharpnesses == 0) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fill Maya crease vertices</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html">MUintArray</a>   mayaVertexIds;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> mayaCreaseData;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numCreaseVertices = std::min(numCornerIndices, numCornerSharpnesses);</div>
<div class="line">    mayaVertexIds.<a name="a42"></a><a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numCreaseVertices);</div>
<div class="line">    mayaCreaseData.<a name="a43"></a><a class="code" href="#!/url=./cpp_ref/class_m_double_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numCreaseVertices);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numCreaseVertices; i++) {</div>
<div class="line">        mayaVertexIds[i]  = cornerIndices[i];</div>
<div class="line">        mayaCreaseData[i] = cornerSharpnesses[i];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set Maya crease vertices</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    status = fSubD.setCreaseVertices(mayaVertexIds, mayaCreaseData);</div>
<div class="line">    assert(status == MS::kSuccess);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubDSmoother::setInvisibleFaces()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (fSubDData.object().isNull() ||</div>
<div class="line">            !fHolesCache.valid()) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span>           numHoles = fHolesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* holes = fHolesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (numHoles == 0) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fill Maya invisible faces</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html">MUintArray</a> mayaFaceIds(holes, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numHoles);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set Maya invisible faces</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    status = fSubD.setInvisibleFaces(mayaFaceIds);</div>
<div class="line">    assert(status == MS::kSuccess);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubDSmoother::setUVs()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (fSubDData.object().isNull()) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// unsupported scope</span></div>
<div class="line">    <span class="keywordflow">if</span> (fCheckedUVsScope != Alembic::AbcGeom::kVaryingScope &amp;&amp; </div>
<div class="line">            fCheckedUVsScope != Alembic::AbcGeom::kVertexScope &amp;&amp;</div>
<div class="line">            fCheckedUVsScope != Alembic::AbcGeom::kFacevaryingScope) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// no UVs</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fCheckedUVs) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input data</span></div>
<div class="line">    <span class="keywordtype">size_t</span>           numFaceCounts = fFaceCountsCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* faceCounts = fFaceCountsCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>                      numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>    numUVs = fCheckedUVs-&gt;size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* UVs = fCheckedUVs-&gt;get();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> IndexBuffer::index_t* uvIndices = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (fCheckedUVIndices) {</div>
<div class="line">        uvIndices    = fCheckedUVIndices-&gt;get();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Clear Maya UVs if the number of UVs does not equal</span></div>
<div class="line">    <span class="comment">// MFnMesh::setUVs() only allow uv arrays equal or larger than current UV set size</span></div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(numUVs) != fSubD.numUVs()) {</div>
<div class="line">        fSubD.clearUVs();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// no UVs, we are done </span></div>
<div class="line">    <span class="keywordflow">if</span> (numUVs == 0) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fill Maya UVs</span></div>
<div class="line">    <a name="_a44"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> mayaUArray((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numUVs);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> mayaVArray((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numUVs);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numUVs; i++) {</div>
<div class="line">        mayaUArray[i] = UVs[i * 2 + 0];</div>
<div class="line">        mayaVArray[i] = UVs[i * 2 + 1];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fill Maya UV indices</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> mayaUVCounts((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numFaceCounts);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> mayaUVIds((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numFaceIndices);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0, polyVertOffset = 0; i &lt; numFaceCounts; i++) {</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceCount = mayaUVCounts[i] = faceCounts[i];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; faceCount; j++) {</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uvIndex = 0;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Alembic&#39;s polygon winding is CW</span></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertIndex = polyVertOffset + faceCount - j - 1;</div>
<div class="line">            <span class="keywordflow">if</span> (fCheckedUVsScope == Alembic::AbcGeom::kVaryingScope ||</div>
<div class="line">                    fCheckedUVsScope == Alembic::AbcGeom::kVertexScope) {</div>
<div class="line">                <span class="comment">// per-vertex UV</span></div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertIndex = faceIndices[polyVertIndex];</div>
<div class="line">                uvIndex = uvIndices ? uvIndices[vertIndex] : vertIndex;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fCheckedUVsScope == Alembic::AbcGeom::kFacevaryingScope) {</div>
<div class="line">                <span class="comment">// per-face per-vertex UV</span></div>
<div class="line">                uvIndex = uvIndices ? uvIndices[polyVertIndex] : polyVertIndex;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                assert(0);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            mayaUVIds[polyVertOffset + j] = uvIndex;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        polyVertOffset += faceCount;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set Maya UVs and UV indices</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    status = fSubD.setUVs(mayaUArray, mayaVArray);</div>
<div class="line">    assert(status == MS::kSuccess);</div>
<div class="line">    status = fSubD.assignUVs(mayaUVCounts, mayaUVIds);</div>
<div class="line">    assert(status == MS::kSuccess);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubDSmoother::convertToPoly()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (fSubDData.object().isNull() ||</div>
<div class="line">            fSubD.numVertices() == 0 || fSubD.numFaceVertices() == 0) {</div>
<div class="line">        fTriangleIndices.reset();</div>
<div class="line">        fWireIndices.reset();</div>
<div class="line">        fPositions.reset();</div>
<div class="line">        fNormals.reset();</div>
<div class="line">        fUVs.reset();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Smooth the subdivision mesh</span></div>
<div class="line">    <a name="_a45"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh_data.html">MFnMeshData</a> smoothMeshData;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> smoothMeshDataObj = smoothMeshData.<a name="a46"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh_data.html#af1adb4abaf5243c6c0749bcca7b5c418">create</a>();</div>
<div class="line">    </div>
<div class="line">    <a name="_a47"></a><a class="code" href="#!/url=./cpp_ref/class_m_mesh_smooth_options.html">MMeshSmoothOptions</a> smoothOptions;</div>
<div class="line">    smoothOptions.<a name="a48"></a><a class="code" href="#!/url=./cpp_ref/class_m_mesh_smooth_options.html#ae83b35db107d4c6252c7bd7f36b5a723">setDivisions</a>(2);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> smoothMeshObj = fSubD.generateSmoothMesh(smoothMeshDataObj, &amp;smoothOptions);</div>
<div class="line"></div>
<div class="line">    MayaMeshExtractor&lt;IndexBuffer::index_t&gt; extractor(smoothMeshDataObj);</div>
<div class="line">    extractor.setWantUVs(fNeedUVs);</div>
<div class="line">    extractor.compute();</div>
<div class="line"></div>
<div class="line">    fTriangleIndices = extractor.triangleIndices();</div>
<div class="line">    fWireIndices     = extractor.wireIndices();</div>
<div class="line">    fPositions       = extractor.positions();</div>
<div class="line">    fNormals         = extractor.normals();</div>
<div class="line">    fUVs.reset();</div>
<div class="line">    <span class="keywordflow">if</span> (fNeedUVs) {</div>
<div class="line">        fUVs         = extractor.uvs();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheObjectReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">AlembicCacheObjectReader::Ptr</div>
<div class="line">AlembicCacheObjectReader::create(Alembic::Abc::IObject&amp; abcObj, <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">{</div>
<div class="line">    CheckInterruptAndPause(<span class="stringliteral">&quot;reader initialization&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The object type can be mesh or nurbs.</span></div>
<div class="line">    <span class="keywordflow">if</span> (Alembic::AbcGeom::IPolyMesh::matches(abcObj.getHeader()) ||</div>
<div class="line">        Alembic::AbcGeom::INuPatch::matches(abcObj.getHeader()) ||</div>
<div class="line">        Alembic::AbcGeom::ISubD::matches(abcObj.getHeader())) {</div>
<div class="line">        Ptr reader = std::make_shared&lt;AlembicCacheMeshReader&gt;(abcObj, needUVs);</div>
<div class="line">        <span class="keywordflow">return</span> reader-&gt;valid() ? reader : Ptr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// or an xform...</span></div>
<div class="line">    <span class="keywordflow">if</span> (Alembic::AbcGeom::IXform::matches(abcObj.getHeader())) {</div>
<div class="line">        Ptr reader = std::make_shared&lt;AlembicCacheXformReader&gt;(abcObj, needUVs);</div>
<div class="line">        <span class="keywordflow">return</span> reader-&gt;valid() ? reader : Ptr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> Ptr();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AlembicCacheObjectReader::~AlembicCacheObjectReader()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheTopReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">AlembicCacheTopReader::AlembicCacheTopReader(</div>
<div class="line">    Alembic::Abc::IObject abcObj,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs</div>
<div class="line">)</div>
<div class="line"> : fBoundingBoxValidityInterval(TimeInterval::kInvalid)</div>
<div class="line">{</div>
<div class="line">    fXformData = XformData::create();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numChildren = abcObj.getNumChildren();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ii=0; ii&lt;numChildren; ++ii)</div>
<div class="line">    {</div>
<div class="line">        Alembic::Abc::IObject child(abcObj, abcObj.getChildHeader(ii).getName());</div>
<div class="line">        Ptr childReader = create(child, needUVs);</div>
<div class="line">        <span class="keywordflow">if</span> (childReader)</div>
<div class="line">            fChildren.push_back(childReader);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute the exact animation time range</span></div>
<div class="line">    TimeInterval animTimeRange(TimeInterval::kInvalid);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> AlembicCacheObjectReader::Ptr&amp; childReader : fChildren) {</div>
<div class="line">        animTimeRange |= childReader-&gt;getAnimTimeRange();</div>
<div class="line">    }</div>
<div class="line">    fXformData-&gt;setAnimTimeRange(animTimeRange);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AlembicCacheTopReader::~AlembicCacheTopReader()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> AlembicCacheTopReader::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheTopReader::sampleHierarchy(<span class="keywordtype">double</span> seconds, </div>
<div class="line">    <span class="keyword">const</span> <a name="_a49"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; rootMatrix, TimeInterval rootMatrixInterval)</div>
<div class="line">{</div>
<div class="line">    TimeInterval validityInterval(TimeInterval::kInfinite);</div>
<div class="line"></div>
<div class="line">    <a name="_a50"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> bbox;</div>
<div class="line">    TimeInterval bboxValIntrvl(TimeInterval::kInfinite);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> AlembicCacheObjectReader::Ptr&amp; childReader : fChildren) {</div>
<div class="line">        validityInterval &amp;= childReader-&gt;sampleHierarchy(seconds, </div>
<div class="line">                rootMatrix, rootMatrixInterval);</div>
<div class="line"></div>
<div class="line">        bbox.<a name="a51"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">expand</a>(childReader-&gt;getBoundingBox());</div>
<div class="line">        bboxValIntrvl &amp;= childReader-&gt;getBoundingBoxValidityInterval();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The computed validity interval must contain the current time.</span></div>
<div class="line">    assert(validityInterval.contains(seconds));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The current and previous bounding box intervals are either</span></div>
<div class="line">    <span class="comment">// disjoint or equal.</span></div>
<div class="line">    assert(!(fBoundingBoxValidityInterval &amp; bboxValIntrvl).valid() ||</div>
<div class="line">            fBoundingBoxValidityInterval == bboxValIntrvl);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (seconds == bboxValIntrvl.startTime()) {</div>
<div class="line">        fBoundingBox                 = bbox;</div>
<div class="line">        fBoundingBoxValidityInterval = bboxValIntrvl;</div>
<div class="line"></div>
<div class="line">        std::shared_ptr&lt;GPUCache::XformSample&gt; sample =</div>
<div class="line">            GPUCache::XformSample::create(</div>
<div class="line">                seconds,</div>
<div class="line">                <a name="a52"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a9b368179e6c468c7fc4e6b3358ae6f2f">MMatrix::identity</a>,</div>
<div class="line">                fBoundingBox,</div>
<div class="line">                <span class="keyword">true</span></div>
<div class="line">            );</div>
<div class="line">        fXformData-&gt;addSample(sample);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheTopReader::sampleShape(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Top reader has no shape data!</span></div>
<div class="line">    assert(0);</div>
<div class="line">    <span class="keywordflow">return</span> TimeInterval(TimeInterval::kInvalid);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">SubNode::MPtr AlembicCacheTopReader::get()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    SubNode::MPtr node =</div>
<div class="line">        SubNode::create(<a name="_a53"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>), fXformData);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> AlembicCacheObjectReader::Ptr&amp; childReader : fChildren) {</div>
<div class="line">        SubNode::MPtr child = childReader-&gt;get();</div>
<div class="line">        <span class="keywordflow">if</span> (child) </div>
<div class="line">            SubNode::connect(node, child);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (node-&gt;getChildren().empty()) {</div>
<div class="line">        <span class="keywordflow">return</span> SubNode::MPtr();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> node;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> AlembicCacheTopReader::getBoundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fBoundingBox;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheTopReader::getBoundingBoxValidityInterval()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fBoundingBoxValidityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheTopReader::getAnimTimeRange()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fXformData-&gt;animTimeRange();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> AlembicCacheTopReader::saveAndReset(AlembicCacheReader&amp; cacheReader)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// We don&#39;t save xform readers. Just call children&#39;s saveAndReset().</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> AlembicCacheObjectReader::Ptr&amp; childReader : fChildren) {</div>
<div class="line">        childReader-&gt;saveAndReset(cacheReader);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheXformReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">AlembicCacheXformReader::AlembicCacheXformReader(</div>
<div class="line">    Alembic::Abc::IObject abcObj,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs</div>
<div class="line">)</div>
<div class="line">    : fName(abcObj.getName()),</div>
<div class="line">      fValidityInterval(TimeInterval::kInvalid),</div>
<div class="line">      fBoundingBoxValidityInterval(TimeInterval::kInvalid)</div>
<div class="line">{</div>
<div class="line">    Alembic::AbcGeom::IXform xform(abcObj, Alembic::Abc::kWrapExisting);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Xform schema</span></div>
<div class="line">    Alembic::AbcGeom::IXformSchema schema = xform.getSchema();</div>
<div class="line">        </div>
<div class="line">    <span class="comment">// transform</span></div>
<div class="line">    fXformCache.init(schema);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// transform visibility</span></div>
<div class="line">    Alembic::AbcGeom::IVisibilityProperty visibility = </div>
<div class="line">                    Alembic::AbcGeom::GetVisibilityProperty(abcObj);</div>
<div class="line">    <span class="keywordflow">if</span> (visibility) {</div>
<div class="line">        fVisibilityCache.init(visibility);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fXformData = XformData::create();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> numChildren = abcObj.getNumChildren();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ii=0; ii&lt;numChildren; ++ii)</div>
<div class="line">    {</div>
<div class="line">        Alembic::Abc::IObject child(abcObj, abcObj.getChildHeader(ii).getName());</div>
<div class="line">        Ptr childReader = create(child, needUVs);</div>
<div class="line">        <span class="keywordflow">if</span> (childReader)</div>
<div class="line">            fChildren.push_back(childReader);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute the exact animation time range</span></div>
<div class="line">    Alembic::Abc::TimeSamplingPtr timeSampling = schema.getTimeSampling();</div>
<div class="line">    <span class="keywordtype">size_t</span> numSamples = schema.getNumSamples();</div>
<div class="line"></div>
<div class="line">    TimeInterval animTimeRange(</div>
<div class="line">        timeSampling-&gt;getSampleTime(0),</div>
<div class="line">        timeSampling-&gt;getSampleTime(numSamples &gt; 0 ? numSamples-1 : 0) );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> AlembicCacheObjectReader::Ptr&amp; childReader : fChildren) {</div>
<div class="line">        animTimeRange |= childReader-&gt;getAnimTimeRange();</div>
<div class="line">    }</div>
<div class="line">    fXformData-&gt;setAnimTimeRange(animTimeRange);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AlembicCacheXformReader::~AlembicCacheXformReader()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> AlembicCacheXformReader::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fXformCache.valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheXformReader::sampleHierarchy(<span class="keywordtype">double</span> seconds, </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; rootMatrix, TimeInterval rootMatrixInterval)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Fill the sample if this sample has not been read</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fValidityInterval.contains(seconds)) {</div>
<div class="line">        fillTopoAndAttrSample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Inherit transformation</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> newRootMatrix = fXformCache.getValue() * rootMatrix;</div>
<div class="line">    TimeInterval newRootMatrixInterval = </div>
<div class="line">        fXformCache.getValidityInterval() &amp; rootMatrixInterval;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    TimeInterval validityInterval = fValidityInterval;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> bbox;</div>
<div class="line">    TimeInterval bboxValIntrvl(TimeInterval::kInfinite);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> AlembicCacheObjectReader::Ptr&amp; childReader : fChildren) {</div>
<div class="line">        validityInterval &amp;= childReader-&gt;sampleHierarchy(seconds, </div>
<div class="line">            newRootMatrix, newRootMatrixInterval);</div>
<div class="line"></div>
<div class="line">        bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">expand</a>(childReader-&gt;getBoundingBox());</div>
<div class="line">        bboxValIntrvl &amp;= childReader-&gt;getBoundingBoxValidityInterval();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The computed validity interval must contain the current time.</span></div>
<div class="line">    assert(validityInterval.contains(seconds));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The current and previous bounding box intervals are either</span></div>
<div class="line">    <span class="comment">// disjoint or equal.</span></div>
<div class="line">    assert(!(fBoundingBoxValidityInterval &amp; bboxValIntrvl).valid() ||</div>
<div class="line">            fBoundingBoxValidityInterval == bboxValIntrvl);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (seconds == (fValidityInterval &amp; bboxValIntrvl).startTime()) {</div>
<div class="line">        fBoundingBox                 = bbox;</div>
<div class="line">        fBoundingBoxValidityInterval = bboxValIntrvl;</div>
<div class="line"></div>
<div class="line">        std::shared_ptr&lt;GPUCache::XformSample&gt; sample =</div>
<div class="line">            GPUCache::XformSample::create(</div>
<div class="line">                seconds,</div>
<div class="line">                fXformCache.getValue(),</div>
<div class="line">                fBoundingBox,</div>
<div class="line">                isVisible()</div>
<div class="line">            );</div>
<div class="line">        fXformData-&gt;addSample(sample);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheXformReader::sampleShape(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Transform reader has no shape data!</span></div>
<div class="line">    assert(0);</div>
<div class="line">    <span class="keywordflow">return</span> TimeInterval(TimeInterval::kInvalid);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">SubNode::MPtr AlembicCacheXformReader::get()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    SubNode::MPtr node =</div>
<div class="line">        SubNode::create(<a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(fName.c_str()), fXformData);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> AlembicCacheObjectReader::Ptr&amp; childReader : fChildren) {</div>
<div class="line">        SubNode::MPtr child = childReader-&gt;get();</div>
<div class="line">        <span class="keywordflow">if</span> (child) </div>
<div class="line">            SubNode::connect(node, child);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (node-&gt;getChildren().empty()) {</div>
<div class="line">        <span class="keywordflow">return</span> SubNode::MPtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> node;</div>
<div class="line">}</div>
<div class="line">        </div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> AlembicCacheXformReader::fillTopoAndAttrSample(chrono_t time)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Notes:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// When possible, we try to reuse the samples from the previously</span></div>
<div class="line">    <span class="comment">// read sample.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// update caches</span></div>
<div class="line">    fXformCache.setTime(time);</div>
<div class="line">    <span class="keywordflow">if</span> (fVisibilityCache.valid()) {</div>
<div class="line">        fVisibilityCache.setTime(time);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// return the new cache valid interval</span></div>
<div class="line">    TimeInterval validityInterval(TimeInterval::kInfinite);</div>
<div class="line">    validityInterval &amp;= fXformCache.getValidityInterval();</div>
<div class="line">    <span class="keywordflow">if</span> (fVisibilityCache.valid()) {</div>
<div class="line">        validityInterval &amp;= fVisibilityCache.getValidityInterval();</div>
<div class="line">    }</div>
<div class="line">    assert(validityInterval.valid());</div>
<div class="line"></div>
<div class="line">    fValidityInterval = validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> AlembicCacheXformReader::isVisible()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// xform invisible</span></div>
<div class="line">    <span class="keywordflow">if</span> (fVisibilityCache.valid() &amp;&amp; </div>
<div class="line">            fVisibilityCache.getValue() == char(Alembic::AbcGeom::kVisibilityHidden)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// visible</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> AlembicCacheXformReader::getBoundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fBoundingBox;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheXformReader::getBoundingBoxValidityInterval()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fBoundingBoxValidityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheXformReader::getAnimTimeRange()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fXformData-&gt;animTimeRange();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> AlembicCacheXformReader::saveAndReset(AlembicCacheReader&amp; cacheReader)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// We don&#39;t save xform readers. Just call children&#39;s saveAndReset().</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> AlembicCacheObjectReader::Ptr&amp; childReader : fChildren) {</div>
<div class="line">        childReader-&gt;saveAndReset(cacheReader);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheMeshReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">AlembicCacheMeshReader::AlembicCacheMeshReader(</div>
<div class="line">    Alembic::Abc::IObject <span class="keywordtype">object</span>,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs</div>
<div class="line">) </div>
<div class="line">    : fName(object.getName()),</div>
<div class="line">      fFullName(object.getFullName()),</div>
<div class="line">      fBoundingBoxValidityInterval(TimeInterval::kInvalid),</div>
<div class="line">      fNumTransparentSample(0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Shape schema</span></div>
<div class="line">    <span class="keywordflow">if</span> (Alembic::AbcGeom::IPolyMesh::matches(<span class="keywordtype">object</span>.getHeader())) {</div>
<div class="line">        Alembic::AbcGeom::IPolyMesh       meshObj(<span class="keywordtype">object</span>, Alembic::Abc::kWrapExisting);</div>
<div class="line">        Alembic::AbcGeom::IPolyMeshSchema schema = meshObj.getSchema();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// check the existence of wireframe index property</span></div>
<div class="line">        <span class="comment">// if the mesh is written by gpuCache command, the wireframe index property must exist</span></div>
<div class="line">        <span class="keywordflow">if</span> (schema.getPropertyHeader(kCustomPropertyWireIndices) != NULL ||</div>
<div class="line">            schema.getPropertyHeader(kCustomPropertyWireIndicesOld) != NULL) {</div>
<div class="line">            fDataProvider.reset(<span class="keyword">new</span> RawDataProvider(schema, needUVs));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            fDataProvider.reset(<span class="keyword">new</span> Triangulator(schema, needUVs));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Alembic::AbcGeom::INuPatch::matches(<span class="keywordtype">object</span>.getHeader())) {</div>
<div class="line">        Alembic::AbcGeom::INuPatch       nurbsObj(<span class="keywordtype">object</span>, Alembic::Abc::kWrapExisting);</div>
<div class="line">        Alembic::AbcGeom::INuPatchSchema schema = nurbsObj.getSchema();</div>
<div class="line"></div>
<div class="line">        fDataProvider.reset(<span class="keyword">new</span> NurbsTessellator(schema, needUVs));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Alembic::AbcGeom::ISubD::matches(<span class="keywordtype">object</span>.getHeader())) {</div>
<div class="line">        Alembic::AbcGeom::ISubD       subdObj(<span class="keywordtype">object</span>, Alembic::Abc::kWrapExisting);</div>
<div class="line">        Alembic::AbcGeom::ISubDSchema schema = subdObj.getSchema();</div>
<div class="line"></div>
<div class="line">        fDataProvider.reset(<span class="keyword">new</span> SubDSmoother(schema, needUVs));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        DisplayWarning(kUnsupportedGeomMsg);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fShapeData = ShapeData::create();    </div>
<div class="line">    fShapeData-&gt;setAnimTimeRange(fDataProvider-&gt;getAnimTimeRange());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Whole object material assignment</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> material;</div>
<div class="line"></div>
<div class="line">    std::string materialAssignmentPath;</div>
<div class="line">    <span class="keywordflow">if</span> (Alembic::AbcMaterial::getMaterialAssignmentPath(</div>
<div class="line">            <span class="keywordtype">object</span>, materialAssignmentPath)) {</div>
<div class="line">        <span class="comment">// We assume all materials are stored in &quot;/materials&quot;</span></div>
<div class="line">        std::string prefix = <span class="stringliteral">&quot;/&quot;</span>;</div>
<div class="line">        prefix += kMaterialsObject;</div>
<div class="line">        prefix += <span class="stringliteral">&quot;/&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (std::equal(prefix.begin(), prefix.end(), materialAssignmentPath.begin())) {</div>
<div class="line">            std::string objectName = materialAssignmentPath.substr(prefix.size()).c_str();</div>
<div class="line">            <span class="comment">// No material inheritance here.</span></div>
<div class="line">            <span class="keywordflow">if</span> (objectName.find(<span class="stringliteral">&quot;/&quot;</span>) == std::string::npos) {</div>
<div class="line">                material = objectName.c_str();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (material.<a name="a54"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) {</div>
<div class="line">        fShapeData-&gt;setMaterial(material);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AlembicCacheMeshReader::~AlembicCacheMeshReader()</div>
<div class="line">{</div>
<div class="line">    fDataProvider.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> AlembicCacheMeshReader::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fDataProvider &amp;&amp; fDataProvider-&gt;valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheMeshReader::sampleHierarchy(<span class="keywordtype">double</span> seconds, </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; rootMatrix, TimeInterval rootMatrixInterval)</div>
<div class="line">{</div>
<div class="line">    CheckInterruptAndPause(<span class="stringliteral">&quot;sampling hierarchy&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fill the sample if this sample has not been read</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fDataProvider-&gt;getBBoxAndVisValidityInterval().contains(seconds)) {</div>
<div class="line">        <span class="comment">// Read minimal data to construct the hierarchy</span></div>
<div class="line">        fDataProvider-&gt;fillBBoxAndVisSample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TimeInterval validityInterval = fDataProvider-&gt;getBBoxAndVisValidityInterval();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute bounding box in root sub-node axis</span></div>
<div class="line">    fBoundingBox = fDataProvider-&gt;getBoundingBox();</div>
<div class="line">    fBoundingBox.transformUsing(rootMatrix);</div>
<div class="line">    fBoundingBoxValidityInterval = rootMatrixInterval &amp;</div>
<div class="line">        fDataProvider-&gt;getBoundingBoxValidityInterval();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We only add the sample if it is the first sample of the</span></div>
<div class="line">    <span class="comment">// interval.</span></div>
<div class="line">    <span class="keywordflow">if</span> (seconds == validityInterval.startTime()) {</div>
<div class="line">        std::shared_ptr&lt;const ShapeSample&gt; sample = </div>
<div class="line">            fDataProvider-&gt;getBBoxPlaceHolderSample(seconds);</div>
<div class="line">        fShapeData-&gt;addSample(sample);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheMeshReader::sampleShape(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    CheckInterruptAndPause(<span class="stringliteral">&quot;sampling shape&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fill the sample if this sample has not been read</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fDataProvider-&gt;getValidityInterval().contains(seconds)) {</div>
<div class="line">        fDataProvider-&gt;fillTopoAndAttrSample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TimeInterval validityInterval = fDataProvider-&gt;getValidityInterval();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We only add the sample if it is the first sample of the</span></div>
<div class="line">    <span class="comment">// interval.</span></div>
<div class="line">    <span class="keywordflow">if</span> (seconds == validityInterval.startTime()) {</div>
<div class="line">        <span class="keywordflow">if</span> (fDataProvider-&gt;isVisible()) {</div>
<div class="line">            std::shared_ptr&lt;const ShapeSample&gt; sample = </div>
<div class="line">                fDataProvider-&gt;getSample(seconds);</div>
<div class="line">            fShapeData-&gt;addSample(sample);</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">float</span> alpha = sample-&gt;diffuseColor()[3];</div>
<div class="line">            <span class="keywordflow">if</span> (alpha &gt; 0.0f &amp;&amp; alpha &lt; 1.0f) {</div>
<div class="line">                fNumTransparentSample++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// hidden geometry, simply append an empty sample</span></div>
<div class="line">            std::shared_ptr&lt;ShapeSample&gt; sample =</div>
<div class="line">                ShapeSample::createEmptySample(seconds);</div>
<div class="line">            fShapeData-&gt;addSample(sample);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">SubNode::MPtr AlembicCacheMeshReader::get()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">if</span> (fShapeData-&gt;getSamples().size() == 1 &amp;&amp;</div>
<div class="line">        !fShapeData-&gt;getSamples().begin()-&gt;second-&gt;visibility()) {</div>
<div class="line">        <span class="comment">// Prune the node entirely if it is hidden.</span></div>
<div class="line">        <span class="keywordflow">return</span> SubNode::MPtr();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    SubNode::MPtr subNode = SubNode::create(<a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(fName.c_str()), fShapeData);</div>
<div class="line">    <span class="keywordflow">if</span> (fNumTransparentSample == 0) {</div>
<div class="line">        subNode-&gt;setTransparentType(SubNode::kOpaque);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fNumTransparentSample == fShapeData-&gt;getSamples().size()) {</div>
<div class="line">        subNode-&gt;setTransparentType(SubNode::kTransparent);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        subNode-&gt;setTransparentType(SubNode::kOpaqueAndTransparent);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> subNode;</div>
<div class="line">}</div>
<div class="line">        </div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> AlembicCacheMeshReader::getBoundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fBoundingBox;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheMeshReader::getBoundingBoxValidityInterval()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fBoundingBoxValidityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheMeshReader::getAnimTimeRange()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fShapeData-&gt;animTimeRange();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> AlembicCacheMeshReader::saveAndReset(AlembicCacheReader&amp; cacheReader)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Clear the content of this reader for reuse.</span></div>
<div class="line">    fBoundingBox.<a name="a55"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>();</div>
<div class="line">    fBoundingBoxValidityInterval = TimeInterval(TimeInterval::kInvalid);</div>
<div class="line">    fNumTransparentSample = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create a new shape data.</span></div>
<div class="line">    ShapeData::MPtr newShapeData = ShapeData::create();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Animation time range and material assignment won&#39;t change so just copy them.</span></div>
<div class="line">    newShapeData-&gt;setAnimTimeRange(fShapeData-&gt;animTimeRange());</div>
<div class="line">    newShapeData-&gt;setMaterials(fShapeData-&gt;getMaterials());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Release the reference to the old shape data to avoid instability.</span></div>
<div class="line">    fShapeData = newShapeData;</div>
<div class="line"></div>
<div class="line">    Ptr thisPtr = shared_from_this();</div>
<div class="line">    cacheReader.saveReader(fFullName, thisPtr);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheMaterialReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">AlembicCacheMaterialReader::AlembicCacheMaterialReader(Alembic::Abc::IObject abcObj)</div>
<div class="line">    : fName(abcObj.getName()),</div>
<div class="line">      fValidityInterval(TimeInterval::kInvalid)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Wrap with IMaterial</span></div>
<div class="line">    Alembic::AbcMaterial::IMaterial material(abcObj, Alembic::Abc::kWrapExisting);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Material schema</span></div>
<div class="line">    Alembic::AbcMaterial::IMaterialSchema schema = material.getSchema();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create the material graph</span></div>
<div class="line">    fMaterialGraph = std::make_shared&lt;MaterialGraph&gt;(<a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(fName.c_str()));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The number of nodes in the material</span></div>
<div class="line">    <span class="keywordtype">size_t</span> numNetworkNodes = schema.getNumNetworkNodes();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Map: name -&gt; (IMaterialSchema::NetworkNode,MaterialNode)</span></div>
<div class="line">    <span class="keyword">typedef</span> std::pair&lt;Alembic::AbcMaterial::IMaterialSchema::NetworkNode,MaterialNode::MPtr&gt; NodePair;</div>
<div class="line">    <span class="keyword">typedef</span> std::unordered_map&lt;std::string,NodePair&gt; NodeMap;</div>
<div class="line">    NodeMap nodeMap;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read nodes</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numNetworkNodes; i++) {</div>
<div class="line">        Alembic::AbcMaterial::IMaterialSchema::NetworkNode abcNode = schema.getNetworkNode(i);</div>
<div class="line"></div>
<div class="line">        std::string target;</div>
<div class="line">        <span class="keywordflow">if</span> (!abcNode.valid() || !abcNode.getTarget(target) || target != kMaterialsGpuCacheTarget) {</div>
<div class="line">            <span class="keywordflow">continue</span>;  <span class="comment">// Invalid node</span></div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        std::string type;</div>
<div class="line">        <span class="keywordflow">if</span> (!abcNode.getNodeType(type) || type.empty()) {</div>
<div class="line">            <span class="keywordflow">continue</span>;  <span class="comment">// Invalid type</span></div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Node name</span></div>
<div class="line">        std::string name = abcNode.getName();</div>
<div class="line">        assert(!name.empty());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Create material node</span></div>
<div class="line">        MaterialNode::MPtr node = MaterialNode::create(name.c_str(), type.c_str());</div>
<div class="line">        assert(node);</div>
<div class="line"></div>
<div class="line">        fMaterialGraph-&gt;addNode(node);</div>
<div class="line">        nodeMap.insert(std::make_pair(name, std::make_pair(abcNode, node)));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Initialize property caches.</span></div>
<div class="line">    <span class="keywordflow">for</span>(NodeMap::value_type&amp; val : nodeMap) {</div>
<div class="line">        Alembic::AbcMaterial::IMaterialSchema::NetworkNode&amp; abcNode = val.second.first;</div>
<div class="line">        MaterialNode::MPtr&amp; node = val.second.second;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over all child properties</span></div>
<div class="line">        Alembic::Abc::ICompoundProperty compoundProp = abcNode.getParameters();</div>
<div class="line">        <span class="keywordtype">size_t</span> numProps = compoundProp.getNumProperties();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numProps; i++) {</div>
<div class="line">            <span class="keyword">const</span> Alembic::Abc::PropertyHeader&amp; header = compoundProp.getPropertyHeader(i);</div>
<div class="line">            <span class="keyword">const</span> std::string propName = header.getName();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (Alembic::Abc::IBoolProperty::matches(header)) {</div>
<div class="line">                fBoolCaches.push_back(</div>
<div class="line">                    ScalarMaterialProp&lt;Alembic::Abc::IBoolProperty&gt;(compoundProp, propName, node));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Alembic::Abc::IInt32Property::matches(header)) {</div>
<div class="line">                fInt32Caches.push_back(</div>
<div class="line">                    ScalarMaterialProp&lt;Alembic::Abc::IInt32Property&gt;(compoundProp, propName, node));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Alembic::Abc::IFloatProperty::matches(header)) {</div>
<div class="line">                fFloatCaches.push_back(</div>
<div class="line">                    ScalarMaterialProp&lt;Alembic::Abc::IFloatProperty&gt;(compoundProp, propName, node));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Alembic::Abc::IV2fProperty::matches(header)) {</div>
<div class="line">                fFloat2Caches.push_back(</div>
<div class="line">                    ScalarMaterialProp&lt;Alembic::Abc::IV2fProperty&gt;(compoundProp, propName, node));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Alembic::Abc::IV3fProperty::matches(header)) {</div>
<div class="line">                fFloat3Caches.push_back(</div>
<div class="line">                    ScalarMaterialProp&lt;Alembic::Abc::IV3fProperty&gt;(compoundProp, propName, node));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Alembic::Abc::IC3fProperty::matches(header)) {</div>
<div class="line">                fRGBCaches.push_back(</div>
<div class="line">                    ScalarMaterialProp&lt;Alembic::Abc::IC3fProperty&gt;(compoundProp, propName, node));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Alembic::Abc::IWstringProperty::matches(header)) {</div>
<div class="line">                fStringCaches.push_back(</div>
<div class="line">                    ScalarMaterialProp&lt;Alembic::Abc::IWstringProperty&gt;(compoundProp, propName, node));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read connections</span></div>
<div class="line">    <span class="keywordflow">for</span>(NodeMap::value_type&amp; val : nodeMap) {</div>
<div class="line">        Alembic::AbcMaterial::IMaterialSchema::NetworkNode&amp; abcNode = val.second.first;</div>
<div class="line">        MaterialNode::MPtr&amp; node = val.second.second;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over the connections and connect properties</span></div>
<div class="line">        <span class="keywordtype">size_t</span> numConnections = abcNode.getNumConnections();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numConnections; i++) {</div>
<div class="line">            std::string inputName, connectedNodeName, connectedOutputName;</div>
<div class="line">            abcNode.getConnection(i, inputName, connectedNodeName, connectedOutputName);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Find destination property</span></div>
<div class="line">            MaterialProperty::MPtr prop = node-&gt;findProperty(inputName.c_str());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Find source node</span></div>
<div class="line">            MaterialNode::MPtr srcNode;</div>
<div class="line">            NodeMap::iterator it = nodeMap.find(connectedNodeName);</div>
<div class="line">            <span class="keywordflow">if</span> (it != nodeMap.end()) {</div>
<div class="line">                srcNode = (*it).second.second;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Find source property</span></div>
<div class="line">            MaterialProperty::MPtr srcProp;</div>
<div class="line">            <span class="keywordflow">if</span> (srcNode) {</div>
<div class="line">                srcProp = srcNode-&gt;findProperty(connectedOutputName.c_str());</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Make the connection</span></div>
<div class="line">            <span class="keywordflow">if</span> (prop &amp;&amp; srcNode &amp;&amp; srcProp) {</div>
<div class="line">                prop-&gt;connect(srcNode, srcProp);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read Terminal node (ignore output)</span></div>
<div class="line">    std::string rootNodeName, rootOutput;</div>
<div class="line">    <span class="keywordflow">if</span> (schema.getNetworkTerminal(kMaterialsGpuCacheTarget, kMaterialsGpuCacheType, rootNodeName, rootOutput)) {</div>
<div class="line">        NodeMap::iterator it = nodeMap.find(rootNodeName);</div>
<div class="line">        <span class="keywordflow">if</span> (it != nodeMap.end()) {</div>
<div class="line">            fMaterialGraph-&gt;setRootNode((*it).second.second);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AlembicCacheMaterialReader::~AlembicCacheMaterialReader()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">TimeInterval AlembicCacheMaterialReader::sampleMaterial(<span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    TimeInterval validityInterval(TimeInterval::kInfinite);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(ScalarMaterialProp&lt;Alembic::Abc::IBoolProperty&gt;&amp; cache : fBoolCaches) {</div>
<div class="line">        validityInterval &amp;= cache.sample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(ScalarMaterialProp&lt;Alembic::Abc::IInt32Property&gt;&amp; cache : fInt32Caches) {</div>
<div class="line">        validityInterval &amp;= cache.sample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(ScalarMaterialProp&lt;Alembic::Abc::IFloatProperty&gt;&amp; cache : fFloatCaches) {</div>
<div class="line">        validityInterval &amp;= cache.sample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(ScalarMaterialProp&lt;Alembic::Abc::IV2fProperty&gt;&amp; cache : fFloat2Caches) {</div>
<div class="line">        validityInterval &amp;= cache.sample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(ScalarMaterialProp&lt;Alembic::Abc::IV3fProperty&gt;&amp; cache : fFloat3Caches) {</div>
<div class="line">        validityInterval &amp;= cache.sample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(ScalarMaterialProp&lt;Alembic::Abc::IC3fProperty&gt;&amp; cache : fRGBCaches) {</div>
<div class="line">        validityInterval &amp;= cache.sample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(ScalarMaterialProp&lt;Alembic::Abc::IWstringProperty&gt;&amp; cache : fStringCaches) {</div>
<div class="line">        validityInterval &amp;= cache.sample(seconds);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">MaterialGraph::MPtr AlembicCacheMaterialReader::get()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Check invalid graph.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fMaterialGraph || !fMaterialGraph-&gt;rootNode() || fMaterialGraph-&gt;getNodes().empty()) {</div>
<div class="line">        <span class="keywordflow">return</span> MaterialGraph::MPtr();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> fMaterialGraph;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace CacheReaderAlembicPrivate</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>AlembicCacheReader::MakeSharedEnabler: <span class="keyword">public</span> AlembicCacheReader</div>
<div class="line">{</div>
<div class="line">    MakeSharedEnabler(<span class="keyword">const</span> <a name="_a56"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file): AlembicCacheReader(file){}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;CacheReader&gt; AlembicCacheReader::create(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;MakeSharedEnabler&gt;(file);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AlembicCacheReader::AlembicCacheReader(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">    : fFile(file)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Open the archive for reading.</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> resolvedFullName = file.<a name="a57"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">resolvedFullName</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; alembicLock(gsAlembicMutex);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (resolvedFullName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() != 0 &amp;&amp; std::ifstream(resolvedFullName.<a name="a58"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>()).good()) {</div>
<div class="line">            Alembic::AbcCoreFactory::IFactory factory;</div>
<div class="line">            <span class="comment">// Disable Alembic caching as we have implemented our own</span></div>
<div class="line">            <span class="comment">// caching...</span></div>
<div class="line">            factory.setSampleCache( Alembic::AbcCoreAbstract::ReadArraySampleCachePtr());</div>
<div class="line">            factory.setPolicy(Alembic::Abc::ErrorHandler::kThrowPolicy);</div>
<div class="line">            fAbcArchive = factory.getArchive(resolvedFullName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// File exists but Alembic fails to open.</span></div>
<div class="line">            <span class="keywordflow">if</span> (!fAbcArchive.valid()) {</div>
<div class="line">                DisplayError(kFileFormatWrongMsg, file.<a name="a59"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a2f505a3eabc9709fad04e2a14d960614">rawFullName</a>());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// File doesn&#39;t exist.</span></div>
<div class="line">            DisplayError(kFileDoesntExistMsg, file.<a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a2f505a3eabc9709fad04e2a14d960614">rawFullName</a>());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (CacheReaderInterruptException&amp; ex) {</div>
<div class="line">        <span class="comment">// pass upward</span></div>
<div class="line">        <span class="keywordflow">throw</span> ex;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception&amp; ex) {</div>
<div class="line">        <span class="comment">//The resolved full name will be empty if the resolution fails.</span></div>
<div class="line">        <span class="comment">//Print the raw full name in case of this situation.</span></div>
<div class="line">        DisplayError(kCacheOpenFileErrorMsg, file.<a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a2f505a3eabc9709fad04e2a14d960614">rawFullName</a>(), ex.what());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AlembicCacheReader::~AlembicCacheReader()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; alembicLock(gsAlembicMutex);</div>
<div class="line">        fAbcArchive.reset();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception&amp; ex) {</div>
<div class="line">        DisplayError(kCloseFileErrorMsg, fFile.resolvedFullName(), ex.what());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> AlembicCacheReader::valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    std::lock_guard&lt;std::mutex&gt; alembicLock(gsAlembicMutex);</div>
<div class="line">    <span class="keywordflow">return</span> fAbcArchive.valid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> AlembicCacheReader::validateGeomPath(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; validatedGeomPath)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">if</span> (!valid()) {</div>
<div class="line">        validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; alembicLock(gsAlembicMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// path: |xform1|xform2|meshShape</span></div>
<div class="line">        <a name="_a60"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> pathArray;</div>
<div class="line">        geomPath.<a name="a61"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(<span class="charliteral">&#39;|&#39;</span>, pathArray);</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> valid = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// find the mesh in Alembic archive</span></div>
<div class="line">        validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>();</div>
<div class="line">        Alembic::Abc::IObject current = fAbcArchive.getTop();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; pathArray.<a name="a62"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++) {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> step = pathArray[i];</div>
<div class="line">            current = current.getChild(step.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line">            <span class="keywordflow">if</span> (!current.valid()) {</div>
<div class="line">                valid = <span class="keyword">false</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            validatedGeomPath += <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">            validatedGeomPath += step;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (validatedGeomPath.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0) {</div>
<div class="line">            validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">        <span class="keywordflow">return</span> valid;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (CacheReaderInterruptException&amp; ex) {</div>
<div class="line">        <span class="comment">// pass upward</span></div>
<div class="line">        <span class="keywordflow">throw</span> ex;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception&amp; ex) {</div>
<div class="line">        DisplayError(kReadMeshErrorMsg, fFile.resolvedFullName(), geomPath, ex.what());</div>
<div class="line"></div>
<div class="line">        validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">SubNode::Ptr AlembicCacheReader::readScene(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Read sub-node hierarchy</span></div>
<div class="line">    SubNode::Ptr top = readHierarchy(geomPath, needUVs);</div>
<div class="line">    <span class="keywordflow">if</span> (!top) <span class="keywordflow">return</span> SubNode::Ptr();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Extract shape paths</span></div>
<div class="line">    ShapePathVisitor::ShapePathAndSubNodeList shapeGeomPaths;</div>
<div class="line">    ShapePathVisitor shapePathVisitor(shapeGeomPaths);</div>
<div class="line">    top-&gt;accept(shapePathVisitor);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The absolute shape path in the archive is prefix+shapePath</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> prefix;</div>
<div class="line">    <span class="keywordtype">int</span> lastStep = geomPath.<a name="a63"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a8b323761724ea9659348e33b0fea356b">rindexW</a>(<span class="charliteral">&#39;|&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (lastStep &gt; 0) {</div>
<div class="line">        prefix = geomPath.<a name="a64"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#ad748626e545fa6db3afc2f61644b5d62">substringW</a>(0, lastStep - 1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read shapes</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> ShapePathVisitor::ShapePathAndSubNode&amp; pair : shapeGeomPaths) {</div>
<div class="line">        SubNode::Ptr shape = readShape(prefix + pair.first, needUVs);</div>
<div class="line">        <span class="keywordflow">if</span> (shape &amp;&amp; pair.first.length() &gt; 0) {</div>
<div class="line">            ReplaceSubNodeData(top, shape, pair.first);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update transparent type</span></div>
<div class="line">    SubNodeTransparentTypeVisitor transparentTypeVisitor;</div>
<div class="line">    top-&gt;accept(transparentTypeVisitor);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> top;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">SubNode::Ptr AlembicCacheReader::readHierarchy(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>CacheReaderAlembicPrivate;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!valid()) <span class="keywordflow">return</span> SubNode::Ptr();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; alembicLock(gsAlembicMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// path: |xform1|xform2|meshShape</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> pathArray;</div>
<div class="line">        geomPath.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(<span class="charliteral">&#39;|&#39;</span>, pathArray);</div>
<div class="line"></div>
<div class="line">        Alembic::Abc::IObject current = fAbcArchive.getTop();</div>
<div class="line">        AlembicCacheObjectReader::Ptr reader;</div>
<div class="line">        <span class="keywordflow">if</span> (pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0) {</div>
<div class="line">            <span class="comment">// Determine the number of children under the top level object.</span></div>
<div class="line">            <span class="comment">// We skip objects that we don&#39;t recognize. (Cameras, Materials, ..)</span></div>
<div class="line">            <span class="keywordtype">size_t</span> numChildren = 0;</div>
<div class="line">            <span class="keywordtype">size_t</span> lastChild   = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; current.getNumChildren(); i++) {</div>
<div class="line">                <span class="keywordflow">if</span> (Alembic::AbcGeom::IPolyMesh::matches(current.getChildHeader(i)) ||</div>
<div class="line">                    Alembic::AbcGeom::INuPatch::matches(current.getChildHeader(i)) ||</div>
<div class="line">                    Alembic::AbcGeom::ISubD::matches(current.getChildHeader(i)) ||</div>
<div class="line">                    Alembic::AbcGeom::IXform::matches(current.getChildHeader(i))) {</div>
<div class="line">                        numChildren++;</div>
<div class="line">                        lastChild = i;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (numChildren == 1) {</div>
<div class="line">                current = Alembic::Abc::IObject(</div>
<div class="line">                    current, current.getChildHeader(lastChild).getName());</div>
<div class="line">                <span class="keywordflow">if</span> (current.valid())</div>
<div class="line">                    reader = AlembicCacheObjectReader::create(</div>
<div class="line">                    current, needUVs);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numChildren &gt; 1) {</div>
<div class="line">                <span class="comment">// The top level object is not a proper xform object. We</span></div>
<div class="line">                <span class="comment">// therefore have to create a dummy top-level transform in</span></div>
<div class="line">                <span class="comment">// that case.</span></div>
<div class="line">                reader = std::make_shared&lt;AlembicCacheTopReader&gt;(</div>
<div class="line">                    current, needUVs);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// find the top level node in the Alembic archive</span></div>
<div class="line">            <span class="keywordtype">bool</span> geometryFound = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++) {</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> step = pathArray[i];</div>
<div class="line">                current = current.getChild(step.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line">                <span class="keywordflow">if</span> (!current.valid()) {</div>
<div class="line">                    geometryFound = <span class="keyword">false</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (geometryFound)</div>
<div class="line">                reader = AlembicCacheObjectReader::create(current, needUVs);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!reader || !reader-&gt;valid()) <span class="keywordflow">return</span> SubNode::Ptr();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Each time samplings only records the start time, i.e. there</span></div>
<div class="line">        <span class="comment">// is no way to ask for the end time of a TimeSampling!</span></div>
<div class="line">        <span class="comment">// Therefore, to determine the end of the animation, we simply</span></div>
<div class="line">        <span class="comment">// loop until time no longer advances...</span></div>
<div class="line">        {</div>
<div class="line">            TimeInterval interval = reader-&gt;sampleHierarchy(</div>
<div class="line">                -std::numeric_limits&lt;double&gt;::max(),</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a9b368179e6c468c7fc4e6b3358ae6f2f">MMatrix::identity</a>, TimeInterval::kInfinite);</div>
<div class="line">            <span class="keywordflow">while</span> (interval.endTime() != std::numeric_limits&lt;double&gt;::max()) {</div>
<div class="line">                interval = reader-&gt;sampleHierarchy(</div>
<div class="line">                    interval.endTime(), </div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a9b368179e6c468c7fc4e6b3358ae6f2f">MMatrix::identity</a>, TimeInterval::kInfinite);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The sub-node hierarchy with bounding box place holders.</span></div>
<div class="line">        SubNode::Ptr top = reader-&gt;get();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Save the object readers for reuse.</span></div>
<div class="line">        reader-&gt;saveAndReset(*<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> top;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (CacheReaderInterruptException&amp; ex) {</div>
<div class="line">        <span class="comment">// pass upward</span></div>
<div class="line">        <span class="keywordflow">throw</span> ex;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception&amp; ex) {</div>
<div class="line">        DisplayError(kReadMeshErrorMsg, fFile.resolvedFullName(), geomPath, ex.what());</div>
<div class="line">        <span class="keywordflow">return</span> SubNode::Ptr();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">SubNode::Ptr AlembicCacheReader::readShape(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>CacheReaderAlembicPrivate;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!valid()) <span class="keywordflow">return</span> SubNode::Ptr();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; alembicLock(gsAlembicMutex);</div>
<div class="line"></div>
<div class="line">        AlembicCacheObjectReader::Ptr reader;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Search saved readers</span></div>
<div class="line">        ObjectReaderMap::iterator iter = fSavedReaders.find(geomPath.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line">        <span class="keywordflow">if</span> (iter != fSavedReaders.end()) {</div>
<div class="line">            reader = (*iter).second;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// path: |xform1|xform2|meshShape</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> pathArray;</div>
<div class="line">            geomPath.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(<span class="charliteral">&#39;|&#39;</span>, pathArray);</div>
<div class="line"></div>
<div class="line">            Alembic::Abc::IObject current = fAbcArchive.getTop();</div>
<div class="line">            <span class="keywordflow">if</span> (pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) {</div>
<div class="line">                <span class="comment">// Find the shape in the Alembic archive</span></div>
<div class="line">                <span class="keywordtype">bool</span> geometryFound = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++) {</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> step = pathArray[i];</div>
<div class="line">                    current = current.getChild(step.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line">                    <span class="keywordflow">if</span> (!current.valid()) {</div>
<div class="line">                        geometryFound = <span class="keyword">false</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (geometryFound) {</div>
<div class="line">                    reader = AlembicCacheObjectReader::create(current, needUVs);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!reader || !reader-&gt;valid()) <span class="keywordflow">return</span> SubNode::Ptr();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Each time samplings only records the start time, i.e. there</span></div>
<div class="line">        <span class="comment">// is no way to ask for the end time of a TimeSampling!</span></div>
<div class="line">        <span class="comment">// Therefore, to determine the end of the animation, we simply</span></div>
<div class="line">        <span class="comment">// loop until time no longer advances...</span></div>
<div class="line">        {</div>
<div class="line">            TimeInterval interval = reader-&gt;sampleShape(</div>
<div class="line">                -std::numeric_limits&lt;double&gt;::max());</div>
<div class="line">            <span class="keywordflow">while</span> (interval.endTime() != std::numeric_limits&lt;double&gt;::max()) {</div>
<div class="line">                interval = reader-&gt;sampleShape(</div>
<div class="line">                    interval.endTime());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The sub-node with mesh shape data.</span></div>
<div class="line">        SubNode::Ptr top = reader-&gt;get();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Save the object readers for reuse.</span></div>
<div class="line">        reader-&gt;saveAndReset(*<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> top;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (CacheReaderInterruptException&amp; ex) {</div>
<div class="line">        <span class="comment">// pass upward</span></div>
<div class="line">        <span class="keywordflow">throw</span> ex;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception&amp; ex) {</div>
<div class="line">        DisplayError(kReadMeshErrorMsg, fFile.resolvedFullName(), geomPath, ex.what());</div>
<div class="line">        <span class="keywordflow">return</span> SubNode::Ptr();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">MaterialGraphMap::Ptr AlembicCacheReader::readMaterials()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>CacheReaderAlembicPrivate;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!valid()) <span class="keywordflow">return</span> MaterialGraphMap::Ptr();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; alembicLock(gsAlembicMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Find &quot;/materials&quot;</span></div>
<div class="line">        Alembic::Abc::IObject topObject = fAbcArchive.getTop();</div>
<div class="line">        Alembic::Abc::IObject materialsObject = topObject.getChild(kMaterialsObject);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// &quot;/materials&quot; doesn&#39;t exist!</span></div>
<div class="line">        <span class="keywordflow">if</span> (!materialsObject.valid()) {</div>
<div class="line">            <span class="keywordflow">return</span> MaterialGraphMap::Ptr();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        MaterialGraphMap::MPtr materials = std::make_shared&lt;MaterialGraphMap&gt;();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Read materials one by one. Hierarchical materials are not supported.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; materialsObject.getNumChildren(); i++) {</div>
<div class="line">            Alembic::Abc::IObject <span class="keywordtype">object</span> = materialsObject.getChild(i);</div>
<div class="line">            <span class="keywordflow">if</span> (Alembic::AbcMaterial::IMaterial::matches(<span class="keywordtype">object</span>.getHeader())) {</div>
<div class="line">                AlembicCacheMaterialReader reader(<span class="keywordtype">object</span>);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Read the material</span></div>
<div class="line">                TimeInterval interval = reader.sampleMaterial(</div>
<div class="line">                    -std::numeric_limits&lt;double&gt;::max());</div>
<div class="line">                <span class="keywordflow">while</span> (interval.endTime() != std::numeric_limits&lt;double&gt;::max()) {</div>
<div class="line">                    interval = reader.sampleMaterial(interval.endTime());</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                MaterialGraph::MPtr graph = reader.get();</div>
<div class="line">                <span class="keywordflow">if</span> (graph) {</div>
<div class="line">                    materials-&gt;addMaterialGraph(graph);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// No materials..</span></div>
<div class="line">        <span class="keywordflow">if</span> (materials-&gt;getGraphs().empty()) {</div>
<div class="line">            <span class="keywordflow">return</span> MaterialGraphMap::Ptr();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> materials;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (CacheReaderInterruptException&amp; ex) {</div>
<div class="line">        <span class="comment">// pass upward</span></div>
<div class="line">        <span class="keywordflow">throw</span> ex;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception&amp; ex) {</div>
<div class="line">        DisplayError(kReadFileErrorMsg, fFile.resolvedFullName(), ex.what());</div>
<div class="line">        <span class="keywordflow">return</span> MaterialGraphMap::Ptr();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> AlembicCacheReader::readAnimTimeRange(GPUCache::TimeInterval&amp; range)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!valid()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; alembicLock(gsAlembicMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Try *.samples property.</span></div>
<div class="line">        <span class="keywordtype">double</span> samplesMin = std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line">        <span class="keywordtype">double</span> samplesMax = -std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTimeSamplings = fAbcArchive.getNumTimeSamplings();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numTimeSamplings; i++) {</div>
<div class="line">            <span class="comment">// *.samples property</span></div>
<div class="line">            std::stringstream propName;</div>
<div class="line">            propName &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;.samples&quot;</span>;</div>
<div class="line">            Alembic::Abc::IUInt32Property samplesProp(</div>
<div class="line">                fAbcArchive.getTop().getProperties(), </div>
<div class="line">                propName.str(),</div>
<div class="line">                Alembic::Abc::ErrorHandler::kQuietNoopPolicy</div>
<div class="line">            );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The time sampling.</span></div>
<div class="line">            Alembic::Abc::TimeSamplingPtr timeSampling = fAbcArchive.getTimeSampling(i);</div>
<div class="line">            <span class="keywordflow">if</span> (samplesProp &amp;&amp; timeSampling) {</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numSamples = 0;</div>
<div class="line">                samplesProp.get(numSamples);</div>
<div class="line">                <span class="keywordflow">if</span> (numSamples &gt; 0) {</div>
<div class="line">                    samplesMin = std::min(samplesMin, timeSampling-&gt;getSampleTime(0));</div>
<div class="line">                    samplesMax = std::max(samplesMax, timeSampling-&gt;getSampleTime(numSamples - 1));</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Successfully read *.samples property.</span></div>
<div class="line">        <span class="keywordflow">if</span> (samplesMin &lt;= samplesMax) {</div>
<div class="line">            range = TimeInterval(samplesMin, samplesMax);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Try archive bounds property.</span></div>
<div class="line">        Alembic::Abc::IBox3dProperty boxProp = Alembic::AbcGeom::GetIArchiveBounds(</div>
<div class="line">            fAbcArchive, Alembic::Abc::ErrorHandler::kQuietNoopPolicy);</div>
<div class="line">        <span class="keywordflow">if</span> (boxProp) {</div>
<div class="line">            <span class="comment">// The time range of the archive bounds property.</span></div>
<div class="line">            <span class="keywordtype">size_t</span> numSamples                          = boxProp.getNumSamples();</div>
<div class="line">            Alembic::Abc::TimeSamplingPtr timeSampling = boxProp.getTimeSampling();</div>
<div class="line">            <span class="keywordflow">if</span> (numSamples &gt; 0 &amp;&amp; timeSampling) {</div>
<div class="line">                range = TimeInterval(</div>
<div class="line">                    timeSampling-&gt;getSampleTime(0),</div>
<div class="line">                    timeSampling-&gt;getSampleTime(numSamples - 1)</div>
<div class="line">                );</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// No enough animation range info on the archive.</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (CacheReaderInterruptException&amp; ex) {</div>
<div class="line">        <span class="comment">// pass upward</span></div>
<div class="line">        <span class="keywordflow">throw</span> ex;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception&amp; ex) {</div>
<div class="line">        DisplayError(kReadFileErrorMsg, fFile.resolvedFullName(), ex.what());</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> AlembicCacheReader::saveReader(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; fullName,</div>
<div class="line">    CacheReaderAlembicPrivate::AlembicCacheObjectReader::Ptr&amp; reader</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// We save the object reader in this AlembicCacheReader so that </span></div>
<div class="line">    <span class="comment">// the object reader won&#39;t be destroyed after readHierarchy() or readShape().</span></div>
<div class="line">    <span class="comment">// The life time of the object reader would be the same as this AlembicCacheReader.</span></div>
<div class="line">    <span class="comment">// The object reader can be reused as long as the Alembic archive is not closed.</span></div>
<div class="line">    <span class="comment">// There are 2 situations that will cause an Alembic archive to be closed:</span></div>
<div class="line">    <span class="comment">//   1) There are no references to CacheReaderProxy. (Read complete)</span></div>
<div class="line">    <span class="comment">//   2) Maya is running out of file handles. (Temporarily close some inactive archives)</span></div>
<div class="line">    <span class="keywordflow">if</span> (reader &amp;&amp; reader-&gt;valid()) {</div>
<div class="line">        std::string geometryPath = fullName;</div>
<div class="line">        std::replace(geometryPath.begin(), geometryPath.end(), <span class="charliteral">&#39;/&#39;</span>, <span class="charliteral">&#39;|&#39;</span>);</div>
<div class="line">        fSavedReaders.insert(std::make_pair(geometryPath, reader));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace GPUCache</span></div>
<div class="line"></div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
