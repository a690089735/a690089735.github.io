<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
      <title>ufe: UFE Concepts and Architecture</title>
      
	  
      
      
      
      
      
      
      
    

</head>
   <body height="100%"><div class="body_content" id="body-content"><style>div.image img[src="sequenceDiagram.png"]{width:1200px;}</style><link rel="stylesheet" type="text/css" href="ufe_ref/navtree.css"><link rel="stylesheet" type="text/css" href="ufe_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="ufe_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(ufe_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'ufe_ref/'; }
function ufe_ref_initializeToc(forceTrigger) {
    ufe_ref_adsk_ref_toc.initResizable();
    ufe_ref_adsk_ref_toc.initNavTree('ufe_philosophy.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(ufe_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = ufe_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$(document).ready(function() { yepnope.injectJs("./ufe_ref/menudata.js"); });</script><script>$(document).ready(function() { yepnope.injectJs("./ufe_ref/menu.js"); });</script><script>
 if (!tocSystemNeedsToBeLoaded) { ufe_ref_initializeToc(); }
 </script>
      <div>
         <div class="head">
            <h1>ufe: UFE Concepts and Architecture</h1>
         </div>

<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->




<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<!-- window showing the filter options -->


<!-- iframe showing the search results (closed by default) -->


<div class="header">
  <div class="headertitle">
<div class="title">UFE Concepts and Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="ufe_philosophy.html#fundamentals">Fundamental Concepts</a></li>
<li class="level1"><a href="ufe_philosophy.html#architecture">Architecture</a></li>
<li class="level1"><a href="ufe_philosophy.html#implementation">Implementation</a></li>
<li class="level1"><a href="ufe_philosophy.html#runTimeInterfaces">Runtime Interfaces</a></li>
<li class="level1"><a href="ufe_philosophy.html#notifications">Notifications</a></li>
<li class="level1"><a href="ufe_philosophy.html#selection">Selection</a></li>
<li class="level1"><a href="ufe_philosophy.html#globalSelection">Global Selection</a></li>
<li class="level1"><a href="ufe_philosophy.html#undoRedo">Undo / Redo</a></li>
<li class="level1"><a href="ufe_philosophy.html#pathString">Path Strings</a></li>
<li class="level1"><a href="ufe_philosophy.html#versioning">Versioning</a></li>
</ul>
</div>
<div class="textblock"><p>The design goal of the UFE project is to develop an independent component that allows a Digital Content Creation (DCC) application to operate on objects from different plug-in runtimes.</p>
<p>An example is to allow Maya to view and edit objects not just from its native DG (Dependency Graph), but also from plug-in runtimes such as Bifrost and USD. </p>
<h1><a class="anchor" id="fundamentals"></a>
Fundamental Concepts</h1>
<ul>
<li>UFE works on <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene_item.html">scene items</a>: a scene item is a <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path.html">path</a> in the scene and the associated runtime object it represents.</li>
<li>UFE is interface-based: given a scene item, we can try to create an interface from it. Interfaces provide semantics to a scene item. UFE interfaces are:<ul>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_hierarchy.html">hierarchy interface</a>, to navigate the scene hierarchy.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene_item_ops.html">scene item operations interface</a>, to operate on an individual scene item.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_transform3d.html">3D transform interface</a>, to view and edit the 3D transformation of a scene item.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_attributes.html">attributes interface</a>, to list, read from and write to a scene item's attributes.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_object3d.html">3D object interface</a>, to read a 3D object's properties such as bounding box and visibility.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_context_ops.html">context operations interface</a>, to provide contextual operations on a selected scene item. These operations are typically presented in a contextual menu available on right click.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_camera.html">camera interface</a>, to view and edit camera-specific parameters of a scene item. If a scene item does not support a given interface, the resulting interface object will be null.</li>
</ul>
</li>
<li>UFE is DCC-independent: the UFE component is standalone. A DCC application links against UFE. As such, UFE supports, but does not implement, application-centric services like undo / redo, which must be provided by the DCC app using UFE services.</li>
<li><p class="startli">A UFE-enabled DCC creates UFE interface objects on UFE scene items, then calls methods on the interface object.</p>
<p class="startli">Maya API programmers will see a clear analog with MFn function sets, which are interfaces on underlying objects.</p>
</li>
<li>The implementation of the interface is provided by a plug-in to the DCC. The plug-in registers its UFE implementation to the <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_run_time_mgr.html">Ufe::RunTimeMgr</a> , on startup.</li>
</ul>
<h1><a class="anchor" id="architecture"></a>
Architecture</h1>
<p>UFE <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene_item.html">scene items</a> are represented as a <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path.html">path</a> through the scene graph, and the path is component of one or more <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path_segment.html">path segments</a>. Each path segment corresponds to a single runtime. Each path segment is composed of one or more <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path_component.html">path components</a>.</p>
<ul>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene_item.html">Ufe::SceneItem</a> : describes a runtime object. In the base class, a scene item stores a path. Scene items must be implemented as derived classes by runtimes. <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_selection.html">Ufe::Selection</a> and interfaces work with scene items.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path.html">Ufe::Path</a> : names objects in a hierarchical way. Composed of <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path_segment.html">path segments</a>. Each path segment is in a single runtime. Viewed as a list of <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path_component.html">path components</a>.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path_segment.html">Ufe::PathSegment</a> : that part of a UFE path that lies within a single runtime. A list of <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path_component.html">path components</a>.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path_component.html">Ufe::PathComponent</a> : describes the name of an object in the scene graph.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_selection.html">Ufe::Selection</a> : an ordered list of <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene_item.html">scene items</a> that allows for O(m) retrieval of a selection item, given a path of m components. The UFE selection has a hierarchical acceleration structure for fast path-based querying.</li>
<li><a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene.html">Ufe::Scene</a> : a singleton that is a conceptual "container" of all scene items. It provides notification services when items are added or removed.</li>
</ul>
<p>UFE interfaces are bound to UFE <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene_item.html">scene items</a>, one scene item at a time. The expected usage of a UFE interface object is to create one, bind it to a scene item, then operate on the scene item through the interface until the operation is complete. The UFE interface can then be discarded, or bound onto another scene item. This avoids the memory-consuming "one proxy object per scene object" approach.</p>
<p>A scene item may optionally represent a property associated with a given scene object. A property represents data associated with a single node or object. In different runtimes, it is variously known as an attribute, a component, or an underworld path, but is always associated with a single node or object. At time of writing (24-Apr-2018), UFE only supports querying the existence of such data on a scene item, using <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene_item.html#a9286c3d8a3c9e306806bc3d71452767a">Ufe::SceneItem::isProperty()</a> .</p>
<h1><a class="anchor" id="implementation"></a>
Implementation</h1>
<p>The UFE standalone component defines interfaces that DCC plug-in runtimes must implement. When the DCC plug-in runtime loads into the DCC, it registers its implementation of the UFE interfaces with the UFE runtime manager. From that point on, the UFE runtime manager will know how to create interface objects for that runtime.</p>
<ul>
<li>UFE object lifescope: managed through shared pointers. This also makes Python bindings easier, as Python also uses reference counting to manage lifescope.</li>
<li>UFE implementation: in C++. UFE provides source code compatibility only, and requires that the UFE component and all components that depend on it (the DCC, the DCC runtime plug-ins) be compiled with the same C++ runtime and compilation options. Non binary-compatible changes in UFE require recompilation of the DCC and its runtime plug-ins. In practice, this is already a DCC requirement, at each major version.</li>
<li>UFE provides no thread safeness.</li>
<li>UFE scene singleton: provided by the DCC application, at initialization time, using <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene.html#a9ce94d76ba9a32fd6a6830a0357e117f">Ufe::Scene::initializeInstance()</a> . This allows the DCC to implement scene hooks defined in the <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene.html">Ufe::Scene</a> base class, e.g. to refresh its user interface. There is no Python bindings for <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene.html#a9ce94d76ba9a32fd6a6830a0357e117f">Ufe::Scene::initializeInstance()</a> .</li>
</ul>
<h1><a class="anchor" id="runTimeInterfaces"></a>
Runtime Interfaces</h1>
<p>The UFE component defines abstract interfaces. These define semantics that concrete UFE derived class concrete interfaces must implement.</p>
<p>The concrete implementation of one or more interfaces for a given runtime can be either built into the DCC, or provided by a plug-in to that DCC. Providing UFE support through a DCC plug-in has several advantages, all related to the fact that the plug-in is a separate software component:</p><ul>
<li>It provides extensibility to support new data models in the DCC through UFE, without changing the DCC itself.</li>
<li>It reduces risk because the DCC code remains unchanged.</li>
<li>It provides flexibility in delivering the plug-in or fixes to the plug-in separately from the DCC.</li>
</ul>
<p>The sequence of steps, and the software components that participate in implementing this scheme, are the following. Let us call the plug-in that provides UFE support to the DCC the <em>UFE plug-in</em>. Since this is the most flexible way of providing UFE support in a DCC, we will base our description on this approach, though DCC builtin code can follow exactly the same procedure.</p><ul>
<li>At plug-in load time, the UFE plug-in registers its interface implementations with the UFE runtime manager, using <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_run_time_mgr.html#abf677d9d32d6c9bc8e78966b46699dfc">Ufe::RunTimeMgr::register_()</a> . The plug-in registers one handler per interface it supports. Each handler is a singleton that will handle all interface object creation for the interface it handles. If no handler is registered by a runtime for a given interface, requesting an interface object for any scene item from that runtime will return a null pointer.</li>
<li>To view or edit an object from a UFE-enabled runtime, the DCC creates an interface object on a scene item. If the scene item supports the interface, a pointer to a valid interface object is returned. If the scene item does not support the interface, a null pointer is returned. <div class="fragment"><div class="line"><a class="code" href="#!/url=./ufe_ref/class_ufe_1_1_selection.html">Ufe::Selection</a> selection;</div><div class="line"><span class="comment">// Fill in the selection here.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : selection) {</div><div class="line">    <span class="keyword">auto</span> hierarchy = <a class="code" href="#!/url=./ufe_ref/class_ufe_1_1_hierarchy.html#aacea2115703c54367e2419df4becad09">Ufe::Hierarchy::hierarchy</a>(item);</div><div class="line">    <span class="keywordflow">if</span> (!hierarchy) {</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">auto</span> parent = hierarchy-&gt;parent();</div><div class="line">    <span class="comment">// Perform operations on parent here.</span></div><div class="line">}</div></div><!-- fragment --></li>
<li>Internally, UFE uses the handler for the requested interface to create, or bind an existing interface object to the scene item. The runtime that is used is the runtime corresponding to the ID of the final segment in the path. The runtime manager accesses the interface handler for that runtime, and asks the interface handler to return the interface object. This is hidden from the caller, but must be understood by the runtime implementer.</li>
</ul>
<p>The following component diagram illustrates the responsibilities and dependencies of the different objects.</p>
<div class="image">
<img src="ufe_ref/componentDiagram.png" alt="componentDiagram.png">
<div class="caption">
Component Diagram</div></div>
<p> The following sequence diagram illustrates the flow of control between the different components and objects.</p>
<p>   </p><div class="image">
<img src="ufe_ref/sequenceDiagram.png" alt="sequenceDiagram.png">
<div class="caption">
Sequence Diagram</div></div>
 <h1><a class="anchor" id="notifications"></a>
Notifications</h1>
<p>UFE supports the <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer Pattern</a> to allow Views in the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-view-controller Pattern</a> to update on changes.</p>
<p>Observable objects in UFE (Subjects, in Observer Pattern terminology) include an <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_observable_selection.html">Ufe::ObservableSelection</a>, derived from the <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_selection.html">Ufe::Selection</a> base class, to be notified of selection changes, as well as scene items that support the <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_transform3d.html">Ufe::Transform3d</a> interface, to be notified of 3D transform changes on those scene objects. To receive notifications, clients must create an <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_observer.html">Ufe::Observer</a> object, and add it to the Subject to be observed.</p>
<p>It is the intention of UFE to encapsulate native runtime notifications so that UFE clients do not have to use the native runtime API to receive notifications, and can rely on UFE alone.</p>
<p>At time of writing (13-Mar-2018), UFE does not support notification grouping, so that multiple fine-grained notifications can be delivered to observers in a single transaction. However, this support is desired and intended to be present in a future version of UFE.</p>
<h1><a class="anchor" id="selection"></a>
Selection</h1>
<p>The <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_selection.html">Ufe::Selection</a> class provides the following services and performance characteristics. Assuming a scene item with a path of m components, and a selection list that already has n scene items:</p><ul>
<li>Order preserving: items in the list are iterated on according to their append order.</li>
<li>Uniqueness: a <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_scene_item.html">Ufe::SceneItem</a> can be present in the list only once, as keyed by its <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path.html">Ufe::Path</a> .</li>
<li>O(m) append: appending a scene item to the list is on average linear on the number of <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path_component.html">Ufe::PathComponent</a> in the scene item's path.</li>
<li>O(m) remove: similar to append.</li>
<li>O(m) search: similar to append.</li>
<li>O(n) clear.</li>
<li>O(m) queries for contains ancestor or contains descendant.</li>
</ul>
<p>Internally, each selection maintains a <a href="https://en.wikipedia.org/wiki/Trie">Trie</a> of scene items to accelerate lookup. <br>
 </p>
<h1><a class="anchor" id="globalSelection"></a>
Global Selection</h1>
<p>UFE clients can create any number of <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_selection.html">Ufe::Selection</a> objects for their needs. UFE supports the concept of a <a class="el" href="#!/url=./ufe_ref/namespace_ufe_1_1_global_selection.html">Ufe::GlobalSelection</a> singleton, which contains an observable selection. This is intended to match DCCs which use a single, global selection as the workflow mechanism to determine what a user will view or edit. The DCC can set the <a class="el" href="#!/url=./ufe_ref/namespace_ufe_1_1_global_selection.html">Ufe::GlobalSelection</a> observable selection using <a class="el" href="#!/url=./ufe_ref/namespace_ufe_1_1_global_selection.html#a634fa9d70d5cf0de940542075a4a4ecf">Ufe::GlobalSelection::initializeInstance()</a> .</p>
<h1><a class="anchor" id="undoRedo"></a>
Undo / Redo</h1>
<p>UFE provides support for DCC services like undo / redo. In all UFE interfaces that modify objects, each operation has two calls, one with undo capability, and one without. Providing undo capability typically involves code complexity, and using undo capability incurs runtime cost in processing and memory. Therefore, non-interactive use of an interface should use calls without undo capability.</p>
<p>The UFE interface calls that provide undo capability do so by supporting the <a href="https://en.wikipedia.org/wiki/Command_pattern">Command Pattern</a>, to allow the host application to execute and unexecute the operation.</p>
<h1><a class="anchor" id="pathString"></a>
Path Strings</h1>
<p>In UFE, <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_path.html">paths</a> are full-fledged objects that are accessed and used through their object interfaces, in Python and C++. To support scripting environments where such Python or C++ access is inconvenient or simply not possible, UFE provides an optional <a class="el" href="#!/url=./ufe_ref/namespace_ufe_1_1_path_string.html">path string</a> service, which converts a parsable UFE path string to a UFE path. A UFE path string has its segments separated by a path segment separator string, which by default is the single-character comma string ','. In this way, UFE paths can be transported and manipulated as strings. Converting a UFE path to a parsable UFE path string is also provided. To use the path string service, a runtime registers the path component separator(s) it understands at initialization time, using <a class="el" href="#!/url=./ufe_ref/namespace_ufe_1_1_path_string.html#a56bfa10c4ee2673e9ce3b1af6a22468c">Ufe::PathString::registerPathComponentSeparator()</a> .</p>
<h1><a class="anchor" id="versioning"></a>
Versioning</h1>
<p>UFE uses the familiar <a href="https://semver.org">semantic versioning</a> scheme. This implies binary backwardly compatible minor versions, so that plug-ins and clients will be able to pickup a new UFE minor version without needing to recompile.</p>
<p>UFE will attempt to have mostly source code backwardly compatible major versions, so that only minor changes to existing code are necessary when updating to a new major version.</p>
<p>The UFE API is namespaced using the major version number. For ease of use, UFE uses a C++ using namespace declaration to present a familiar un-versioned <a class="el" href="#!/url=./ufe_ref/namespace_ufe.html">Ufe</a> namespace to client code, while keeping the actual symbols in the shared library versioned.</p>
<p>UFE provides the <a class="el" href="#!/url=./ufe_ref/class_ufe_1_1_version_info.html">Ufe::VersionInfo</a> class to retrieve versioning information. It is possible to obtain major, minor, and patch versions, as well as build number, commit SHA, branch name, and build date, both from C++ and from Python. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
