<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
      <title>C++ API Reference: gpuCache/gpuCacheIsectUtil.cpp</title>
      
	  
      
      
      
      
      
      
      
    

</head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_isect_util_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
      <div>
         <div class="head">
            <h1>C++ API Reference: gpuCache/gpuCacheIsectUtil.cpp</h1>
         </div>

<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->

  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="cpp_ref/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="cpp_ref/search/close.png" alt=""></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<!-- window showing the filter options -->


<!-- iframe showing the search results (closed by default) -->


<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/gpuCacheIsectUtil.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc. All rights reserved.</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk</span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download,</span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic</span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheIsectUtil.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MMatrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPointArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// used when ray does not intersect object</span></div>
<div class="line">    <span class="comment">// to account for perspective, all edges are flattened onto </span></div>
<div class="line">    <span class="comment">// a plane defined by the raySource and rayDirection</span></div>
<div class="line">    <span class="keywordtype">double</span> gpuCacheIsectUtil::getClosestPointOnLine(<span class="keyword">const</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; queryPoint, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; pt1, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; pt2, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; closestPoint){</div>
<div class="line">        <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> edgeVec = pt2-pt1;</div>
<div class="line">        <span class="keywordtype">double</span> t = ( (queryPoint - pt1) * edgeVec ) / (edgeVec * edgeVec);</div>
<div class="line">        <span class="keywordflow">if</span>(t&lt;0) t=0;</div>
<div class="line">        <span class="keywordflow">if</span>(t&gt;1) t=1;</div>
<div class="line">        closestPoint = (1-t) * pt1 + t * pt2;</div>
<div class="line">        <span class="keywordflow">return</span> t;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"></div>
<div class="line">    <span class="comment">// used when ray does not intersect object</span></div>
<div class="line">    <span class="comment">// to account for perspective, all edges are flattened onto </span></div>
<div class="line">    <span class="comment">// a plane defined by the raySource and rayDirection</span></div>
<div class="line">    <span class="keywordtype">double</span> gpuCacheIsectUtil::getEdgeSnapPointOnBox(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; raySource, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp; rayDirection, <span class="keyword">const</span> <a name="_a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>&amp; bbox, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; snapPoint){</div>
<div class="line">        <span class="comment">//if ray intersects bbox</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> boxIntersectionPt;</div>
<div class="line">        <span class="keywordflow">if</span>(firstRayIntersection(bbox.<a name="a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afb3213b98f3a6b4bda9759511e9b79a1">min</a>(), bbox.<a name="a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a1dfdbea9d5560e4aa09d34bdbd82480c">max</a>(), raySource, rayDirection, NULL, &amp;boxIntersectionPt))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//  ray intersects bounding box, so snapPoint is</span></div>
<div class="line">            <span class="comment">//  closest hit on the outside of the box</span></div>
<div class="line">            <span class="comment">//  and distance to box is 0 (for snapping purposes)</span></div>
<div class="line">            snapPoint = boxIntersectionPt;</div>
<div class="line">            <span class="keywordflow">return</span> 0.0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <a name="_a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_point_array.html">MPointArray</a> verts;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vmin = bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afb3213b98f3a6b4bda9759511e9b79a1">min</a>();</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vmax = bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a1dfdbea9d5560e4aa09d34bdbd82480c">max</a>();</div>
<div class="line"></div>
<div class="line">        verts.<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(vmin,0);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(<a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(vmax[0],vmin[1],vmin[2]),1);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(<a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(vmax[0],vmax[1],vmin[2]),2);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(<a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(vmin[0],vmax[1],vmin[2]),3);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(<a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(vmin[0],vmin[1],vmax[2]),4);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(<a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(vmax[0],vmin[1],vmax[2]),5);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(vmax,6);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(<a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(vmin[0],vmax[1],vmax[2]),7);</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">int</span> edgeIndices[12][2]={{0,1},{1,2},{2,3},{3,0},{4,5},{5,6},{6,7},{7,4},{0,4},{1,5},{3,7},{2,6}};</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">double</span> minDistRect = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> edge=0; edge&lt;12;edge++){</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1Org = verts[edgeIndices[edge][0]];</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2Org = verts[edgeIndices[edge][1]];</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">double</span> coef_plane = rayDirection * raySource;</div>
<div class="line">            <span class="keywordtype">double</span> d = coef_plane - rayDirection * vertex1Org;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1 = vertex1Org + rayDirection * d;</div>
<div class="line">            d = coef_plane - rayDirection * vertex2Org;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2 = vertex2Org + rayDirection * d;</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> edgeDir = vertex2 - vertex1;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (edgeDir.<a name="a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_vector.html#ad207cb443e371f73f07e874c504f60c1">length</a>()&lt;0.0000001){</div>
<div class="line">                <span class="keywordtype">double</span> dist = vertex1.<a name="a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(raySource);</div>
<div class="line">                <span class="keywordflow">if</span> (dist &lt; minDistRect) {</div>
<div class="line">                    minDistRect = dist;</div>
<div class="line">                    snapPoint = vertex1Org;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> edgePt;</div>
<div class="line">                <span class="comment">// Compute the closest point from the edge to cursor Ray.</span></div>
<div class="line">                <span class="keywordtype">double</span> percent = gpuCacheIsectUtil::getClosestPointOnLine(raySource, vertex1, vertex2, edgePt);</div>
<div class="line">                <span class="keywordtype">double</span> dist = edgePt.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(raySource);</div>
<div class="line">                <span class="keywordflow">if</span> (dist &lt; minDistRect) {</div>
<div class="line">                    minDistRect = dist;</div>
<div class="line">                    snapPoint =  (vertex1Org + percent * (vertex2Org - vertex1Org));</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> minDistRect;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// used when ray does not intersect object</span></div>
<div class="line">    <span class="comment">// to account for perspective, all edges are flattened onto </span></div>
<div class="line">    <span class="comment">// a plane defined by the raySource and rayDirection</span></div>
<div class="line">    <span class="keywordtype">double</span> gpuCacheIsectUtil::getEdgeSnapPointOnTriangle(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; raySource, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp; rayDirection, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; vert1, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; vert2, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; vert3, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; snapPoint){</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point_array.html">MPointArray</a> verts;</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(vert1,0);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(vert2,1);</div>
<div class="line">        verts.<a class="code" href="#!/url=./cpp_ref/class_m_point_array.html#a578d44499816c760ecc9812f59ebb0ba">insert</a>(vert3,2);</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">int</span> edgeIndices[3][2]={{0,1},{1,2},{2,0}};</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">double</span> minDistTri = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> edge=0; edge&lt;3;edge++){</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1Org = verts[edgeIndices[edge][0]];</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2Org = verts[edgeIndices[edge][1]];</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">double</span> coef_plane = rayDirection * raySource;</div>
<div class="line">            <span class="keywordtype">double</span> d = coef_plane - rayDirection * vertex1Org;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1 = vertex1Org + rayDirection * d;</div>
<div class="line">            d = coef_plane - rayDirection * vertex2Org;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2 = vertex2Org + rayDirection * d;</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> edgeDir = vertex2 - vertex1;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (edgeDir.<a class="code" href="#!/url=./cpp_ref/class_m_vector.html#ad207cb443e371f73f07e874c504f60c1">length</a>()&lt;0.0000001){</div>
<div class="line">                <span class="keywordtype">double</span> dist = vertex1.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(raySource);</div>
<div class="line">                <span class="keywordflow">if</span> (dist &lt; minDistTri) {</div>
<div class="line">                    minDistTri = dist;</div>
<div class="line">                    snapPoint = vertex1Org;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> edgePt;</div>
<div class="line">                <span class="comment">// Compute the closest point from the edge to cursor Ray.</span></div>
<div class="line">                <span class="keywordtype">double</span> percent = gpuCacheIsectUtil::getClosestPointOnLine(raySource, vertex1, vertex2, edgePt);</div>
<div class="line">                <span class="keywordtype">double</span> dist = edgePt.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(raySource);                                                            </div>
<div class="line">                <span class="keywordflow">if</span> (dist &lt; minDistTri) {</div>
<div class="line">                    minDistTri = dist;</div>
<div class="line">                    snapPoint =  (vertex1Org + percent * (vertex2Org - vertex1Org));</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> minDistTri;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> gpuCacheIsectUtil::getClosestPointToRayOnLine(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; vertex1, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; vertex2, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; raySource, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp; rayDirection, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; closestPoint, <span class="keywordtype">double</span>&amp; percent){</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> clsPoint;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> edgeDir = vertex2 - vertex1;</div>
<div class="line">        <span class="keywordtype">double</span> len = edgeDir.<a class="code" href="#!/url=./cpp_ref/class_m_vector.html#ad207cb443e371f73f07e874c504f60c1">length</a>();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(len &lt; 0.0000001 )</div>
<div class="line">        {</div>
<div class="line">            percent = 0.0;</div>
<div class="line">            closestPoint = vertex1;</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        edgeDir.<a name="a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_vector.html#ab66b0c7697d96a278da9bca810f4dee1">normalize</a>();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">//if line is parallel to ray</span></div>
<div class="line">        <span class="keywordtype">double</span> dotPrd = fabs(edgeDir * rayDirection);</div>
<div class="line">        <span class="keywordflow">if</span>(dotPrd &gt; 0.9999){</div>
<div class="line">            percent = 0.0;</div>
<div class="line">            closestPoint = vertex1;</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Vector connecting two closest points.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> crossProd = edgeDir ^ rayDirection;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Normal to the plane defined by that vector and the &#39;otherLine&#39;.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> planeNormal = rayDirection ^ crossProd;</div>
<div class="line">        <span class="comment">//intersectionPlane is raySource,planeNormal</span></div>
<div class="line">        <span class="keywordtype">double</span> t;</div>
<div class="line">        <span class="keywordflow">if</span>(intersectPlane(raySource, planeNormal, vertex1,edgeDir,t)){</div>
<div class="line">            clsPoint = vertex1 + t * edgeDir;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Find percent, where</span></div>
<div class="line">            <span class="comment">// vertex1 + percent * (edgeDir) == closestPoint</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            percent = edgeDir * (clsPoint - vertex1) / len;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The closest point may not be on the segment. Find the closest</span></div>
<div class="line">            <span class="comment">// point on the segment using t.</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="keywordflow">if</span> (percent &lt; 0)</div>
<div class="line">            {</div>
<div class="line">                closestPoint = vertex1;</div>
<div class="line">                percent = 0.0;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (percent &gt; 1.0)</div>
<div class="line">            {</div>
<div class="line">                closestPoint = vertex2;</div>
<div class="line">                percent = 1.0;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                closestPoint = clsPoint;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            closestPoint = vertex1;</div>
<div class="line">            percent = 0.0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> gpuCacheIsectUtil::getClosestPointOnBox(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; point, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>&amp; bbox, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; closestPoint){</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> diff = point - bbox.<a name="a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a329b58fadcbe4f236bfbb0887253fdc7">center</a>();</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> axis[3] = { <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>(1.0,0.0,0.0),</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>(0.0,1.0,0.0),</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>(0.0,0.0,1.0)};</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">double</span> dimensions[3] = {0.5*bbox.<a name="a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a6cddcbf72c80144aa2e6501abb150c30">width</a>(),0.5*bbox.<a name="a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afa7750092d5dcf402c83fb5adba91453">height</a>(),0.5*bbox.<a name="a13"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a65c72a51aba9fc4233b58751dd712e43">depth</a>()};</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">double</span> sqrDistance = 0.0;</div>
<div class="line">        <span class="keywordtype">double</span> delta;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> closest;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line">        {</div>
<div class="line">            closest[i] = diff * axis[i];</div>
<div class="line">            <span class="keywordflow">if</span> (closest[i] &lt; -dimensions[i])</div>
<div class="line">            {</div>
<div class="line">                delta = closest[i] + dimensions[i];</div>
<div class="line">                sqrDistance += delta*delta;</div>
<div class="line">                closest[i] = -dimensions[i];</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (closest[i] &gt; dimensions[i])</div>
<div class="line">            {</div>
<div class="line">                delta = closest[i] - dimensions[i];  </div>
<div class="line">                sqrDistance += delta*delta;</div>
<div class="line">                closest[i] = dimensions[i];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        closestPoint = bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a329b58fadcbe4f236bfbb0887253fdc7">center</a>();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line">        {</div>
<div class="line">            closestPoint += closest[i]*axis[i];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> sqrt(sqrDistance);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> gpuCacheIsectUtil::intersectRayWithBox(</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> minPoint,</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> maxPoint,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;   rayOrigin,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp;  rayDirection,</div>
<div class="line">        <span class="keywordtype">double</span>          isectParams[2]</div>
<div class="line">    )</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//  Description:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//      Utility function that finds parametric values of all</span></div>
<div class="line">        <span class="comment">//      intersections of a ray with the bounding box whose</span></div>
<div class="line">        <span class="comment">//      lower and upper bounds along each axis are defined</span></div>
<div class="line">        <span class="comment">//      by xBound, yBound, zBound.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//      Returns number of hits found (should always be &lt;= 2),</span></div>
<div class="line">        <span class="comment">//      and returns parametric values of hits (sorted by increasing</span></div>
<div class="line">        <span class="comment">//      distance from the ray) through isectParams array.</span></div>
<div class="line">        <span class="comment">//      These parameters are the &quot;t&quot; values, if the ray is </span></div>
<div class="line">        <span class="comment">//      expressed parametrically as P(t) = rayOrigin + t*rayDirection.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//  small tolerance necessary when ray passes almost exactly through</span></div>
<div class="line">        <span class="comment">//  corners of the bounding box.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> isectTol = 1.0e-6;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  how many hits have we found so far</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">int</span> numFound = 0;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  put bounds in an array to let us index them by axis</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">double</span> boundsMin[3]={minPoint[0],minPoint[1],minPoint[2]};</div>
<div class="line">        <span class="keywordtype">double</span> boundsMax[3]={maxPoint[0],maxPoint[1],maxPoint[2]};</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  for each side of the voxel grid (+X, -X, +Y, -Y, +Z, -Z), we will</span></div>
<div class="line">        <span class="comment">//  intersect the ray with that side&#39;s plane, then check the intersection</span></div>
<div class="line">        <span class="comment">//  point to see if it lies within </span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> axis = 0; axis &lt; 3; axis++ )</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//  ray can&#39;t intersect faces that it is parallel to </span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="keywordflow">if</span>( rayDirection[axis] != 0 )</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//  We are intersecting the ray with faces perp. to one axis </span></div>
<div class="line">                <span class="comment">//  (X, Y, or Z).  Figure out what the other two axes are, as we&#39;re </span></div>
<div class="line">                <span class="comment">//  going to have to test whether the intersect points are &quot;inside&quot;</span></div>
<div class="line">                <span class="comment">//  those faces.</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="keywordtype">int</span> otherAxis1 = (axis+1)%3;</div>
<div class="line">                <span class="keywordtype">int</span> otherAxis2 = (axis+2)%3;</div>
<div class="line"></div>
<div class="line">                <span class="comment">//  figure out high and low &quot;axis&quot; coordinate values for the faces</span></div>
<div class="line">                <span class="comment">//  (x values of the -X and +X faces, for example)</span></div>
<div class="line">                <span class="comment">//          </span></div>
<div class="line">                <span class="keywordtype">double</span> sides[2] = { boundsMin[axis], boundsMax[axis] };</div>
<div class="line"></div>
<div class="line">                <span class="comment">//  find the ray intersection with the high and low faces for this</span></div>
<div class="line">                <span class="comment">//  axis, and determine if the hit points lie within the bounds</span></div>
<div class="line">                <span class="comment">//  for the other two axes.  For example, if the ray hits the plane</span></div>
<div class="line">                <span class="comment">//  defined by the +X face, does the hit point lie within the Y and Z</span></div>
<div class="line">                <span class="comment">//  ranges of the box.  If so, then the ray intersects the box at</span></div>
<div class="line">                <span class="comment">//  that point.</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="comment">//  &quot;side&quot; is just 0 or 1: 0 for the low face (-X, for example),</span></div>
<div class="line">                <span class="comment">//  1 for the high face (1, for example).</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> side = 0; side &lt; 2; side++ )</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//  find parametric distance to this face</span></div>
<div class="line">                    <span class="comment">//  </span></div>
<div class="line">                    <span class="keywordtype">double</span> tSide = (sides[side]-rayOrigin[axis])/rayDirection[axis];</div>
<div class="line">                    <span class="keywordflow">if</span>( tSide &gt; 0.0 )</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">//  find first other coordinate value of hit point (hit x</span></div>
<div class="line">                        <span class="comment">//  axis, we figure out the y value, for example)</span></div>
<div class="line">                        <span class="comment">//</span></div>
<div class="line">                        <span class="keywordtype">double</span> newPointOtherAxis1 = rayOrigin[otherAxis1] + </div>
<div class="line">                            tSide*rayDirection[otherAxis1];</div>
<div class="line"></div>
<div class="line">                        <span class="comment">//  see if the bounding box for the first other axis </span></div>
<div class="line">                        <span class="comment">//  contains the hit point.  If not, the ray can&#39;t intersect</span></div>
<div class="line">                        <span class="comment">//  this face of the bounding box</span></div>
<div class="line">                        <span class="comment">//</span></div>
<div class="line"></div>
<div class="line">                        <span class="keywordflow">if</span>( (newPointOtherAxis1 &gt;= (boundsMin[otherAxis1]-isectTol)) &amp;&amp; (newPointOtherAxis1 &lt;= (boundsMax[otherAxis1]+isectTol)) )</div>
<div class="line">                        {</div>
<div class="line">                            <span class="comment">//  now, test the hit point for the second other coordinate</span></div>
<div class="line">                            <span class="comment">//  value, to see if it is inside the box bounds</span></div>
<div class="line">                            <span class="comment">//</span></div>
<div class="line">                            <span class="keywordtype">double</span> newPointOtherAxis2 = rayOrigin[otherAxis2] + </div>
<div class="line">                                tSide*rayDirection[otherAxis2];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">                            <span class="keywordflow">if</span>( (newPointOtherAxis2 &gt;= (boundsMin[otherAxis2]-isectTol)) &amp;&amp; (newPointOtherAxis2 &lt;= (boundsMax[otherAxis2]+isectTol)) )</div>
<div class="line">                            {</div>
<div class="line">                                <span class="comment">//  Point is on one face, inside the box bounds for</span></div>
<div class="line">                                <span class="comment">//  the other two axes, so it&#39;s a hit.  </span></div>
<div class="line">                                <span class="comment">//  Now, insert its parametric value into the hit</span></div>
<div class="line">                                <span class="comment">//  param array, maintaining the array in</span></div>
<div class="line">                                <span class="comment">//  sorted order of ascending t.  Note that since</span></div>
<div class="line">                                <span class="comment">//  we are intersecting a ray against a convex </span></div>
<div class="line">                                <span class="comment">//  object, we should never have more than 2 </span></div>
<div class="line">                                <span class="comment">//  intersections, so we&#39;ll just assume that the</span></div>
<div class="line">                                <span class="comment">//  array currently has size 0 or 1, which makes</span></div>
<div class="line">                                <span class="comment">//  the sorting trivial. </span></div>
<div class="line">                                <span class="comment">//</span></div>
<div class="line">                                <span class="comment">//  The only time that this may not be the case</span></div>
<div class="line">                                <span class="comment">//  is if a ray goes exactly through an edge or</span></div>
<div class="line">                                <span class="comment">//  a corner.  In that case, all the intersections</span></div>
<div class="line">                                <span class="comment">//  correspond to the same point, so we should only</span></div>
<div class="line">                                <span class="comment">//  report it once.  We will achieve this by </span></div>
<div class="line">                                <span class="comment">//  discarding intersection param values that are</span></div>
<div class="line">                                <span class="comment">//  &quot;equivalent&quot; (equal with a small numerical </span></div>
<div class="line">                                <span class="comment">//  tolerance). </span></div>
<div class="line">                                <span class="comment">//</span></div>
<div class="line">                                <span class="keywordflow">if</span>( numFound == 0 )</div>
<div class="line">                                {</div>
<div class="line">                                    isectParams[0] = tSide;</div>
<div class="line">                                    numFound++;</div>
<div class="line">                                }</div>
<div class="line">                                <span class="keywordflow">else</span> <span class="keywordflow">if</span>( numFound == 1 )</div>
<div class="line">                                {</div>
<div class="line">                                    <span class="comment">//  add the hit param in the appropriate</span></div>
<div class="line">                                    <span class="comment">//  position in the array</span></div>
<div class="line">                                    <span class="comment">//</span></div>
<div class="line">                                    <span class="keywordflow">if</span>( tSide &gt;= (isectParams[0]+1.0e-10) )</div>
<div class="line">                                    {</div>
<div class="line">                                        isectParams[1] = tSide;</div>
<div class="line">                                        numFound++;</div>
<div class="line">                                    }</div>
<div class="line">                                    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( tSide &lt;= (isectParams[0]-1.0e-10) )</div>
<div class="line">                                    {</div>
<div class="line">                                        isectParams[1] = isectParams[0];</div>
<div class="line">                                        isectParams[0] = tSide;</div>
<div class="line">                                        numFound++;</div>
<div class="line">                                    }</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> numFound;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> gpuCacheIsectUtil::firstRayIntersection ( </div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> bboxMin,</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> bboxMax,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;       rayOrigin,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp;      rayDirection,</div>
<div class="line">        <span class="keywordtype">double</span>*         isectParam,</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> *        isectPoint</div>
<div class="line">        ) </div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//  Description:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//      Finds first hit of ray against the outside of the bounding box.</span></div>
<div class="line">        <span class="comment">//      Returns true if the ray hits the box, false otherwise.</span></div>
<div class="line">        <span class="comment">//      &quot;isectParam&quot;, if non-NULL, receives parametric distance along ray</span></div>
<div class="line">        <span class="comment">//      to the intersection point (ie the &quot;t&quot; value if the ray is expressed</span></div>
<div class="line">        <span class="comment">//      parametrically as P(t) = rayOrigin + t * rayDirection).</span></div>
<div class="line">        <span class="comment">//      &quot;isectPoint&quot;, if non-NULL, receives the intersection point coordinates.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//  get all the hits with the bounding box</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">double</span> allIsectParams[4] = {0};</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>( !intersectRayWithBox( bboxMin, bboxMax, rayOrigin, rayDirection, allIsectParams ) )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//  Found hits, so closest one is first in array.  Return</span></div>
<div class="line">            <span class="comment">//  parametric value and point coordinates, if required.</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="keywordflow">if</span>( isectParam != NULL )</div>
<div class="line">            {</div>
<div class="line">                *isectParam = allIsectParams[0];</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span>( isectPoint != NULL )</div>
<div class="line">            {</div>
<div class="line">                *isectPoint = rayOrigin + allIsectParams[0]*rayDirection;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> gpuCacheIsectUtil::intersectPlane(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;planePoint, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;planeNormal, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; rayPoint, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;rayDirection, <span class="keywordtype">double</span> &amp;t)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// assuming vectors are all normalized</span></div>
<div class="line">        <span class="keywordtype">double</span> denom = planeNormal * rayDirection;</div>
<div class="line">        <span class="keywordflow">if</span> (denom &gt; 0.0000001) {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> p0l0 = planePoint - rayPoint;</div>
<div class="line">            t = (p0l0 * planeNormal) / denom; </div>
<div class="line">            <span class="keywordflow">return</span> (t &gt;= 0);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> gpuCacheIsectUtil::getClosestPointOnTri(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;toThisPoint, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;pt1, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;pt2, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;pt3, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;theClosestPoint, <span class="keywordtype">double</span> &amp;currDist) </div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">double</span>      sum, a, b, c, len, dist;</div>
<div class="line">        <a name="_a14"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> mat;</div>
<div class="line">        mat.<a name="a15"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a1353e697af6f95ba0b8c0331c6af7f2f">setToIdentity</a>();</div>
<div class="line">        mat[2][0] = mat[2][1] = mat[2][2] = 1.;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> v = toThisPoint - pt1;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> v12 = pt2 - pt1;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> v13 = pt3 - pt1;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> norm = v12 ^ v13;</div>
<div class="line">        len = norm * norm;</div>
<div class="line">        <span class="keywordflow">if</span> (len &lt; 1.175494351e-38F) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        len = ( norm * v ) / len;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> pnt = toThisPoint - len * norm;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Do a quick test first</span></div>
<div class="line">        <span class="keywordflow">if</span> (pnt.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(toThisPoint) &gt;= currDist)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">int</span> i, j;               <span class="comment">// Find best plane to project to</span></div>
<div class="line">        <span class="keywordflow">if</span> (fabs(norm[0]) &gt; fabs(norm[1]))</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (fabs(norm[0]) &gt; fabs(norm[2]))</div>
<div class="line">            {</div>
<div class="line">                i = 1; j = 2;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                i = 0; j = 1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (fabs(norm[1]) &gt; fabs(norm[2]))</div>
<div class="line">            {</div>
<div class="line">                i = 0; j = 2;</div>
<div class="line">                <span class="comment">// i = 2; j = 0;</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                i = 0; j = 1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        mat[0][0] = pt1[i]; mat[0][1] = pt2[i]; mat[0][2] = pt3[i]; </div>
<div class="line">        mat[1][0] = pt1[j]; mat[1][1] = pt2[j]; mat[1][2] = pt3[j]; </div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> matInv = mat.<a name="a16"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a8ca5ebc404566e2c4a16d4754772e082">inverse</a>();</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> abc(pnt[i], pnt[j], 1, 0);</div>
<div class="line"></div>
<div class="line">        abc = matInv * abc;</div>
<div class="line">        <span class="comment">// Now abc is the barycentric coordinates of pnt</span></div>
<div class="line">        <span class="comment">// clip to inside triangle</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (abc[0]&lt;0) { <span class="comment">// a &lt; 0</span></div>
<div class="line">            <span class="keywordflow">if</span> (abc[1]&lt;0) { <span class="comment">// b &lt; 0</span></div>
<div class="line">                a = b = 0;</div>
<div class="line">                c = 1;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abc[2]&lt;0) { <span class="comment">// c &lt; 0</span></div>
<div class="line">                a = c = 0;</div>
<div class="line">                b = 1;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                a = 0;</div>
<div class="line">                <span class="comment">// c = BP dot BC / BC square;</span></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> v23 = pt3 - pt2; <span class="comment">// BC</span></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> vp =  toThisPoint - pt2;  <span class="comment">// BP</span></div>
<div class="line"></div>
<div class="line">                c = ( vp * v23 ) / ( v23[0]*v23[0] + v23[1]*v23[1] + v23[2]*v23[2] );</div>
<div class="line">                <span class="keywordflow">if</span> (c&lt;0) c = 0; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c&gt;1) c = 1;</div>
<div class="line">                b = 1 - c;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abc[1]&lt;0) { <span class="comment">// b &lt; 0</span></div>
<div class="line">            <span class="keywordflow">if</span> (abc[2]&lt;0) { <span class="comment">// c &lt; 0</span></div>
<div class="line">                b = c = 0;</div>
<div class="line">                a = 1;</div>
<div class="line">                <span class="comment">//} else if (abc[0]&lt;0) { // a &lt; 0</span></div>
<div class="line">                <span class="comment">//  b = a = 0;  // commented-code for optimization</span></div>
<div class="line">                <span class="comment">//  c = 1;      // leaving it in for readability (cyclic variations)</span></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                b = 0;</div>
<div class="line">                <span class="comment">// a = CP dot CA / CA square;</span></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> v31 = pt1 - pt3; <span class="comment">// CA</span></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> vp =  toThisPoint - pt3;  <span class="comment">// CP</span></div>
<div class="line"></div>
<div class="line">                a = ( vp * v31 ) / ( v31[0]*v31[0] + v31[1]*v31[1] +v31[2]*v31[2] );</div>
<div class="line">                <span class="keywordflow">if</span> (a&lt;0) a = 0; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a&gt;1) a = 1;</div>
<div class="line">                c = 1 - a;</div>
<div class="line">            } </div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abc[2]&lt;0) { <span class="comment">// c &lt; 0</span></div>
<div class="line">            <span class="comment">//if (abc[1]&lt;0) { // b &lt; 0</span></div>
<div class="line">            <span class="comment">//  c = b = 0;</span></div>
<div class="line">            <span class="comment">//  a = 1;</span></div>
<div class="line">            <span class="comment">//} else if (abc[0]&lt;0) { // a &lt; 0</span></div>
<div class="line">            <span class="comment">//  c = a = 0;</span></div>
<div class="line">            <span class="comment">//  b = 1;  // commented-code for optimization</span></div>
<div class="line">            <span class="comment">//} else {  // leaving it in for readability (cyclic variations)</span></div>
<div class="line">            c = 0;</div>
<div class="line">            <span class="comment">// b = AP dot AB / AB square;</span></div>
<div class="line">            <span class="comment">//DIFF(v23, pt3, pt2); // AB</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> vp =  toThisPoint - pt1;  <span class="comment">// AP</span></div>
<div class="line"></div>
<div class="line">            b = ( vp * v12 ) / ( v12[0]*v12[0] + v12[1]*v12[1] + v12[2]*v12[2] );</div>
<div class="line">            <span class="keywordflow">if</span> (b&lt;0) b = 0; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b&gt;1) b = 1;</div>
<div class="line">            a = 1 - b;</div>
<div class="line">            <span class="comment">//}</span></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (abc[0]&gt;0) a = abc[0]; <span class="keywordflow">else</span> a = 0;</div>
<div class="line">            <span class="keywordflow">if</span> (abc[1]&gt;0) b = abc[1]; <span class="keywordflow">else</span> b = 0;</div>
<div class="line">            <span class="keywordflow">if</span> (abc[2]&gt;0) c = abc[2]; <span class="keywordflow">else</span> c = 0;</div>
<div class="line">        }</div>
<div class="line">        sum = a+b+c;</div>
<div class="line">        a /= sum ; b /= sum ; c /= sum ; </div>
<div class="line">        pnt = a * pt1 + b * pt2 + c * pt3;</div>
<div class="line">        dist = pnt.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(toThisPoint);</div>
<div class="line">        <span class="keywordflow">if</span> ( dist &lt; currDist)</div>
<div class="line">        {           </div>
<div class="line">            <span class="comment">// Now it&#39;s really closer, keep it</span></div>
<div class="line">            currDist = dist;</div>
<div class="line">            theClosestPoint = pnt;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
