var topic = "<!-- saved from url=(0024)http://docs.autodesk.com -->\n\
<html>\n\
   <head>\n\
<link href=\"../../../../style/prettify.css\" type=\"text/css\" rel=\"stylesheet\" />\n\
<script type=\"text/javascript\" src=\"../../../../scripts/prettify.js\"></script><script src=\"../../../../scripts/lib/jquery-1.11.1.min.js\" type=\"text/javascript\"></script><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /><meta http-equiv=\"Content-Style-Type\" content=\"text/css\" /><meta name=\"generator\" content=\"pandoc\" /><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /><script type=\"text/javascript\" src=\"../../../../scripts/utils/adsk.redirect.js\"></script>\n\
      <title>Render Loop Overrides</title>\n\
   </head>\n\
   <body height=\"100%\"><div class=\"body_content\" id=\"body-content\"><style type=\"text/css\">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs(\"./scripts/multireflink.js\"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id=\"reflinkdiv\"></div>\n\
      <div>\n\
         <div class=\"head\">\n\
            <h1>Render Loop Overrides</h1>\n\
         </div>\n\
\n\
<div class=\'section\'><a id=\"render-loop-overrides\"></a></div>\n\
<p>A render loop override is represented in the API as an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOverride</a></span>.</p>\n\
<p>As the name implies a plug-in of this type overrides the entire rendering for a complete frame. Unlike older interfaces there are no fixed entry points to insert or remove specific render logic in the render loop. For example there is no such thing as a “pre” and “post” “pass” callback. Instead the intention is to provide the appropriate mix of <strong>building blocks</strong> and pipeline exposure to allow the plug-in to define arbitrarily complex pipeline logic.</p>\n\
<p>An override is broken down into a set of <strong>operations</strong>. Predefined operations, which execute parts of the internal pipeline, as well as custom operations represent the base set of building blocks. Operations are designed to fully describe data inputs and outputs, and by default execute independently of each other. The main connection between operations is thus data. All operations render into a render target and data is explicitly passed between operations by sharing render targets.</p>\n\
<p>The following is a set of basic operations available:</p>\n\
<ul>\n\
<li><strong>Scene render</strong>: Draw renderable objects into a render target</li>\n\
<li><strong>2D quad render</strong>: render a 2d quad to a render target. Can take a render target as input.</li>\n\
<li><strong>User defined operation</strong>: Custom rendering to a render target.</li>\n\
<li><strong>Heads-up-display</strong>: Render a 2d HUD to a render target. Specific to 3d viewports.</li>\n\
<li>A <strong>present</strong> operation: Make a render target visible for interactive preview. Specific to 3d viewports.</li>\n\
</ul>\n\
<p>As these operations are embedded into the rendering pipeline, a rendering state is provided to operations as necessary. This information is generally determined at the beginning of a frame and is implicitly set as default values for each operation. Overrides which are set per operation do not persist between operations.</p>\n\
<ul>\n\
<li>The set of renderable objects</li>\n\
<li>The output render targets.</li>\n\
<li>The camera and viewport parameters.</li>\n\
<li>The render state.</li>\n\
<li>The renderer preferences. It is not advisable to change render global state during a frame render.</li>\n\
</ul>\n\
<p>Depending on the amount of customization, the interfaces are mostly draw API agnostic.</p>\n\
<p>Unlike previous API implementations, <strong>sequence</strong> is specified by plug-in code and is not defined by the interface. The plug-in is therefore required to break down the desired render loop into a linear list of operations. A basic look at the API interface shows an example of the type of render loop that can be specified (left). The plug-in determines the appropriate ordering of operations. On the right is the basic multi-pass looping logic for old interfaces. Here, sequence is predefined based on the interface.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8cfb.jpg\' title=\'\' /></div>\n\
<p>Figure 45: On the left, render targets serve as a means to pass context between operations as outputs and/or inputs. On the right, a series of scene render ‘passes’ get called one after the other to update a particular viewport. Callbacks in the old interface are provided between renders to access and update external data or state, which can be used to affect the current render or subsequent renders.</p>\n\
<div class=\'section\'><a id=\"render-override-registration-and-activation\"></a><h2 id=\"render-override-registration-and-activation\">Render Override Registration and Activation</h2></div>\n\
<p>As overrides are integrated into the rendering framework, they work for all exposed interfaces (3d viewport, Playblast, RenderView and batch rendering), while avoiding dependencies on any specific interface such as 3d viewports (M3dView).</p>\n\
<p>Any number of overrides can be registered via the MRenderer class but only one can be actively set per exposed interface. Each 3d viewport (which Playblast uses) can have a different override, while command line rendering (RenderView and batch) can use yet another different override.</p>\n\
<p>The main interfaces for querying the available set of overrides as well as setting the active override are: <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"M3dView\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m3d_view.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">M3dView</a></span> and the <strong>modelEditor</strong> for interactive rendering and render options or <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderer\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderer</a></span> for non interactive (RenderView and batch) rendering.</p>\n\
<p>Using an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOverride</a></span> does not always preclude usage of old interfaces but their usage is strongly discouraged for a number of reasons including the fact that old interfaces:</p>\n\
<ul>\n\
<li>Are inherently unsafe, since they equate the renderer with a 3d viewport OpenGL context – which is never the case in the rendering framework in which <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOverride</a></span> resides.</li>\n\
<li>Can modify state in unexpected ways, and as such must be guarded by the plug-in writer for all state changes.</li>\n\
<li>Are OpenGL only interfaces.</li>\n\
<li>Can only work for interactive rendering (e.g. <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"M3dView\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m3d_view.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">M3dView</a></span>)</li>\n\
<li>May cause unexpected DG or DAG object evaluation. (e.g. <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDrawTraversal\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_traversal.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MDrawTraversal</a></span>)</li>\n\
<li>Are incompatible. This includes <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPx3dModelView\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px3d_model_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MPx3dModelView</a></span> and <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MViewportRenderer\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_viewport_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MViewportRenderer</a></span>. Both can be replaced by <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOverride</a></span> functionality.</li>\n\
</ul>\n\
<p>When creating an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOverride</a></span> plug-in, you can do the following to add an option box to open a dialog that supports UI configurable user options:</p>\n\
<p>If your <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOverride</a></span>’s name is <em>FooRenderer</em>, then provide a global MEL procedure named <em>FooRendererOptionBox</em> (ensure that <em>OptionBox</em> is added as a postfix ), and the option box icon will appear beside the viewport menu item automatically.</p>\n\
<p>You can manage the UI layout of the option dialog box in the <em>FooRendererOptionBox</em> procedure.</p>\n\
<div class=\'section\'><a id=\"base-render-operation-and-utility-overrides\"></a><h2 id=\"base-render-operation-and-utility-overrides\">Base Render Operation And Utility Overrides</h2></div>\n\
<p>All render operations which can be instantiated are derived from the base class: <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOperation</a></span>. These classes can be used as is, or they can be further customized through further class derivation. Derivation is the approach used to provide override parameters or required methods per operation.</p>\n\
<p>MRenderOperation provides interfaces which are generic to all operations. This includes:</p>\n\
<ol>\n\
<li>A name: All operations require a unique identifier.</li>\n\
<li>A possible override for the output render targets (MRenderTarget).</li>\n\
<li>A possible override for the 2d viewport rectangle (of the draw context).</li>\n\
</ol>\n\
<p>Some operations such as scene renders and custom user operations can override camera inputs. The utility structure <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MCameraOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_camera_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_camera_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MCameraOverride</a></span> is the interface for providing such an override.</p>\n\
<p>The override of the camera can be specified at two levels:</p>\n\
<ul>\n\
<li>High level: Referencing a valid camera DAG object in the scene.</li>\n\
<li>Low level: Using any or all of: a view matrix, a projection matrix, a near clip plane, or a far clip plane. Note that the matrices used for projection follow the DirectX convention.</li>\n\
</ul>\n\
<p>The camera override parameters can also be used to hide the 3D UI for a list of cameras.</p>\n\
<p>Another utility structure which is coupled with scene operations and quad render operations is a render target clear. This structure is <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MClearOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_clear_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_clear_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MClearOperation</a></span>. The utilities parameters can be set to selectively indicate the following options:</p>\n\
<ul>\n\
<li>Clear color (RGBA)</li>\n\
<li>Whether to clear using a gradient fill.</li>\n\
<li>Clear mask (color, depth, stencil)</li>\n\
</ul>\n\
<p>User operations can perform their own clear as required.</p>\n\
<p>Note that clear operation overrides which are embedded in the render loop disallow any internal 2D post effects from rendering as the clear operation can cause required data for a post effect to be removed.</p>\n\
<p>All operations and support classes are only descriptions of behavior and are not resources themselves. As such, they can be persistent beyond the lifetime of a frame render.</p>\n\
<div class=\'section\'><a id=\"scene-render\"></a><h2 id=\"scene-render\">Scene Render</h2></div>\n\
<p>The construct to represent a scene render is <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MSceneRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MSceneRender</a></span>.</p>\n\
<p>By default a scene render operation renders all or part of the current visible scene into the current render target. Visibility takes into account the current state of objects, any display filters, and camera frustum culling.</p>\n\
<p>When querying pass context information if a scene render is active then its name will be the current pass identifier and the pass will be marked with a “color pass” semantic.</p>\n\
<p>There are a fair number of per operation overrides. These overrides reflect what can be set either in a 3d viewport or from command line rendering. The overrides are set for the duration that the operation is being executed.</p>\n\
<p>The possible overrides include:</p>\n\
<ul>\n\
<li>A camera override (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MCameraOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_camera_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_camera_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MCameraOverride</a></span>).</li>\n\
<li>An object set override by specifying a Maya selection list (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MSelectionList\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_selection_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MSelectionList</a></span>)</li>\n\
<li>Maya node object type exclusions (<span class=\'code\'>MObjectTypeExclusions</span>). This is similar to existing exclusion interfaces and allows for specific Maya node types to be excluded from rendering.</li>\n\
<li>A display mode override (<span class=\'code\'>MDisplayModeOverride</span>). Basic display modes such as wireframe, shaded, textured, bounding box, and default material draw.</li>\n\
<li>A lighting mode override (<span class=\'code\'>MLightingModeOverride</span>). Basic lighting modes such as no lights, ambient, default light, selected lights and all scene lights.</li>\n\
<li>A culling mode override. (<span class=\'code\'>MCullingOption</span>). None, front or back face culling for surface shaded objects.</li>\n\
<li>A clear operation override (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MClearOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_clear_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_clear_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MClearOperation</a></span>).</li>\n\
<li><p>A shader override (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MShaderInstance\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MShaderInstance</a></span>). For all surface shaded objects, the override can be set. <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MShaderInstance\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MShaderInstance</a></span>s also allow connections to be formed between operations by allowing for <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderTarget\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderTarget</a></span>s to be passed in as input. In this case, the target is being used for surface shading. An example of this could be for dynamic shadow or environment map rendering.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d01.jpg\' title=\'\' /></div>\n\
<p>Figure 46: The scene render’s rendering pipeline has been expanded to show how a render item sent down the pipeline can have its shader instance replaced with an external override. Also shown is the “flow” of render targets as either inputs or specified as the output target.</p></li>\n\
<li><p>Filtering by “shaded” vs. “non-shaded” (<span class=\'code\'>MSceneFilterOption</span>). Shaded is anything that requires shading or lighting. This includes filled drawing for all surface and volumetric shape types (polygonal surfaces, NURBS surfaces, subdivision surfaces, and fluids). Non-shaded includes non-filled/component drawing for all DAG objects, any 3d UI which are part of the Maya scene and any 3d UI which is temporary drawn. Items in this category include wireframe draw, locators, and manipulators respectively.</p>\n\
<p>Note that drawing for <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxDrawOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MPxDrawOverride</a></span> is considered to be shaded, whereas for custom render items returned from <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPxGeometryOverride\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MPxGeometryOverride</a></span>, this depends on the associated shader instance and geometry type.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d07.jpg\' title=\'\' /></div>\n\
<p>Figure 47: <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MSceneRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MSceneRender</a></span> operation and the possible overrides in addition to the base set of overrides on an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOperation</a></span> (clear, targets, camera override) which are shown without coloring. Light green boxes are constructs which are not classes.</p></li>\n\
</ul>\n\
<p>For per scene render preparation, pre and/or post render callbacks can also be specified.</p>\n\
<p>There is no limit on the number of scene operations that can be specified, though there is the inherent cost of rendering multiple types. Each invocation runs the rendering pipeline and thus it is possible to have multiple update and draw phases invoked. The main difference between the new and the old systems is that <em>multiple scene traversals are not invoked</em>, as this is no longer an inherent part of the pipeline logic.</p>\n\
<p>An example of a shaded versus non-shaded pipeline split is show in the following diagram. Each variation in an override can be used to create a different pipeline per scene operation.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d0d.jpg\' title=\'\' /></div>\n\
<p>Figure 48: The top-most pipeline is an example of what roughly occurs when there is no separation of “shaded” from “non-shaded”. The split into two pipeline configurations is shown below: a “shaded” only pipeline (middle) and a “non-shaded” pipeline (bottom).</p>\n\
<div class=\'section\'><a id=\"quad-render\"></a><h2 id=\"quad-render\">Quad Render</h2></div>\n\
<p>This is a pre-packaged render of a 2D screen aligned geometric quadrilateral. The construct to represent a quad render is <strong>MQuadRender</strong>.</p>\n\
<p>Depending on the shader and the viewport region specified, the operation can render to fill the entire render target or just part of it. A clear operation (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MClearOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_clear_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_clear_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MClearOperation</a></span>) can be returned from this operation for cases where sub-region rendering is required.</p>\n\
<p><span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MQuadRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MQuadRender</a></span> allows for the specification of state setters. By default, when rendering the geometry for a quad render operation, blending is disabled, depth write is disabled, and culling is disabled. Any of the following methods can be implemented by classes derived from <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MQuadRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MQuadRender</a></span> to replace the default behavior for a given state:</p>\n\
<ul>\n\
<li><span class=\'code\'>virtual const <a href=\"javascript:void(0)\" data-symbol=\"MDepthStencilState\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_stencil_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_depth_stencil_state.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MDepthStencilState</a>* depthStencilStateOverride()</span>; // Override depth-stencil state</li>\n\
<li><span class=\'code\'>virtual const <a href=\"javascript:void(0)\" data-symbol=\"MRasterizerState\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_rasterizer_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_rasterizer_state.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRasterizerState</a>* rastersizerStateOverride();</span> // Override rasterizer state</li>\n\
<li><span class=\'code\'>virtual const <a href=\"javascript:void(0)\" data-symbol=\"MBlendState\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_blend_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_blend_state.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MBlendState</a>* blendStateOverride();</span> // Override blend state</li>\n\
</ul>\n\
<p>This operation can be used to render into any of the render targets (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderTarget\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderTarget</a></span>) specified as output by writing the appropriate shader logic for the shader instance (MShaderInstance) associated with the quad operation. As the shader instance can also take, as input, a set of <span class=\'code\'>MRenderTargets</span>, a quad operation can form connections between operations via the use of shared targets.</p>\n\
<p>The following is the possible flow of render targets as source data and output data.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d19.jpg\' title=\'\' /></div>\n\
<p>Figure 49: The shader instance can take 0 or more targets as input. The shader can write out into 1 or more output targets.</p>\n\
<p>It is possible to render using a render target as both an input and as an output. Depending on device resource management a temporary target may be required. The inherent cost of this functionality should be weighed against any simplification or clarity gained by describing the render loop logic in this way.</p>\n\
<p>“Ping-ponging” of render targets (alternating targets) in general does not create temporary targets. This is due to the fact that the plug-in can explicitly specify different input and output targets to avoid conflicts. For example, a series of quad operations can alternate between using target T1 as a source and target T2 as a destination by writing T1 to T2, T2 to T1, T1 to T2, and so forth. See <a href=\'#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Render-Loop-Overrides.html#post-scene-render-color-operations\' title=\'\'>Post scene render color operations</a>.</p>\n\
<p>For quad rendering, a few basic semantics are provided to allow for automatic binding of parameters which can be used for quad rendering. This includes:</p>\n\
<ul>\n\
<li>Viewport pixel size: ViewportPixelSize. The pixel size is sometimes required.</li>\n\
<li>World view Projection matrix: WorldViewProjection. The matrix required in order for the quad to draw properly in screen space.</li>\n\
<li>Position and texture coordinates for the geometry of the quad which is automatically drawn by the framework.</li>\n\
</ul>\n\
<p>In general, as parameter binding is the responsibility of the operation, it can query the available parameters on the shader instance and bind as appropriate. For example render target binding is performed manually.</p>\n\
<p>Example of an invert operation (CgFx)</p>\n\
<div class=\"codeBlock\"><pre class=\"prettyprint\">// World-view-projection transformation.\n\
float4x4 gWVPXf : WorldViewProjection &lt; string UIWidget = &quot;None&quot;; &gt;;\n\
\n\
// The single filter input, i.e. the image to be manipulated.\n\
texture gInputTex : InputTexture\n\
&lt;\n\
    string UIName = &quot;Input Texture&quot;;\n\
&gt;;\n\
\n\
// Filter input sampler.\n\
sampler2D gInputSampler = sampler_state\n\
{\n\
    Texture = &lt;gInputTex&gt;;\n\
    MinFilter = Point;\n\
    MagFilter = Point;\n\
    MipFilter = Point;\n\
};\n\
\n\
// Vertex shader input structure.\n\
struct VS_INPUT\n\
{\n\
    float4 Pos : POSITION;\n\
    float3 UV : TEXCOORD0;\n\
};\n\
\n\
// Vertex shader output structure.\n\
struct VS_TO_PS\n\
{\n\
    float4 HPos : POSITION;\n\
    float3 UV : TEXCOORD0;\n\
};\n\
\n\
// Vertex shader.\n\
VS_TO_PS VS_Invert(VS_INPUT In)\n\
{\n\
    VS_TO_PS Out;\n\
    \n\
    // Transform the position from object space to clip space for output.\n\
    Out.HPos = mul(gWVPXf, In.Pos);\n\
    \n\
    // Pass the texture coordinates unchanged.\n\
    Out.UV = In.UV;\n\
    \n\
    return Out;\n\
}\n\
\n\
// Pixel shader.\n\
float4 PS_Invert (VS_TO_PS In) : COLOR0\n\
{\n\
    float4 output = tex2D(gInputSampler, In.UV);\n\
    return 1.0f - output;\n\
}\n\
\n\
// The main technique.\n\
technique Main\n\
{\n\
    pass p0\n\
    {\n\
        VertexProgram = compile glslv VS_Invert();\n\
        FragmentProgram  = compile glslf PS_Invert();\n\
    }\n\
}\n\
</pre></div><div class=\'section\'><a id=\"user-operation\"></a><h2 id=\"user-operation\">User Operation</h2></div>\n\
<p>Instead of having a fixed structure for pre and post pass callbacks, a <strong>user operation</strong> is exposed in the API. The API construct for this is <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MUserRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MUserRenderOperation</a></span>.</p>\n\
<p>The operation is most similar to <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MViewportRenderer\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_viewport_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MViewportRenderer</a></span> in the old system. The main difference is the level of integration. An <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MViewportRenderer\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_viewport_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MViewportRenderer</a></span> is an unstructured render override while a <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MUserRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MUserRenderOperation</a></span> is an action which is integrated into the render loop support structure.</p>\n\
<p>A <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MUserRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MUserRenderOperation</a></span> allows for a camera override to be specified, in addition to the viewport and render target overrides inherited from the parent <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOperation</a></span> class.</p>\n\
<p>When querying pass context information if a user operation is active then it&#39;s name will be the current pass identifier and the pass will be marked with a &quot;user pass&quot; semantic.</p>\n\
<p>There is one entry point which is exposed to &quot;execute&quot; the operation. In order to have some frame of reference a draw context (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDrawContext\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MDrawContext</a></span>) is provided.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d1f.jpg\' title=\'\' /></div>\n\
<p>Figure 50: The camera can be overridden for a user operation. At execution time, an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDrawContext\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MDrawContext</a></span> is provided. The output can be directed to one or more render targets.</p>\n\
<p>As with all plug-ins which affect draw state via direct API calls, the operation should always restore to the entry state. This is especially important in relation to the current output target(s). State such as the active OpenGL context, FBO, PBO should not be set within the operation, and if they ever are, then the previous values must be restored on exit from the operation.</p>\n\
<p>For example, calls such as <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"M3dView::beginGL()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html#a0e318e5634c7aaf31c4eb7232d2013d4&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m3d_view.html#a091f4d5c3cd36bdd6359020da45b6cd7&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">M3dView::beginGL()</a>/endGL()</span> should never be called since they set active OpenGL context. Also, they never run under DirectX or in batch mode.</p>\n\
<div class=\'section\'><a id=\"present-operation\"></a><h2 id=\"present-operation\">Present Operation</h2></div>\n\
<p>To present a render target for interactive viewing a <strong>present</strong> operation is provided. In the API this is represented by <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPresentTarget\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_present_target.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_present_target.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MPresentTarget</a></span>.</p>\n\
<p>This is roughly equivalent to a swap buffers call in OpenGL or a present of a SwapChain in DirectX.</p>\n\
<p>When batch rendering, this operation has no meaning and is automatically ignored.</p>\n\
<p>The operation can specify a color render target to be displayed. If none is specified, the active internally set color target is used. It is possible to optionally specify depth to be presented. If a depth target override is specified then the depth values from that target are copied to an onscreen depth target.</p>\n\
<p>When dealing with <em>active stereo rendering</em> the output can be directed to the left or right eye. The way to achieve this in the render loop is to present the contents of a render target to the left buffer&quot;, and the contents of a render target to the right buffer. Mono viewing, which is the default, is achieved by specifying rendering to the center buffer.</p>\n\
<p>If active stereo rendering is supported by the video card, and the driver has been appropriately set up, then the <span class=\'code\'>MTargetBackBuffer</span> input can be set to route targets for display as appropriate.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d25.jpg\' title=\'\' /></div>\n\
<p>Figure 51: The back-buffer option can be set to override the output buffer. The “present” operation routes the appropriate render target to the correct buffer on the “on screen target”.</p>\n\
<div class=\'section\'><a id=\"hud-render\"></a><h2 id=\"hud-render\">HUD Render</h2></div>\n\
<p>This operation allows for the display of the 2D HUD for a 3D viewport. In the API, this is represented by <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MHUDRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_h_u_d_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_h_u_d_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MHUDRender</a></span>.</p>\n\
<div class=\'section\'><a id=\"structure-summary\"></a><h2 id=\"structure-summary\">Structure Summary</h2></div>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d2b.jpg\' title=\'\' /></div>\n\
<p>Figure 52</p>\n\
<p>The above diagram shows the overall structure of all of the various operations and how various overrides and resources (shader instances, render targets) can be shared and reused.</p>\n\
<p>The connection from the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MShaderInstance\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MShaderInstance</a></span> to an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderItem\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderItem</a></span>, though not explicitly part of the render loop structures, shows the possible flow of data (render targets or textures) from the output of a render loop (pipeline) to the input for a render item flowing down another pipeline. An example of this is to provide shadow maps as an input to shaders which render an item with shadowing.</p>\n\
<div class=\'section\'><a id=\"override-setup-and-execution\"></a><h2 id=\"override-setup-and-execution\">Override Setup And execution</h2></div>\n\
<p>With a basic understanding of the available operations, this section shows how a plug-in should set up the override to ensure proper configuration and execution of these operations.</p>\n\
<p>The term <strong>phase</strong> introduced when discussing the rendering pipeline is reused here to describe the key functionalities of a plug-in. The basic phases are: <strong>setup</strong>, <strong>execution</strong> and <strong>cleanup</strong>.</p>\n\
<p>During the <strong>setup</strong> phase:</p>\n\
<ul>\n\
<li><span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MRenderOverride::setup()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html#a773d1f1082e711c8d4cf216d32b07fe4&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html#aafa1bdf70c0e23993b38a51bc81d556b&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRenderOverride::setup()</a></span> is called.</li>\n\
<li>Regardless of the render loop, the logic needs to be translated into a list of operations. This is not defining the logic but rather preparing the appropriate operations. Generally all operations can be statically allocated once and reused across frames, though it is possible to allocate and return operations dynamically during the execution phase.</li>\n\
<li>Any data which should be persistent across the frame render (global to all operations) should be evaluated at this time.</li>\n\
<li>All texture and target allocation needs to be done at this phase. This includes handling any resize of custom render targets. Generally, all textures and targets can be statically pre-allocated once and updated as required.</li>\n\
<li>Shader instance allocation needs to be done at this phase. Parameter updates can be done at this phase or when the shader instance is updated for an operation. Generally, all shaders can be statically pre-allocated once and reused as required.</li>\n\
<li>In general, any DG or DAG updates should only be performed in this phase. This includes determining selection lists for scene filtering, determining which camera(s) to use and so forth. As the override is being performed within a frame render, actions like DG time change should not be performed, but instead should be triggered at a higher level.</li>\n\
<li>For interactive 3d viewport rendering, any access to classes such as <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"M3dView\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m3d_view.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">M3dView</a></span> should all be done at this phase. The required information should be extracted and passed to operations a necessary.</li>\n\
</ul>\n\
<p>During the <strong>execution</strong> phase:</p>\n\
<ul>\n\
<li>A set of methods are called on the override to iterate and return the operations which should be called in sequence. (<span class=\'code\'>startOperationIterator()</span>, <span class=\'code\'>renderOperation()</span>, <span class=\'code\'>nextRenderOperation()</span>). This provides the framework with knowledge to set up the appropriate pipelines to be executed. There are an unlimited number of possible configurations with various levels of complexity. It is up to the plug-in code to determine which operations should be returned here. As an example, stereo rendering is supported as a plug-in, and the logic is setup to allow for different configurations to be performed based on stereo display mode.</li>\n\
<li>Once this operations list is specified, operations cannot be created nor deleted until they have finished executing.</li>\n\
<li>Each operation is called independently and in the sequence specified by the plug-in. If a custom derivation has been created, then virtual overrides are called to query for data required at the time the operation executes.</li>\n\
<li>Some operations require shader instances to be returned. If the parameters on the shader instance need to setup per operation invocation, the update should be done here.</li>\n\
<li>As operations are independent, co-dependent data should be avoided if possible. In addition, one operation should avoid modifying another operation while it is being executed.</li>\n\
</ul>\n\
<p>During the <strong>cleanup</strong> phase:</p>\n\
<ul>\n\
<li>Any temporary per-frame references should be released or reset here. For example, any selection list, DAG paths or node references should be reset.</li>\n\
<li>A good practice is to reset operations to their default state which also clears out any external references.</li>\n\
</ul>\n\
<p>Instances of render overrides and operations have no implicit resources themselves, but instead only keep references to external resources. It is the responsibility of the plug-in to determine the life-time for these resources. It is best to use the available resource managers if possible. As long as the plug-in holds on to a reference to a resource, it remains allocated. Resources which are passed back to an operation (for example through an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDrawContext\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MDrawContext</a></span>) should never be held on to as it could be a resource which only exists during the lifetime that the operation is being executed.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d31.jpg\' title=\'\' /></div>\n\
<p>Figure 53: A high level breakdown of the override “phases”: up-front data evaluation and update, execution time logic definition and operation invocation, and the final cleanup. One or more pipelines may be setup and updates to operations can represent changes to operation data dependencies. For example, the render target used by a shader instance parameter can change during execution time.</p>\n\
<div class=\'section\'><a id=\"render-override-examples\"></a><h2 id=\"render-override-examples\">Render Override Examples</h2></div>\n\
<p>In this section, a few example operation configurations are described.</p>\n\
<div class=\'section\'><a id=\"post-scene-render-color-effect\"></a><h3 id=\"post-scene-render-color-effect\">Post scene render color effect</h3></div>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d37.jpg\' title=\'\' /></div>\n\
<p>Figure 54</p>\n\
<p>This example shows a basic scene render into depth and color output targets. The second operation applies a color effect (for example, “posterize”) to the color target from the first operation and writes back into the same target. This is similar to allowing reading and writing to the same color target. The implementation can follow the example above; or, a second color target can be acquired and used as the destination for the color effect, or a color target can be not specified at all. In the latter case, the active internal color target is used.</p>\n\
<div class=\'section\'><a id=\"glow-example\"></a><h3 id=\"glow-example\">Glow example</h3></div>\n\
<p>A more complex configuration which is used to support a “glow” post effect is part of the <em>viewRenderOverride</em> SDK sample.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/API_white_paper_section3_8_10_fig55.png\' title=\'\' /></div>\n\
<p>Figure 55: In this example, the threshold of the original scene render is based on an intensity value. The result is blurred using a 2-pass filter and then combined with the original image to provide a very rudimentary “glow” effect. The user interface elements are drawn last. The original depth buffer is used to provide proper UI and non-UI element compositing.</p>\n\
<div class=\'section\'><a id=\"stereo-rendering\"></a><h3 id=\"stereo-rendering\">Stereo rendering</h3></div>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d3d.jpg\' title=\'\' /></div>\n\
<p>Figure 56</p>\n\
<p>This is an example from the plug-in which is used to support stereo display. On the left are two scene renders which are the first two operations. Each scene render uses different camera overrides to render from the left and right eye (camera). The output is passed to two color targets in order to perform a final composite based on two color inputs. The depth target is reused as the final contents are not required. At the top right a quad render operation is specified as the next operation in order to support Anaglyph passive stereo display. Different shaders can be returned dynamically for the quad operation, depending on the required final passive stereo display mode. Active stereo is shown at the bottom right. It would be an alternative operation configuration that passes the left and right color targets to the left and right onscreen buffers respectively.</p>\n\
<p>The Maya stereo plug-in implements this design.</p>\n\
<div class=\'section\'><a id=\"beauty-pass-color-composite\"></a><h3 id=\"beauty-pass-color-composite\">Beauty pass color composite</h3></div>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d43.jpg\' title=\'\' /></div>\n\
<p>Figure 57</p>\n\
<p>This example shows how an external renderer, which only generates color images as output, can be composited with the rest of the scene rendered using the internal framework.</p>\n\
<p>There are three basic operations performed:</p>\n\
<ol>\n\
<li>The first (left) <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MSceneRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MSceneRender</a></span> prepares the depth buffer with depth values based on shaded objects in the scene. The display mode is set to be shaded and the scene filter is set to only draw shaded items. There are a few choices for the shader used. Either a custom depth shader can be applied; or, as shown in this case, a solid color shader using an ambient light can be used. The color mask is set to only write to a depth target.</li>\n\
<li>The next operation (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MUserRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MUserRenderOperation</a></span>) is used to blit the external renderers color image only to the color target.</li>\n\
<li>The last operation (right) <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MSceneRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MSceneRender</a></span> is responsible for overlaying the non-shaded scene elements. Here, only the active Maya objects are rendered. No targets are cleared but depth testing is still enabled to support proper shaded versus non-shaded scene compositing (for example, “wireframe-on-shaded”).</li>\n\
</ol>\n\
<div class=\'section\'><a id=\"multiple-render-targets\"></a><h3 id=\"multiple-render-targets\">Multiple render targets</h3></div>\n\
<div class=\'figure\'><img src=\'dev_help/images/API_white_paper_section3_8_10_fig58.png\' title=\'\' /></div>\n\
<p>Figure 58</p>\n\
<p>A simple example of multiple color target usage is found in the <em>viewRenderOverrideMRT</em> sample plug-in. Here, a single scene render uses a shader override to output position and normal values to two different color targets at the same time. To visualize the results, an additional quad render option takes the two targets as input into a shader which blits the two target contents side-by-side. The result of the quad render operation is written to one of the two existing color targets. A “present” operation is then used for displaying to the viewport (not shown above).</p>\n\
<div class=\'section\'><a id=\"depth-and-color-render-compositing\"></a><h3 id=\"depth-and-color-render-compositing\">Depth and color render compositing</h3></div>\n\
<p>In the case where an external renderer is used, and directly rendering into existing targets is not desired (or not possible), the recommended approach is to render to an intermediate target or texture.</p>\n\
<p>These intermediaries can be then blit to the final targets used for display. Once this is done, as long as depth has been properly prepared, any additional UI elements that the external renderer does not handle can be composited.</p>\n\
<p>The following are rendered images for a Maya scene. Shown is the final color (beauty) image as well as the corresponding depth image (remapped to 0..1 grey scale from the original values).</p>\n\
<div class=\'figure\'><img src=\'dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/images/API_white_paper_section2_4_fig30_color_depth.png\' title=\'\' /></div>\n\
<p>Figure 59</p>\n\
<p>The simple pipeline found in the sample <em>viewImageBlitOverride</em> plug-in is shown in the diagram below:</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/API_white_paper_section3_8_10_fig60.png\' title=\'\' /></div>\n\
<p>Figure 60</p>\n\
<p>The rendered images are taken and read as color and depth textures accordingly. A single quad render uses a shader to blit the textures to the color and depth targets. After this is done, a scene render is used to optionally depth composite the “UI” elements. Here, the clear is disabled, and a filter applied to ignore shaded render items.</p>\n\
<p>Assuming that the original scene used to create the render is loaded into Maya, the result could look as follows. The wireframe and IK rendering are all done by the scene render pass.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/API_white_paper_section3_8_10_fig61.png\' title=\'\' /></div>\n\
<p>Figure 61</p>\n\
<p>The <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MQuadRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MQuadRender</a></span> operation uses a state setter override. By default, when rendering the geometry for a quad render, alpha blending, depth-write, and back-face culling are all disabled. Any of the following methods can be implemented by classes derived from <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MQuadRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MQuadRender</a></span> to replace the default behavior for a given state:</p>\n\
<ul>\n\
<li><span class=\'code\'>virtual const <a href=\"javascript:void(0)\" data-symbol=\"MDepthStencilState\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_stencil_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_depth_stencil_state.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MDepthStencilState</a>* depthStencilStateOverride(); // Override depth-stencil state</span></li>\n\
<li><span class=\'code\'>virtual const <a href=\"javascript:void(0)\" data-symbol=\"MRasterizerState\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_rasterizer_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_rasterizer_state.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MRasterizerState</a>* rastersizerStateOverride(); // Override rasterizer state</span></li>\n\
<li><span class=\'code\'>virtual const <a href=\"javascript:void(0)\" data-symbol=\"MBlendState\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_blend_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_blend_state.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MBlendState</a>* blendStateOverride(); // Override blend state</span></li>\n\
</ul>\n\
<p>In this example, a depth stencil state instance was created which enables depth-write, and sets the depth compare to be “Always”. The instance is then returned by overriding the <span class=\'code\'>depthStencilStateOverride()</span> method.</p>\n\
<p>Another possibility (not show in the plug-in example) is to add an additional scene render for non-UI objects that the renderer does not render. Basic filtering by object type can be used. For example, plug-in objects may not be handled by the renderer, in which case they can be composited in another pass. The level of integration of compositing may vary.</p>\n\
<p>In general, an integration that renders both color and depth does not integrate with internal hardware post-effects such as screen-space ambient occlusion. Any operation that only draws UI does not have post-effects enabled. Additional non-UI scene renders can disable post-effects as part of the operation.</p>\n\
<div class=\'section\'><a id=\"user-operation-with-device-access\"></a><h2 id=\"user-operation-with-device-access\">User operation with device access</h2></div>\n\
<p>This is a simple configuration from a render loop logic perspective. Its logic is closest to the free-form <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MViewportRenderer\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_viewport_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MViewportRenderer</a></span> implementation from the old system. There is only one <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MUserRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MUserRenderOperation</a></span>. The SDK example viewDX11DeviceAccess shows how various resources can be allocated from the framework and how GPU handles to the render targets and texture (shader resource views), state blocks, sampler states can be extracted. The older <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDrawTraversal\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_traversal.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MDrawTraversal</a></span> interface is used to scan the entire scene to draw some bounding boxes.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/aa0f8d49.jpg\' title=\'\' /></div>\n\
<p>Figure 62: In the setup phase the GPU device handle is extracted to create some stock DX geometry. A texture and a sampler state are allocated via the appropriate manager in the framework. An output target is also allocated. During the execution phase, a series of steps is performed to get the GPU handles of resources and rendering is all done using native DX calls.</p>\n\
<div class=\'section\'><a id=\"render-target-frame-caching\"></a><h2 id=\"render-target-frame-caching\">Render target / frame caching</h2></div>\n\
<p>It is sometimes desirable to cache or save rendered frames. For example, you can store frames on disk for the playback of an animation or for manipulation in another application. The example in this section shows how a render override can be used to cache viewport frames in memory for faster playback.</p>\n\
<p>The following figure shows the complete set of actions in a system which can either cache frames or playback cached frames. Each color coded area represents a logical sub-set of available actions. Resources are colored in green.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/API_white_paper_3_8_12_Figure63.png\' title=\'\' /></div>\n\
<p>Figure 63: Diagram illustrating the following: regular refresh (blue boxes), a frame cache (green boxes), and render pipeline operations that perform either caching (red boxes), or scene render replacement in playback (yellow boxes). The present operation is shown as a possible final viewing output. Output could also be serialized to disk. Outputs are represented in grey boxes.</p>\n\
<p>During an animation playback, the scene is rendered to the viewport for each time step. The two operations are represented by blue boxes: an <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MSceneRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MSceneRender</a></span> to render the scene into a color render target and a <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPresentTarget\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_present_target.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_present_target.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MPresentTarget</a></span> to display the color target in the viewport. The render target contents are only valid at the current time. Whenever the current time changes, new content must be drawn to the target.</p>\n\
<p>To avoid this redraw, the contents can be cached. In the diagram, we show a simple cache where each cache element references a hardware texture (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MTexture\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MTexture</a></span>) and a frame time (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MTime\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_time.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_time.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MTime</a></span>). Each of these elements could be serialized to disk.</p>\n\
<p>With this structure, a <em>snapshot</em> (or copy) of the render target can be taken at the desired time frames. In this implementation, a user operation (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MUserRenderOperation\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MUserRenderOperation</a></span>, shown in red) executes after the scene render. The operation makes a hardware copy of the render target to a texture (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MTexture\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MTexture</a></span>). The convenience method <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MDrawContext::copyCurrentColorRenderTargetToTexture()\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html#a98d740fa86e12f8604d12d89e503db75&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html#a65c712b9f5cc28262e0760912e2221d3&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MDrawContext::copyCurrentColorRenderTargetToTexture()</a></span> is used in the implementation to produce this cached texture. You can also perform this copy within the post render (<span class=\'code\'>postRender()</span>) method on the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MSceneRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MSceneRender</a></span>.</p>\n\
<p>The caching operation flow of data is shown via the links labelled <em>Cache</em>.</p>\n\
<p>To stop re-rendering the scene during playback, the scene render operation is replaced by a quad render operation (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MQuadRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MQuadRender</a></span>, shown in yellow). This operation determines if a frame (texture) has been cached for a given time frame. If one is found, then it draws that texture back to the color render target. The present operation can still be executed as before. The playback flow of data is shown via the links labelled <em>Playback.</em></p>\n\
<p>The code for this example can be found in the <em>viewRenderOverrideFrameCache</em> SDK example in the Developer Kit.</p>\n\
<div class=\'section\'><a id=\"multiple-pass-scene-rendering\"></a><h2 id=\"multiple-pass-scene-rendering\">Multiple Pass Scene Rendering</h2></div>\n\
<p>The following example demonstrates how the multiple <em>draw</em> interface (found in the <span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MPx3dModelView\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_px3d_model_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MPx3dModelView</a></span> class in the Legacy Default Viewport only) can be performed in Viewport 2.0 using a render override.</p>\n\
<p>In this example, instead of a <em>draw</em>, a scene operation can be executed. In this case two scene operations are shown.</p>\n\
<div class=\'figure\'><img src=\'dev_help/images/API_white_paper_section_3_8_13_fig64.png\' title=\'\' /></div>\n\
<p>Figure 64: Operations that are implemented in the plug-in are shown in green. The <em>present</em> operation (in lighter green) is optional. To override the clear and object set methods, a new class is derived with different return parameters for each method depending on the desired execution sequence and filter options.</p>\n\
<p>The first scene operation clears the background via the <span class=\'code\'>clearOperation()</span> method’s return value. If a subset of objects is to be drawn, then the <span class=\'code\'>objectSetOverride()</span> method returns an appropriate value.</p>\n\
<p>The second scene operation (shown below the first in the diagram) indicates not to clear the background. This allows for drawing to be cumulative.</p>\n\
<p>The final operation that can optionally be executed is a <em>present</em> operation. This step is needed if presenting the results to the active interactive viewport.</p>\n\
<p>Internal Targets indicates that rendering is drawn to the current internal color and depth targets, and is the source target for presentation.</p>\n\
<p>The Developer Kit example <em>viewObjectSetOverride</em> provides the source code that implements this scenario. The example queries the contents of two Maya sets. The first scene operation renders a first set, and the second scene operation a second set.</p>\n\
<div class=\'section\'><a id=\"post-scene-render-color-operations\"></a><h2 id=\"post-scene-render-color-operations\">Post scene render color operations</h2></div>\n\
<div class=\'figure\'><img src=\'dev_help/images/RenderLoopOverrides_PostSceneRenderColorOps.png\' title=\'\' /></div>\n\
<p>Figure 65</p>\n\
<p>This example shows how a series of 2D color operations can be performed after a scene render. Refer to the <em>viewRenderOverridePostColor</em> developer kit example for more details.</p>\n\
<p>In this plug-in example, there are three 2D quad operations (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MQuadRender\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MQuadRender</a></span>), each using a different shader (<span class=\'code\'><a href=\"javascript:void(0)\" data-symbol=\"MShaderInstance\" class=\"a_multireflink\" data-reflinkdata=\"[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]\">MShaderInstance</a></span>). The scene render is stored in a custom target (labeled <em>Target 1</em> in this figure). This target is used as input to a second target (labeled <em>Target 2</em>). The next color operation takes Target 2 as input and route it to Target 1. Subsequent color operations will alternate between using Target 1 as the source and Target 2 as the destination targets by writing Target 1 to Target 2, then Target 2 to Target 1 and so forth.</p>\n\
<p>After the color operations are performed, the HUD is drawn using a HUD operation, and a present operation presents the output target used by the last color operation.</p>\n\
<p>The associated image shows only the quad operations with the shaders <em>Fish-Eye</em> and <em>Edge-detect</em> enabled.</p>\n\
      <div class=\"footer-block\"><a href=\"../html/ac.cmtdialog.htm\" class=\"comments-anchor\" target=\"_blank\"><span class=\"comments-link\">Please send us your comment about this page</span></a></div></div>\n\
   </div></body>\n\
</html>\n\
";