---
layout: post
title: 数学和算法知识笔记
date: 2020-11-07 10:09:29.00 +08:00
categories: 学习
tags: 笔记
comments: false
---



随着会的东西越来越多,以前一些觉得做不到的东西都能想到可行办法,或者找到其中规律了.

但是受限于学历和知识水平,很多方法和计算无法开展.力所能及的部分,稍微在网上搜索学习一下.其实有些东西很简单,只是没有人细心解释那个专业术语的简称,或是没有得到更可视化的学习方式来帮助理解罢了.

## 数学

方程和函数都是一组用字母\数字\符号组成的特定算式,我感觉他们的核心是同本同宗的.只不过函数存在变量,方程是固定结果.

### 方程

方程得有未知数, **元**(元素): 一个元,是一个未知数,比如:**x**=0,是一元,**x**+**y**=0是二元,x+**y**+**z**=0是三元.....

这个或这几个位置数可能是带指数的.**次**(次幂):函数中最高次方的元的次方数,比如:**x**^3^ = 1

### 函数

最简单的函数: **y = x** ,她的效果是 **x = 1** 时 **y = 1**, **x = 2** 时 **y = 2**, **x = 3** 时 **y = 3** ...

比最简单,稍微厉害一点点的函数: **y = x^2^** ,她的效果是 **x = 1** 时 **y = 1**, **x = 2** 时 **y = 4**, **x = 3** 时 **y = 9** ...

再厉害一点点的函数: **y = 2x^2^ + x + 2**  ,她的效果是 **x = 1** 时 **y = 5**, **x = 2** 时 **y = 12**, **x = 3** 时 **y = 23** ...

接着就是不断的加次数了,**y = 4x^3^ +  9x^2^ + x + 2** ,**y = 2x^4^ + 4x^3^ +  9x^2^ + x + 2**...啥的.因为函数不断精简后,只有各个不同次数(**不同指数**,不同次幂,不同次方)的x和其**系数**被保留了下来.(系数,比如2x,就是两个x呗,这里的2就是系数,默认情况下可以是任何数,比如0.5x,系数是0.5. 12x,系数是12,-x,系数是-1.....)

仔细看看上面那些越来越厉害的函数.要说有什么规律的话,其实这些函数都是**某个数量的x的几个次幂相加的和**.最重要的还是系数.就算是 2x^2^ + **b** 最尾巴的那个**b**,其实也不过是 **bx^0^**,任何数的**0次幂**都是**1**嘛,所以简写成了**b**.(真够鸡贼的,哈哈哈,当年上这堂课的时候我好像睡觉了没学到,前几天遇见了*拟合*(不用查,写在下面的"更多"里了)的时候才发现的.我发现知道了这个规律后,函数写的再复杂也不迷糊了啊.这是多年前擦肩而过那个她啊.我的天呐~)

y = x可以写成 y = f(x),画在二维空间中,就是一条斜着的直线.

恼火的是, y = 2x^2^ + 6x + 7, 也写成 f(x), 只是"f()"代表的式子(算式)不同了.

其他的还有f(x+1)或者f(x,y,z),由此发现,f()是表示函数本身,括号内的东西是变量.f(xxxxx)这一坨东西,是两坨东西的组合.尤其是f(),这不是一个东西,他背后特么的承载了一大坨东西.

### 平面直角坐标系

上学的时候,觉得平面直角坐标系她就只是个毫无实际意义的图像,枯燥又乏味,麻烦又无用,明明可以简单画一下的东西,非要整这么大个阵仗,还只能得到点和线,还不如画个王八有意思.

后来对她有了应用,发现这其实应该是当时阶段最有趣的知识了.

平面直角坐标系,其实是一个**二维空间**啊! 只要有一个**0点**和**两个互相垂直的轴**,你就可以在这个二维空间里愉快的玩耍了.

二维空间其实就是在玩点(坐标).

>  不管几维,都是在玩点(玩坐标),要么是移动点的位置,要么是用点的位置排列来画线,要么按某个点的旋转,重新计算其他点的位置啥的....

比如在一个末日游戏中,你控制的生存者在[10,35],僵尸在[5,-3],如果电脑要计算僵尸在横纵轴各移动多少去攻击你,它只要用[10,35]减去[5,-3]就完了,如果你想计算僵尸[5,-3]是不是在你的武器射程内,可以用家喻户晓的 **直角三角形勾股定理** 算出距离呀(斜边长即是距离!)

关键是:学会了这个,以后二维世界有什么图形问题,就不用拿尺子一点一点的比量着画出来了,全是自动出结果,而且还绝对准确没有误差,比自己手动画的不知道精准几百倍.

然后是我发现的关于各种坐标系的一些规律.

> **0点**是给你参照相对位置的,**必须得有**!没有0就不知道1在哪里.
>
> **两个互相垂直的轴**是用来标记相对位置的,**也必须得有**!
>
> 这两个垂直的轴,是你自己画出来参考用的,就是两个带刻度的参考线,画成什么样字你大可以自己做主.而且,其实两个轴不垂直也行,只是不垂直的话,特别特别难计算,也不好理解,何必呢?
>
> 一个轴?一个轴那就是一维空间呗! 三个轴就三维空间, 四个就四维....
>
> **四个互相垂直的轴!**很难理解吧.四维有什么用呢.比如你的身高、体重、年龄、学历都放到四维坐标系的一个轴上,你就基于这些数据成了一个四维空间点.再把我的参数放进思维空间.就能用勾股定理求咱俩的属性距离了!(距离就是这些属性的整体相似度,距离近的话,咱俩可能就会在APP里收到同样的职位的招聘信息.)
>
> 强烈建议 **平面直角坐标系** 改名为 **二维空间参照系** 呀,哈哈哈

(哈哈.忽然想起小时候老师教ax^2^+bx+c的时候(刚查了一下,叫二次函数),给了几个值让大家画出几个点,然后连接起来.我很快算了五个点,然后用直线连接了一下.我记得自己当时是第一个交的,交给老师后,老师却说要用曲线连接.我很不理解嘛,就问老师为什么.清晰的记得老师和我说的是,"用曲线连接更好看",哈哈哈哈,老师还在黑板上补充了一下,要求后面的同学都用曲线连接算出的点,后来好像也说了"这样也更真实"这样的话.不过我当时的智商和知识背景完全没有条件理解这其中蕴含的信息.时隔多年,好像都退伍回来几年了,我才知道,当你按照算式不断的画点,画的越多,就越接近曲线,当你按照算式画出无数个点时,他们的排列自然是一条曲线.这就是函数的魅力所在.)

#### 拟合

已知自变量和因变量求函数,叫**拟合**(曲线拟合,多项式拟合)

比如当 x = 0 时, y = 0; x = 1 时, y = 3; x = 2 时 y = 18 ,求f(x)的表达式.(结果化简后:6x^2^ - 3x......我不会求,先编的答案,后编的题...很多时候化简后很难理解,但是可以显著减少程序计算次数,)

**Python的numpy库**可以简单的计算拟合得出结果,可以不用知道为什么,直接拿来用.(原理好像叫最小二乘法.稍微知道就行了,先用着.)

要注意的是,拟合是允许误差的,结果只是近似,因为当点的随机性很强的时候,无法匹配所有结果,但这正是拟合的优点--不论多么无关的随机值,咱都能得出一条近似的曲线来描述.

其次,选取最适合的多项式次数是最重要的.比如:一次:ax+b,二次:ax^2^+bx+c:三次ax^3^+bx^2^+cx+d:四次ax^4^+bx^3^+cx^2^+dx+e.....(拟合的过程就是把各个系数计算出来.)

不过并不是哪一个次数的多项式就更好,这里只有最合适没有最好,有可能你就是想要直接的直线表达来概括数据,有可能你想尽量贴合散点来描述变化.(如图,配图来自知乎)

![1~4次多项式的拟合结果]({{site.img}}14次多项式的拟合结果.jpg)

我不清楚这几个次数的区别,但是实际看来,一次多项式绘制的曲线是个直线,二次绘制的可以拐一个弯,三次能拐两个弯,四次三个弯.....

还有个有用的更牛的应用叫 **平面拟合**,空间离散点拟合成空间平面,(这个是我想在空间中通过一些点的选择,配合二维凸包算法生成一个面,然后根据这个面的法线创建一个坐标轴的时候发现的,不过一直没去实现.写到这里,加上之前的一些经验,我发现在游戏开发上,二维就是简化版的三维,二维能做的,三维都能实现,只是三维更复杂一些.想研究三维可以先从二维入手,三维不过是二维plus,开发过二维游戏,就会觉得三维游戏无非是一些算法稍微复杂了一些.(尤其是旋转))

![20160417211137718]({{site.img}}20160417211137718.png)

拟合还有个标记是**r**,具体怎么回事不知道,也没细查,计算中怎么得出也不知道,不过这个值越接近1,结果误差就越小.不过经常出现好多9,建议用1减去r,比较容易知道是不是可以将误差忽略不计.比如: 1 - r = 0.00000190733

#### 矢量

矢量真是太**简单了.矢量就是有方向的量,有的放矢的矢!像箭矢一样射出去的量啊!

比如[1,1],只考虑他本身的话,就**是个坐标.

但是这个[1,1]是相对0点的坐标呀.所以把[1,1]和[0,0]考虑在一起的话,就有了两个点,形成了一条从[0,0]开始画出的线段.相当于一个弓箭手站在[0,0]点拉弓蓄力,朝[1,1]射了一箭,这根箭就有了方向!

至于为什么是[0,0]开始?因为[0,0]是相对来说固定不变的,坐标系也是以他为基本的,所有的矢量(坐标)也都是以他为参照的.

然后[0,0]为什么不能作为矢量,因为[0,0]到[0,0]就是两个叠在一起的点,相当于一个点,既可以说他作为矢量没有意义,又可以说他作为矢量有无限多个方向,这可就没法玩了(其实[0,0]也可以是矢量,就是让他加进来就不好玩了.弓箭手可以射自己一箭,但是他拒绝了.(其实是人们,或者我自己,还没搞清[0,0]的特殊意义))

### 三角

**任意三角形面积公式:**

1. 底乘高的一半: $\frac {c*h}{2}$, $c * h/2$ 或者: $h * c/2$ ,$h$和$c$加不加括号效果一样的.简写成: $0.5hc$.
	
	其中 $c=底;h=高$ ;任意三角形都有高,这条高甚至可能在三角形之外,计算时,采用的是互相垂直的底和高.(因为三角形相当于半个长方体)
	
2. 海伦公式: $\sqrt {p(p-a)(p-b)(p-c)}$
	
	其中标记$p = \frac {a+b+c}{2}$,$a+b+c$ 其实就是周长,p就是周长的一半.


### 基础

#### 负数

负数是现实生活中看不见摸不着的存在.,正数可以拿一个苹果,两个苹果,三个苹果...来举例,但因为实物不可能小于0,所以负数只有当东西不够了,或者出现负债的时候才能体现出来.比如

#### 加法,减法

加法:加法是最基本的计数计算法, 简单的加法以1为根本,从1+1= 2推演出各种加法,比如1+3= 1+(1+2) = 1+(1+(1+1)).只要像数数一样去加他们就行了,但是因为太简单了,所以大家都是好几位的不同数字直接计算,比如 101+ 99 = 200 .

减法:在知道了加法之后,减法就很简单了,以1为根本的话,则是以1-1=0为基础推演,不过要有符号的概念,1-1 = 1+(-1) . 比加法多一点的是比如 3-2 = (1+1+1)-(1+1) = 1+1+1-1-1 ,划掉等于0的部分 1~~+1+1-1-1~~ ,只剩 1

多位数加减法要有进位的概念,比如89+11=100

#### 进制

数是有进制的,通常使用的是十进制 就是满十进一,用0占位,比如$0+1=1,1+1=2...9+1=10,10+1=11$ 

其他比较常见的,比如2进制的,满二进一,举例$0+1=1,1+1=10,10+1=11,11+1=100$

#### 乘法,除法

普通乘法,我理解为反复相加的方法(辗转相加法),"乘"是不断上升的意思. 比如$5×4$ ,就是$5$反复相加$4$次, 即 $5+5+5+5 = 20$.

整式的乘法十分丰富,但实际计算和普通乘法没什么区别. 最简单的是 $10×(1+2-3)$, 可以换成 $(10×1+10×2-10×3)$,其他的整式乘法也由此演变.

同理,除法就是"辗转相减法",得数是减到余数小于除数的次数.比如$100÷50 = 100-50余50-50余0$.不过后来大家有了小数.余数就不太常见了.

乘法和除法可以互换,比如 $1÷2=1×0.5$

#### 被除数,除数

比如 24 ÷ 8 = 3 ,24是被除数,8是除数. 

"除"这个字的含义,基本上就是反复减,得数就是最多可以反复减的次数.相当于"把24按8反复减3次可减干净(除尽)","变成被字句就是24被8反复减3次可减干净", 故24是被除的数,即**被除数**,8是用来除的数,即**除数**. 

0不能作为除数,主要是没法除0,除得的结果也用不了(能除无限个0?),更没法还原计算(因为将得数乘以0时,0乘任何数都是0,无法满足原除式).

(相对的,"乘",基本上就是反复加的意思)

#### 相反数

一个数乘以-1就得到相反数,两个和为0的数互为相反数,(绝对值相等,正负号相反的两个数),相反数都是成对的.比如 +2和-2, 0 和 0. 

####  倒数

1除以一个数就得到倒数,两个数乘积为1则互为倒数

## 算法

### 随机分布

我给自己出了10道有生之年我解不开的题,在学习过程中,我发现这些问题可能有一些其他名词,比如 包装问题,几何堆积问题,关数值装箱问题,背包问题

在100*100的范围内随机放置10个物体的不同难度和思考的逻辑(伪代码).

#### 1.100x100浮点范围内随机放置10个物体,或100x100x100浮点范围内随机放置10个物体

```
1. 2D
循环开始(循环10次):
	位置xy = (随机(-50.0,50.0), 随机(-50.0,50.0))
	放置方块(位置xy)
循环结束
```

```
2. 3D
循环开始(循环10次):
	位置xyz = (随机(-50,50.0), 随机(-50.0,50.0), 随机(-50.0,50.0))
	放置方块(位置xyz)
循环结束
```

```
不算. 
代码里的-50到50的随机,一开始写错成了0到100,虽然加一个对半的偏移也不是不行,但是为了后面便于理解也为了和后面统一,还是改一下.往回整体改了一遍,看到2,刚好想到了一种可以只在对角生成随机位置的方法,特别好,就记到这一下:
循环开始(循环10次):
	单位 = 随机(-50,50.0)
	位置xyz = (单位, 单位, 单位)
	放置方块(位置xyz)
循环结束
简直太好了!
```

#### 2.100x100浮点范围内随机放置10个物体,但中心2x2浮点范围内不放置(不包括2)

```
1. 删除法,简单粗暴,但速度看运气
成功数量 = 0
判断循环开始 ( 成功数量 < 10 则 一直循环):
	如果 按下ESC:
		结束循环 #/--加这一句,是血的教训.
	位置x = 随机(-50.0,50.0)
	位置y = 随机(-50.0,50.0)
	位置xy = (位置x,位置y)
	如果 位置x < -2 and x > 2 and 位置y < -2 and y > 2:
		继续循环 #/--直接开始下次循环
	放置方块(位置xy) #/--通过了上边的判断
	成功数量+=1
```

```
2. 分区法,只适合方形区域,更多的准备工作
除了中心区域,其他地方都切成方块,然后计算随机到哪一块.(如果分的不平均的话,要加一个权重.正方形的话,多少个面就有多少个区域)
实现起来太闹心,略.
2号想法其实不现实,但扩充了思路,引出了下面的3和4.
```

```
3. 阵列排除法,不是完全随机,很占内存,速度取决于精度
--做出一个足够细小的阵列点,作为可放置的位置列表.
精度 = 0.1
位置列表 = []
计次循环 x= -50 到 50 每 0.1:
	如果 (x>2 或 x<-2) 则:
		计次循环 y= 0 到 100:
            如果 (y>2 或 x<-2) 则 位置列表.添加(x,y)
计次循环 i= 1 到 10:
	放置方块(位置列表[随机(1, 位置列表.长度)])
3.2 或者可以优化成
精度 = 0.1
位置列表 = []
计次循环 x= 1 到 50 每 0.1:
		计次循环 y= 1 到 50:
            位置列表.添加(x,y)
            位置列表.添加(x,-y)
            位置列表.添加(-x,y)
            位置列表.添加(-x,-y)
从位置列表中删除在排除范围内的位置()
计次循环 i= 1 到 10:
	放置方块(随机(位置列表))
```

```
4.公约数体素
这部分已经删除了两天的测试1000+字
最后得出,因为分布范围和排除范围都是方体,所以可以用最大公约数当作上边的算法的精度.

实际测试的时候发现没这么简单,约数结果是单数或者双数,需要不同的计算方式.最好的过程是将所有公约数结果都生成为单数的,但强制转换为单数的话,结果又会大概率接近最小数,比如10的话,大概率约到1,0.9999的话,大概率约到0.0001,得不偿失.
```

试过方法4之后,忽然觉得随机这种东西,有些情况里即使不那么随机,看起来也是挺随机的...

```
5.分块法
这个想法实在不知道怎么实现
大概是:因为大家都是方块,所以以排除块的边缘分割,可以把随机区域分割成几个大块,根据体积随机这个大块的方形,然后再在大块内部随机,这个速度应该很快很稳.
```



#### 3.100x100浮点范围内随机放置10个物体,但中心2x2浮点范围内不放置(不包括2),且放置过的位置不能再放置

```
删除法可以,每个生成过的位置记录个位置.
```

#### 4. 100x100浮点范围内随机放置10个物体,但中心2x2浮点范围内不放置(不包括2),且放置过的位置的2x2范围内不能再放置

```
删除法可以...过程同上,最后判断范围再删除
```

#### 5.半径为50的球形浮点范围内随机放置10个物体

```
1.删除法
本来以为自己搞不定了.前天优化了一下上边2的算法,发现删除法是万能的啊(虽然发挥很不稳定).
半径为50的球,可以当做半高为50的正方体(长宽高100的正方体)
先把区域随机出来,然后减去距离圆心大于50的.
成功数量 = 0
判断循环开始 (成功数量 < 10 则 一直循环):
	如果 按下ESC:
		结束循环
	位置x = 随机(-50.0,50.0)
	位置y = 随机(-50.0,50.0)
	位置xy = (位置x,位置y)
	如果 计算距离(位置xy,(0,0)) > 50:
		继续循环 #/--直接开始下次循环
	放置方块(位置xy) #/--通过了上边的判断
	成功数量+=1
```



#### 6.100x100浮点范围内随机放置10个物体,但中心半径为2的球形浮点范围内不放置(不包括2)

```
这个也是以为搞不出来了.然后发现删除法可以.
先创建,然后按距离删除.
成功数量 = 0
判断循环开始 (成功数量 < 10 则 一直循环):
	如果 按下ESC:
		结束循环 #/--加这一句,是血的教训.
	位置x = 随机(-50.0,50.0)
	位置y = 随机(-50.0,50.0)
	位置xy = (位置x,位置y)
	如果 计算距离(位置xy,(0,0)) < 2: #/--(0,0)可以替换为球心坐标
		继续循环 #/--直接开始下次循环
	放置方块(位置xy) #/--通过了上边的判断
	成功数量+=1
```

#### 7.100x100且四个角有距离为1圆角的浮点范围内随机放置10个物体

```
欸我艹
```



#### 8.100x100且四个角有距离为1圆角的浮点范围随机放置10个物体,但中心半径为1的球形浮点范围内不放置(不包括2)

```
......
```
#### 9.100x100浮点范围内随机放置10个物体,但放置过的位置不能再放置(难度1,放不下了可以不放,难度二,不论有多少个,只要有可能,就必须全部放下)

#### 10.100x100且四个角有距离为1圆角的浮点范围随机放置10个物体,但中心半径为1的球形浮点范围内不放置(不包括2),且放置过的位置,半径为1的球形范围内不能再放置(不论有多少个,只要有可能,就必须全部放下)

### 寻路算法^运动规划算法^

寻路算法学一遍忘一遍.记下来看看

**烧草算法**

**A*算法**

### 骨架算法

**细化算法**

查烧草算法的时候,在别处发现的一个算法.

[OpenCV学习(13) 细化算法(1)](https://www.cnblogs.com/mikewolf2002/p/3321732.html)

[OpenCV学习(14) 细化算法(2)](https://www.cnblogs.com/mikewolf2002/p/3322108.html)

[OpenCV学习(12) 图像的腐蚀与膨胀(3)](https://www.cnblogs.com/mikewolf2002/p/3321372.html)

**烧草算法**

这个玩意理解了原理,但是不知道怎么实现和优化,他在自动绑定上,自动生成骨骼方面很有用.

### 凸包算法

### 最优三角剖分算法

### 曲线简化算法

曲线拟合有很多不同的算法，但是几乎所有的曲线拟合算法都可以分为两类：插值和逼近。插值算法产生的曲线精确地穿过所有数据点，而近似算法产生的曲线接近数据点。当然，也存在混合算法。

[回归、插值、逼近、拟合的区别](https://www.cnblogs.com/bnuvincent/p/4877908.html)

[MATLAB回归、插值、逼近、拟合总结](https://blog.csdn.net/daaikuaichuan/article/details/73870209)

可能会用于动画曲线简化.即,将动画曲线转换为尽量近似的最少关键帧贝塞尔曲线.

#### 多顶点折线简化算法

#### 贝塞尔曲线拟合算法





