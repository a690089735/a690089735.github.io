<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../../../style/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../../../../scripts/prettify.js"></script><script src="../../../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="pandoc" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><script type="text/javascript" src="../../../../scripts/utils/adsk.redirect.js"></script>
      <title>Texture creation and texture manager</title>
   </head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Texture creation and texture manager</h1>
         </div>

<div class='section'><a id="texture-creation-and-texture-manager"></a></div>
<p>A unified mechanism for hardware (GPU) texture creation and management is exposed in the API. The textures are cached for reuse regardless of whether they are internally or externally loaded, and all memory management is handled internally.</p>
<p>Textures can be created either from an image on disk or via a block of pixels in CPU memory. The types of textures and the number of formats supported are much greater than any of the legacy interfaces. The interfaces are also draw API agnostic as opposed to legacy interfaces that only support OpenGL.</p>
<p>A texture is represented by the class <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture</a></span> and the management is handled by the class <span class='code'><a href="javascript:void(0)" data-symbol="MTextureManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture_manager.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTextureManager</a></span>.</p>
<p>There are three basic interfaces for acquiring a texture:</p>
<ol>
<li>Acquiring a texture from a file on disk: For this method, the currently available image code types are sup­ported. If any custom plug-in codecs have been added via the IMF plug-in interface, they are also sup­ported. The description of the image loaded is described by the class <span class='code'><a href="javascript:void(0)" data-symbol="MTextureDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture_description.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTextureDescription</a></span>. <span class='code'><a href="javascript:void(0)" data-symbol="MTextureDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture_description.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTextureDescription</a></span> itself is not a resource but a resource description.</li>
<li>Acquiring a texture from a block of pixels residing in CPU memory: In this case an <span class='code'><a href="javascript:void(0)" data-symbol="MTextureDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture_description.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTextureDescription</a></span> is a required input to describe the pixels. It is the responsibility of the plug-in writer to provide the correct description for the data. Note that it is possible to allocate a texture referencing a NULL block of data.</li>
<li><p>Acquiring a texture based on the output of a Maya shading node plug or node.</p>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MTextureManager::acquireTexture()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a04aa3cfef217948abc8edd0f19565f95&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture_manager.html#a912c9f447b1912945878c76608cb8cad&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTextureManager::acquireTexture()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MTexture::update()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#a3d365396b4e87bce3f2c6b8d93ea4d69&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html#a58572d537d159f0e5c12534e4ea85ba2&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture::update()</a></span> methods (that accept a file texture node as an input argument) may be preferable to explicitly specifying a file texture name, as these methods internally determine the file name from the file texture node. See the developer kit example <em>hwApiTextureTest</em> for sample code demonstrating the usage of the <span class='code'>acquireTexture()</span> methods. See the example <em>viewOverriedTrackTexture</em> for sample code demonstrating the usage of the <span class='code'>update()</span> method.</p></li>
</ol>
<p><strong>Uniqueness</strong> of a texture is provided by the name given to the texture. In the case of images on disk, the file path provides the unique name. Otherwise, the plug-in code is responsible for determining what is unique. On acquisition, if a texture with the same name already exists, then it is returned.</p>
<p>If an empty string is passed as the unique name, then the texture is considered to be “unnamed”. The main difference between named and unnamed textures is that unnamed textures are not cached by the internal texture caching system, resulting in the acquisition creating a new texture instance for each method call.</p>
<p>As it is not the purpose of <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture</a></span> and the manager to handle CPU side pixel maps, additional image codecs cannot be added directly via this interface. Instead, existing interfaces such as <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> can be used in conjunction with these interfaces. In fact, any interface which creates a block of pixels in CPU memory can use the interface which accepts CPU data to acquire GPU textures.</p>
<p>The relationships for texture acquisition are shown in the following diagram:</p>
<div class='figure'><img src='dev_help/images/aa0f8cad.jpg' title='' /></div>
<p>Figure 28</p>
<p>The most direct scenario is to load images from disk directly into GPU memory. In this scenario, CPU side memory is not persistently held. Other scenarios require a two-step process of allocating a block of pixels in CPU memory and then transferring the data to the GPU. Here, three options are shown: reading from a plug-in on a shader node, reading via the <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> class, and via some custom code.</p>
<p>The GPU handle to textures is accessible and is meant to be read only. As long as the data itself is not deleted or resized it is possible to perform updates directly on textures via this GPU handle. For DirectX11, this is actually a tex­ture handle, for OpenGL this is a texture id (integer). See <a href='#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/API-constructs/Texture-creation-and-texture.html#updating-color-textures' title=''>2.4.1 Updating color textures</a> and <a href='#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/API-constructs/Texture-creation-and-texture.html#depth-textures' title=''>2.4.2 Depth textures</a> for more formalized interfaces for texture updating.</p>
<p>The general use case for textures is to bind to shaders. As an example, an <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture</a></span> instance can be bound to a tex­ture parameter on an <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MShaderInstance</a></span>. If a texture is bound to a shader instance, this information is used during render item categorization phase. For example, setting the texture to indicate that it has semi-transparent pixels (between 0 and 1) can be used to categorize a render item as being transparent. There are also other query and set methods for checking different alpha channel properties of a texture.</p>
<div class='section'><a id="updating-color-textures"></a><h2 id="updating-color-textures">Updating color textures</h2></div>
<p>Continuously re-acquiring texture instances in order to replace their contents is not recommended, as this can be expensive. This is especially true for unnamed textures, as each acquisition results in a new texture being allocated. If it is known that a texture can be reused, then it is better to acquire it once from the texture manager and then update it using the <span class='code'><a href="javascript:void(0)" data-symbol="MTexture::update()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#a3d365396b4e87bce3f2c6b8d93ea4d69&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html#a58572d537d159f0e5c12534e4ea85ba2&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture::update()</a></span> interfaces.</p>
<p>The re-generation of mip-maps should be done as necessary to avoid any noticeable performance costs due to this computation. By default, mip-maps are automatically recomputed if the texture already contains mip-maps.</p>
<p>The update mechanisms are currently restricted to the updating of 2D non-array textures.</p>
<div class='section'><a id="raw-data-update-interfaces"></a><h3 id="raw-data-update-interfaces">Raw data update interfaces</h3></div>
<p>The fastest interface to use is the one that accepts a reference to raw data. This data can either be newly created in CPU memory, or data that is extracted from an existing <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture</a></span> or <span class='code'>MRenderTarget.</span></p>
<p>Whether newly created or not, it is important to use the appropriate row pitch as the row pitch may not be equal to the length of a texture row. Row padding concerns mainly affect textures that are created using the DirectX API. For example, if the data is extracted from an existing texture, the row pitch information extracted via the <span class='code'><a href="javascript:void(0)" data-symbol="MTexture::rawData()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#ae99c4e325062e162a32dfd435d81725c&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html#a1d3aef47eee7fff44ec6e1e6ac003338&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture::rawData()</a></span> method should be used. For new raw data, the row pitch information can additionally be computed based on the bytes-per-pixel method (<span class='code'><a href="javascript:void(0)" data-symbol="MTexture::bytesPerPixel()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#ac5a2b82710739bfaa0763e8d03116783&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html#a24e5513faa64001f1031ac38f31910fe&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture::bytesPerPixel()</a></span>) and the width for a texture.</p>
<p>If the data is being extracted from a target via <span class='code'><a href="javascript:void(0)" data-symbol="MRenderTarget::rawData()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html#a8056533f17e149f6113c5b6c72e55c5f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_target.html#ae74bdbf22163290e217d89a32bf16f66&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderTarget::rawData()</a></span>, the target may or may not be a texture and it is thus best to use the returned row pitch value. Note that a target (<span class='code'><a href="javascript:void(0)" data-symbol="MRenderTarget" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderTarget</a></span>) can be created with data from an on screen buffer (for example, a DirectX11 <span class='code'>SwapChain</span>) via the <span class='code'><a href="javascript:void(0)" data-symbol="MRenderTargetManager::acquireRenderTargetFromScreen()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target_manager.html#a1b0da7ddbe3556d678cd0593714f44e8&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_target_manager.html#a83f44ee0ad416990848d1f6d2b5686f1&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderTargetManager::acquireRenderTargetFromScreen()</a></span> method. A proper row pitch value should still be used in this case.</p>
<p>The basic cost of writing new data is the upload of CPU data to GPU texture. This should not be a “blocking” operation, meaning no data is read back from the GPU. For example, for OpenGL writers, the upload can be regarded as the equivalent of calling <span class='code'>glTexSubImage*()</span>.</p>
<p>Reading back from an existing texture is blocking, since the memory needs to be mapped back to CPU memory from GPU memory.</p>
<div class='section'><a id="mimage-update-interface"></a><h3 id="mimage-update-interface">MImage update interface</h3></div>
<p>Data from an existing <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> can also be used to update an existing <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture</a></span>. It is the responsibility of the caller to ensure that the format of the texture matches that of the <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span>. This is currently 4-channel, 8 bytes-per-channel RGBA color. The <span class='code'>bytesPerPixel()</span> method can be used to check for a match.</p>
<p>Using the <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> interface requires mapping GPU memory to the CPU, updating it and then mapping it back to the GPU.</p>
<div class='section'><a id="backdoor-updating-via-gpu-handle"></a><h3 id="backdoor-updating-via-gpu-handle">“Backdoor” updating via GPU handle</h3></div>
<p>As GPU resource handles (<span class='code'><a href="javascript:void(0)" data-symbol="MTexture::resourceHandle()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#ad7bcab0d1707ef0da22fc72ada62c40e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html#aed7e3e1f42e6cc3b4f73ee24e2e2012e&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture::resourceHandle()</a></span>) are available, it is also possible to perform the update using these handles. For example, GPU to GPU resource memory transfers are not exposed in the API, but can be performed using the raw resource handles.</p>
<p>It is strongly recommended that no format change or data size occurs via operations on this handle, as the resource is owned by the internal renderer, and would never know that any of these attributes have been modified.</p>
<div class='section'><a id="texture-update-examples"></a><h3 id="texture-update-examples">Texture update examples</h3></div>
<p>The following diagram illustrates the interaction between the various update possibilities.</p>
<div class='figure'><img src='dev_help/images/API_white_paper_section2_4_fig29.png' title='' /></div>
<p>Figure 29: On the left, an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> could be used to upload new context to the <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture</a></span>. Part of this data is mapped back to the CPU and the new data copied over. The flow of data shown above the <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTexture</a></span> illustrates possible reading back of the raw data, and the possible updating of the texture using raw data. The top right shows that the raw data can also be read from an offscreen render target. The bottom right illustrates the ability to access the GPU handle in order to update the texture.</p>
<p>The following is an example which reads back the raw pixel data from a texture, inverts the pixels and then writes the data back to the texture. The texture here is assumed to have a format of 24-bit fixed point RGBA.</p>
<div class="codeBlock"><pre class="prettyprint">// Get the texture description from the texture 
<a href="javascript:void(0)" data-symbol="MHWRender::MTextureDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MTextureDescription</a> desc;
texture-&gt;textureDescription(desc);
unsigned int bpp = texture-&gt;bytesPerPixel();

// This code happens to only work with fixed-bit 8888 RGBA
//
if (bpp == 4 &amp;&amp; 
    (desc.fFormat == MHWRender::kR8G8B8A8_UNORM ||
     desc.fFormat == MHWRender::kB8G8R8A8))
{
    int rowPitch = 0;
    int slicePitch = 0;
    bool generateMipMaps = true;

    // Extract out the raw data from the texture. Also gets the row and slice pitch
    // The assumption is that this is 2D texture so slicePitch would be 1.
    // A GPU-&gt;CPU transfer of data will occur.
    unsigned char* pixelData = (unsigned char *)texture-&gt;rawData(rowPitch, slicePitch);
    unsigned char* val = NULL;
    if (pixelData &amp;&amp; rowPitch &gt; 0 &amp;&amp; slicePitch &gt; 0)
    {
        // Do some example operation: invert the pixel values (255-value)
        for (unsigned int i=0; i&lt;desc.fHeight; i++)
        {
            val = pixelData + (i*rowPitch);
            for (unsigned int j=0; j&lt;desc.fWidth*4; j++)
            {
                *val = 255 - *val;
                val++;
            }
        }
        // Update the texture. A CPU to GPU transfer of data will occur
        texture-&gt;update(pixelData, generateMipMaps, rowPitch);
    }
    delete [] pixelData;
}
</pre></div><p>The sample plug-in <em>hwAPITextureTest</em> uses the above inversion code to update textures read from disk, blits the result to the screen, and then extracts raw data from an on screen target to transfer back to a texture. The texture is then written to disk.</p>
<p>The sample plug-in <em>viewImageBlitOverride</em> demonstrates the update of a color texture for each refresh of a render override (<span class='code'><a href="javascript:void(0)" data-symbol="MRenderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderOverride</a></span>).</p>
<div class='section'><a id="depth-textures"></a><h2 id="depth-textures">Depth textures</h2></div>
<p>Some interfaces exist to allow for the creation and usage of depth textures. Use of these interfaces is not mandatory, as there is nothing dictating either the format or the manner in which depth textures are used.</p>
<p>Maya has an internal format for storing depth values relative to a camera either in memory or on disk. This is exposed as part of part of the Maya IFF file format and can be written out by a renderer and / or read from disk via API classes such as <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span>.</p>
<p>As a convenience, the texture manager supports reading of depth images to create &quot;depth textures&quot;. The internal format of such textures is a single channel 32-bit floating point stored in the red channel (R32F). The <span class='code'><a href="javascript:void(0)" data-symbol="MTextureManager::acquireDepthTexture()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a069050f9521fe273263d287139a33fee&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture_manager.html#a8189c3e6e4356f1e754fc411d34fbb4b&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTextureManager::acquireDepthTexture()</a></span> methods can either accept reading the depth data from an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> or from a block of raw pixels.</p>
<p>Also as a convenience, the data may be normalized at creation time to the [0…1] range. In order to perform the normalization, an instance of a <em>normalization descriptor</em> is required (<span class='code'><a href="javascript:void(0)" data-symbol="MDepthNormalizationDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDepthNormalizationDescription</a></span>). The default constructor set member data to the values associated with a default perspective camera. The normalization process assumes that the input data adheres to the convention used for depth buffers produced by Maya&#39;s software renderers or equivalently the depth format used for storage in an <span class='code'>MImage.</span></p>
<p>As there is a cost for normalization, textures can be created unnormalized, and the appropriate shader code can be added to normalize values at render time.</p>
<p>If the data is being provided via an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span>, the method <span class='code'><a href="javascript:void(0)" data-symbol="MImage::getDepthMapRange()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html#a5d8f088519961981aaf5977fd57aceff&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html#a5bffa730a161a7f612811809da2e34f8&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage::getDepthMapRange()</a></span> can be used to extract values to use with an <span class='code'><a href="javascript:void(0)" data-symbol="MDepthNormalizationDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDepthNormalizationDescription</a></span>.</p>
<p>The plug-in <em>viewImageBlitOverride</em> shows example code for both generating raw data to fill in a normalized depth texture, as well as reading an existing depth buffer from a <span class='code'>.iff</span> file on disk.</p>
<p>From the plug-in, we extract some of the code to demonstrate example steps for creating a depth texture.</p>
<p>If we are only interested in loading the depth data from an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span>, a &quot;dummy&quot; <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> needs to be created with a desired output &quot;target&quot; size. The depth data is extracted from the <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> and used to acquire the depth texture from the texture manager. In this example, CPU side normalization is performed.</p>
<div class="codeBlock"><pre class="prettyprint">// Pre-create a <a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a> of the output target size.
//
<a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a> image;
image.create(targetWidth, targetHeight, 4, <a href="javascript:void(0)" data-symbol="MImage::kByte" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html#a01e74e17cc52f661123b8a2a4da770c1a46b9941f17f513de8e30e46ac53e684b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage::kByte</a>);


// Load depth image from disk to create the depth texture. The file on disk is assumed to
// have depth data embedded.
//
<a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> depthImageFileName(“testFile.iff”);
if (<a href="javascript:void(0)" data-symbol="MStatus::kSuccess" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MStatus::kSuccess</a> == image.readDepthMap( depthImageFileName ))
{
    image.getDepthMapSize( targetWidth, targetHeight );

    // Set up normalization structure.
    // Take into the account the clipping values from the image.
    // 
    <a href="javascript:void(0)" data-symbol="MHWRender::MDepthNormalizationDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MDepthNormalizationDescription</a> normalizationDesc;
    float minValue, maxValue;
    image.getDepthMapRange( minValue, maxValue );
    normalizationDesc.fNearClipDistance = minValue;
    normalizationDesc.fFarClipDistance = maxValue;

    // Acquire a texture using the depth pixels and normalization structure
    mDepthTexture.texture = textureManager-&gt;acquireDepthTexture(&quot;&quot;, 
        image, false, &amp;normalizationDesc );
}

</pre></div><p>For loading from raw data, we simply allocate a block of floating point data and fill it with suitable values. In this case, we create a checker pattern where each tile has a different camera depth.</p>
<p>The code shows the option of whether or not to create normalized values (via the <span class='code'>useCameraDistanceValues</span> variable). The code also shows the option of taking that raw data and repackaging it into an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> in order to use that interface (using the <span class='code'>createDepthWithMImage</span> variable).</p>
<div class="codeBlock"><pre class="prettyprint">// Load depth using programmatically created data
//
float *textureData = new float[targetWidth*targetHeight];
if (textureData)
{
    // Use &#39;createDepthWithMImage&#39; to switch between using the <a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a>
    // and raw data interfaces.
    //
    // Use &#39;useCameraDistanceValues&#39; to switch between using -1/distance-to-camera
    // values versus using normalized depth coordinates [0...1].
    // The flag is set to create normalized values by default in order to
    // match the requirements of the shader used to render the texture.
    //
    bool createDepthWithMImage = false;
    bool useCameraDistanceValues = false;

    // Create some dummy &#39;checkered&#39; depth data. 
    //
    float depthValue = useCameraDistanceValues ? -1.0f / 100.0f : 1.0f;
    float depthValue2 = useCameraDistanceValues ? -1.0f / 500.0f : 0.98f;
    for (unsigned int y = 0; y &lt; targetHeight; y++)
    {
        float* pPixel = textureData + (y * targetWidth);
        for (unsigned int x = 0; x &lt; targetWidth; x++)
        {
            bool checker = (((x &gt;&gt; 5) &amp; 1) ^ ((y &gt;&gt; 5) &amp; 1)) != 0;
            *pPixel++ = checker ? depthValue  : depthValue2;
        }
    }

    // Create a default normalization structure
    <a href="javascript:void(0)" data-symbol="MHWRender::MDepthNormalizationDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MDepthNormalizationDescription</a> normalizationDesc;

    // Take the raw data and repackage it into an <a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a> and use that interface
    // This is presented as an example only and is not necessary since the
    // raw data interface is available.
    if (createDepthWithMImage)
    {
        image.setDepthMap( textureData, targetWidth, targetHeight );
        mDepthTexture.texture = textureManager-&gt;acquireDepthTexture(&quot;&quot;, 
            image, false, useCameraDistanceValues ? &amp;normalizationDesc : NULL );
    }

    // Take the raw data and repackage it into an <a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a> and use that interface
    //
    else
    {
        mDepthTexture.texture = textureManager-&gt;acquireDepthTexture(&quot;&quot;, 
            textureData,  targetWidth, targetHeight, false,
            useCameraDistanceValues ? &amp;normalizationDesc : NULL );
    }

    // Data not required anymore so can delete it.
    delete [] textureData;
}

<div class='figure'><img src='dev_help/images/API_white_paper_section2_4_fig31.png' title=''></div>
</pre></div><p>Figure 31: The possible data paths for creating depth textures is shown. The data can be created by a given renderer or by hand. The interfaces to <span class='code'><a href="javascript:void(0)" data-symbol="MTextureManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture_manager.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MTextureManager</a></span> allows for input via raw data or via <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MImage</a></span> argument.</p>
<div class='section'><a id="blitting-depth-textures"></a><h3 id="blitting-depth-textures">Blitting depth textures</h3></div>
<p>The simplest way to transfer the contents of a depth texture to an output target is to use a shader (<span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MShaderInstance</a></span>).</p>
<p>A sample shader called <em>mayaBlitColorDepth</em> has been provided in effects file format. The shader can be acquired via the shader manager. The shader currently shows the transfer from a R32 input texture containing normalized values to depth output.</p>
<p>As with color textures, the co-ordinate target system is from top-to-bottom. The sample shader performs the vertical flip in V as appropriate. Plug-in writers can choose to create their textures with whatever convention they choose and perform the V flip to be consistent.</p>
<p>This shader is used in the <em>viewImageBlitOverride</em> plug-in example.</p>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
