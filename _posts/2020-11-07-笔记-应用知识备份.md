---
layout: post
title: 应用知识备份
date: 2020-11-07 10:09:29.00 +08:00
categories: 学习
tags: 笔记
comments: false
---



随着会的东西越来越多,以前一些觉得做不到的东西都能想到可行办法,或者找到其中规律了.

但是受限于学历和知识水平,很多方法和计算无法开展.力所能及的部分,稍微在网上搜索学习一下.其实有些东西很简单,只是没有人细心解释那个专业术语的简称.也没有得到更可视化的学习方式来帮助理解.

同样受限于受教育程度,并受限于学习环境(主要是谷歌百度和看过时的盗版教程),很多学习理解的过程都是靠**应用**实践,和凭**感觉**推理(难听点叫猜测),在记录中的理解方式和讲解说明可能**存在严重错误或问题**.只做自己记录之用,他人切勿轻信.

(随便写一些,都是自己时至今日方才醒悟的一些常识.受限于自己的智商,对内容准确与否不负任何责任,只保证实际应用的时候可以顺利实施.我都是仅自己,仅在某3D软件或者某游戏引擎,或者某IDE里做过实践测试.都是我脑子自己的观点,不代表个人立场,不代表实际知识就是这样子的.

我这水品,小学以上,初中未满吧.我自己也清楚,写下的这些,都是大家义务教育就能学到的基础知识.所以觉得我很low的人请也不要喷我,因为不论我发不发这些东西,我也都在很不努力的学习和记录,只是认为捎带脚分享一下,万一能帮到谁的话就太好了.兴趣使然而已,喷我也没用,哈哈哈哈哈.

我心里是这么想的:"反正记了也记了,希望没错的部分能帮助到人,错了和不完善的地方能被人指出纠正和教导."

)

## 方程&函数&平面直角坐标系&矢量&线性代数

方程和函数都是一组用字母\数字\符号组成的特定算式,我感觉他们的核心是同本同宗的.只不过函数存在变量,方程是固定结果.

### 方程

方程得有未知数, **元**(元素): 一个元,是一个未知数,比如:**x**=0,是一元,**x**+**y**=0是二元,x+**y**+**z**=0是三元.....

这个或这几个位置数可能是带指数的.**次**(次幂):函数中最高次方的元的次方数,比如:**x**^3^ = 1

### 函数

最简单的函数: **y = x** ,她的效果是 **x = 1** 时 **y = 1**, **x = 2** 时 **y = 2**, **x = 3** 时 **y = 3** ...

比最简单,稍微厉害一点点的函数: **y = x^2^** ,她的效果是 **x = 1** 时 **y = 1**, **x = 2** 时 **y = 4**, **x = 3** 时 **y = 9** ...

再厉害一点点的函数: **y = 2x^2^ + x + 2**  ,她的效果是 **x = 1** 时 **y = 5**, **x = 2** 时 **y = 12**, **x = 3** 时 **y = 23** ...

接着就是不断的加次数了,**y = 4x^3^ +  9x^2^ + x + 2** ,**y = 2x^4^ + 4x^3^ +  9x^2^ + x + 2**...啥的.因为函数不断精简后,只有各个不同次数(**不同指数**,不同次幂,不同次方)的x和其**系数**被保留了下来.(系数,比如2x,就是两个x呗,这里的2就是系数,默认情况下可以是任何数,比如0.5x,系数是0.5. 12x,系数是12,-x,系数是-1.....)

仔细看看上面那些越来越厉害的函数.要说有什么规律的话,其实这些函数都是**某个数量的x的几个次幂相加的和**.最重要的还是系数.就算是 2x^2^ + **b** 最尾巴的那个**b**,其实也不过是 **bx^0^**,任何数的**0次幂**都是**1**嘛,所以简写成了**b**.(真够鸡贼的,哈哈哈,当年上这堂课的时候我好像睡觉了没学到,前几天遇见了*拟合*(不用查,写在下面的"更多"里了)的时候才发现的.我发现知道了这个规律后,函数写的再复杂也不迷糊了啊.这是多年前擦肩而过那个她啊.我的天呐~)

y = x可以写成 y = f(x),画在二维空间中,就是一条斜着的直线.

恼火的是, y = 2x^2^ + 6x + 7, 也写成 f(x), 只是"f()"代表的式子(算式)不同了.

其他的还有f(x+1)或者f(x,y,z),由此发现,f()是表示函数本身,括号内的东西是变量.f(xxxxx)这一坨东西,是两坨东西的组合.尤其是f(),这不是一个东西,他背后特么的承载了一大坨东西.

### 平面直角坐标系

上学的时候,觉得平面直角坐标系她就只是个毫无实际意义的图像,枯燥又乏味,麻烦又无用,明明可以简单画一下的东西,非要整这么大个阵仗,还只能得到点和线,还不如画个王八有意思.

后来对她有了应用,发现这其实应该是当时阶段最有趣的知识了.

平面直角坐标系,其实是一个**二维空间**啊! 只要有一个**0点**和**两个互相垂直的轴**,你就可以在这个二维空间里愉快的玩耍了.

二维空间其实就是在玩点(坐标).

>  不管几维,都是在玩点(玩坐标),要么是移动点的位置,要么是用点的位置排列来画线,要么按某个点的旋转,重新计算其他点的位置啥的....

比如在一个末日游戏中,你控制的生存者在[10,35],僵尸在[5,-3],如果电脑要计算僵尸在横纵轴各移动多少去攻击你,它只要用[10,35]减去[5,-3]就完了,如果你想计算僵尸[5,-3]是不是在你的武器射程内,可以用家喻户晓的 **直角三角形勾股定理** 算出距离呀(斜边长即是距离!)

关键是:学会了这个,以后二维世界有什么图形问题,就不用拿尺子一点一点的比量着画出来了,全是自动出结果,而且还绝对准确没有误差,比自己手动画的不知道精准几百倍.

然后是我发现的关于各种坐标系的一些规律.

> **0点**是给你参照相对位置的,**必须得有**!没有0就不知道1在哪里.
>
> **两个互相垂直的轴**是用来标记相对位置的,**也必须得有**!
>
> 这两个垂直的轴,是你自己画出来参考用的,就是两个带刻度的参考线,画成什么样字你大可以自己做主.而且,其实两个轴不垂直也行,只是不垂直的话,特别特别难计算,也不好理解,何必呢?
>
> 一个轴?一个轴那就是一维空间呗! 三个轴就三维空间, 四个就4维....
>
> **四个互相垂直的轴!**很难理解吧.四维有什么用呢.比如你的身高、体重、年龄、学历都放到四维坐标系的一个轴上,你就基于这些数据成了一个四维空间点.再把我的参数放进思维空间.就能用勾股定理求咱俩的属性距离了!(距离就是这些属性的整体相似度,距离近的话,咱俩可能就会在APP里收到同样的职位的招聘信息.)
>
> 强烈建议 **平面直角坐标系** 改名为 **二维空间参照系** 呀,哈哈哈

(哈哈.忽然想起小时候老师教ax^2^+bx+c的时候(刚查了一下,叫二次函数),给了几个值让大家画出几个点,然后连接起来.我很快算了五个点,然后用直线连接了一下.我记得自己当时是第一个交的,交给老师后,老师却说要用曲线连接.我很不理解嘛,就问老师为什么.清晰的记得老师和我说的是,"用曲线连接更好看",哈哈哈哈,老师还在黑板上补充了一下,要求后面的同学都用曲线连接算出的点,后来好像也说了"这样也更真实"这样的话.不过我当时的智商和知识背景完全没有条件理解这其中蕴含的信息.时隔多年,好像都退伍回来几年了,我才知道,当你按照算式不断的画点,画的越多,就越接近曲线,当你按照算式画出无数个点时,他们的排列自然是一条曲线.这就是函数的魅力所在.)

### 更多

#### 拟合

已知变量求函数,叫**拟合**(曲线拟合,多项式拟合)

比如当 x = 0 时, y = 0; x = 1 时, y = 3; x = 2 时 y = 18 ,求f(x)的表达式.(结果化简后:6x^2^ - 3x......我不会求,先编的答案,后编的题...很多时候化简后很难理解,但是可以显著减少程序计算次数,)

**Python的numpy库**可以简单的计算拟合得出结果,可以不用知道为什么,直接拿来用.(原理好像叫最小二乘法.稍微知道就行了,先用着.)

要注意的是,拟合是允许误差的,结果只是近似,因为当点的随机性很强的时候,无法匹配所有结果,但这正是拟合的优点--不论多么无关的随机值,咱都能得出一条近似的曲线来描述.

其次,选取最适合的多项式次数是最重要的.比如:一次:ax+b,二次:ax^2^+bx+c:三次ax^3^+bx^2^+cx+d:四次ax^4^+bx^3^+cx^2^+dx+e.....(拟合的过程就是把各个系数计算出来.)

不过并不是哪一个次数的多项式就更好,这里只有最合适没有最好,有可能你就是想要直接的直线表达来概括数据,有可能你想尽量贴合散点来描述变化.(如图,配图来自知乎)

![1~4次多项式的拟合结果]({{site.img}}14次多项式的拟合结果.jpg)

我不清楚这几个次数的区别,但是实际看来,一次多项式绘制的曲线是个直线,二次绘制的可以拐一个弯,三次能拐两个弯,四次三个弯.....

还有个有用的更牛的应用叫 **平面拟合**,空间离散点拟合成空间平面,(这个是我想在空间中通过一些点的选择,配合二维凸包算法生成一个面,然后根据这个面的法线创建一个坐标轴的时候发现的,不过一直没去实现.写到这里,加上之前的一些经验,我发现在游戏开发上,二维就是简化版的三维,二维能做的,三维都能实现,只是三维更复杂一些.想研究三维可以先从二维入手,三维不过是二维plus,开发过二维游戏,就会觉得三维游戏无非是一些算法稍微复杂了一些.(尤其是旋转))

![20160417211137718]({{site.img}}20160417211137718.png)

拟合还有个标记是**r**,具体怎么回事不知道,也没细查,计算中怎么得出也不知道,不过这个值越接近1,结果误差就越小.不过经常出现好多9,建议用1减去r,比较容易知道是不是可以将误差忽略不计.比如: 1 - r = 0.00000190733

#### 矢量

矢量真是太**简单了.矢量就是有方向的量,有的放矢的矢!像箭矢一样射出去的量啊!

比如[1,1],只考虑他本身的话,就**是个坐标.

但是这个[1,1]是相对0点的坐标呀.所以把[1,1]和[0,0]考虑在一起的话,就有了两个点,形成了一条从[0,0]开始画出的线段.相当于一个弓箭手站在[0,0]点拉弓蓄力,朝[1,1]射了一箭,这根箭就有了方向!

至于为什么是[0,0]开始?因为[0,0]是相对来说固定不变的,坐标系也是以他为基本的,所有的矢量(坐标)也都是以他为参照的.

然后[0,0]为什么不能作为矢量,因为[0,0]到[0,0]就是两个叠在一起的点,相当于一个点,既可以说他作为矢量没有意义,又可以说他作为矢量有无限多个方向,这可就没法玩了(其实[0,0]也可以是矢量,就是让他加进来就不好玩了.弓箭手可以射自己一箭,但是他拒绝了.(其实是人们,或者我自己,还没搞清[0,0]的特殊意义))

### 一些术语

### 负数

负数是现实生活中看不见摸不着的存在.,正数可以拿一个苹果,两个苹果,三个苹果...来举例,但因为实物不可能小于0,所以负数只有当东西不够了,或者出现负债的时候才能体现出来.比如

#### 加减法

加法:加法是最基本的计数计算法, 简单的加法以1为根本,从1+1= 2推演出各种加法,比如1+3= 1+(1+2) = 1+(1+(1+1)).只要像数数一样去加他们就行了,但是因为太简单了,所以大家都是好几位的不同数字直接计算,比如 101+ 99 = 200 .

减法:在知道了加法之后,减法就很简单了,以1为根本的话,则是以1-1=0为基础推演,不过要有符号的概念,1-1 = 1+(-1) . 比加法多一点的是比如 3-2 = (1+1+1)-(1+1) = 1+1+1-1-1 ,划掉等于0的部分 1~~+1+1-1-1~~ ,只剩 1

多位数加减法要有进位的概念

#### 乘法

普通乘法,我理解为反复相加的方法,"乘"是不断上升的意思. 比如5×4 ,就是5反复相加4次, 即 5+5+5+5 = 20.

整式的乘法十分丰富,但实际计算和普通乘法没什么区别. 最简单的是 10×(1+2-3), 可以换成 (10×1+10×2-10×3),其他的整式乘法也由此演变.

#### 被除数,除数

比如 24 ÷ 8 = 3 ,24是被除数,8是除数. 

"除"这个字的含义,基本上就是反复减,得数就是最多可以反复减的次数.相当于"把24按8反复减3次可减干净(除尽)","变成被字句就是24被8反复减3次可减干净", 故24是被除的数,即**被除数**,8是用来除的数,即**除数**. 

0不能作为除数,主要是没法除0,除得的结果也用不了(能除无限个0?),更没法还原计算(因为将得数乘以0时,0乘任何数都是0,无法满足原除式).

(相对的,"乘",基本上就是反复加的意思)

#### 相反数

一个数乘以-1就得到相反数,两个和为0的数互为相反数,(绝对值相等,正负号相反的两个数),相反数都是成对的.比如 +2和-2, 0 和 0. 

####  倒数

1除以一个数就得到倒数,两个数乘积为1则互为倒数

## 算法

### 随机分布

我给自己出了10道有生之年我解不开的题,在学习过程中,我发现这些问题可能有一些其他名词,比如 包装问题,几何堆积问题,关数值装箱问题,背包问题

在100*100的范围内随机放置10个物体的不同难度和思考的逻辑(伪代码).

#### 1.100x100浮点范围内随机放置10个物体,或100x100x100浮点范围内随机放置10个物体

```
1. 2D
循环开始(循环10次):
	位置xy = (随机(-50.0,50.0), 随机(-50.0,50.0))
	放置方块(位置xy)
循环结束
```

```
2. 3D
循环开始(循环10次):
	位置xyz = (随机(-50,50.0), 随机(-50.0,50.0), 随机(-50.0,50.0))
	放置方块(位置xyz)
循环结束
```

```
不算. 
代码里的-50到50的随机,一开始写错成了0到100,虽然加一个对半的偏移也不是不行,但是为了后面便于理解也为了和后面统一,还是改一下.往回整体改了一遍,看到2,刚好想到了一种可以只在对角生成随机位置的方法,特别好,就记到这一下:
循环开始(循环10次):
	单位 = 随机(-50,50.0)
	位置xyz = (单位, 单位, 单位)
	放置方块(位置xyz)
循环结束
简直太好了!
```



#### 2.100x100浮点范围内随机放置10个物体,但中心2x2浮点范围内不放置(不包括2)

```
1. 排除法,简单粗暴,但速度看运气
循环开始(循环10次):
	位置x = 0.0
	位置y = 0.0
	循环开始 如果 位置x < -2 or x > 2:
		位置x = (随机(-50.0,50.0))
	循环结束
	循环开始 如果 位置y < -2 or y > 2:
		位置y = (随机(-50.0,50.0))
	循环结束
	位置xy = (位置x, 位置y))
	放置方块(位置xy)
```

```
2. 分区法,只适合方形区域,更多的准备工作
除了中心区域,其他地方都切成方块,然后计算随机到哪一块.(如果分的不平均的话,要加一个权重.正方形的话,多少个面就有多少个区域)
实现起来太闹心,略.
```

```
3. 阵列排除法,不是完全随机,很占内存,速度取决于精度
--做出一个足够细小的阵列点,作为可放置的位置列表.
精度 = 0.1
位置列表 = []
计次循环 x= -50 到 50 每 0.1:
	如果 (x>2 或 x<-2) 则:
		计次循环 y= 0 到 100:
            如果 (y>2 或 x<-2) 则 位置列表.添加(x,y)
计次循环 i= 1 到 10:
	放置方块(位置列表[随机(1, 位置列表.长度)])
3.2 或者可以优化成
精度 = 0.1
位置列表 = []
计次循环 x= 1 到 50 每 0.1:
		计次循环 y= 1 到 50:
            位置列表.添加(x,y)
            位置列表.添加(x,-y)
            位置列表.添加(-x,y)
            位置列表.添加(-x,-y)
计次循环 i= 1 到 10:
	放置方块(随机(位置列表))
```

```
4.1 [用不了,或者没用好]分割阵列法,阵列二次随机法,体素随机法(怎么叫都行,基本是吸收了上面2和3的思路,用在方形上特别好用,感觉基本完美了,但是如果这个数不能被2整除就恐怖了)
--做出一个粗糙的阵列点,然后以这些阵列为中心随机(先做出一些很大块的体素,再在体素内随机)
块大小 = 2
块位置列表 = []
计次循环 x= -50 到 50 每 2:
	如果 (x>1 或 x<-1) 则:
		计次循环 y= 0 到 100:
            如果 (y>1 或 x<-1) 则 块位置列表.添加(x,y)
	stop!!!!!

4.2 啊,上边的先停一停,其实我按照中间不能放的那部分方块作为块的单位,然后以不能放的部分为中心计算点,这个算法就完美了啊.而且不能放的区域不光是中间,任何地方也可以啊.(因为只要把中间做为分块单位,那分出来的所有块就都是方形的)
Stop!!!!!

4.3 啊,不对.这样分出来的方块,大小一样还好,如果最外围的块比别的块小怎么办,又要记录大小,又要计算随机比例.
#好像有个最大公约数什么的,在这里应该会很好用吧.
如果 有小数 则 两个数都乘以若干个10倍 然后求 最大公约数n 再 除以刚才的若干个10倍得到新的n 否则 求最大公约数n 
块大小 = n
块位置列表
#因为是利用中心,在块范围内生成,所以起始位置应该在无效范围外的半个块大小的地方开始.
起始 = (1+0.5n)
计次循环 x= 起始 到 50 每 n:
		计次循环 y= 起始 到 50:
            块位置列表.添加(x,y)
            块位置列表.添加(x,-y)
            块位置列表.添加(-x,y)
            块位置列表.添加(-x,-y)
计次循环 i= 1 到 10:
	放置中心xy = 随机(块位置列表)
	位置x = 随机(放置中心xy.x + n, 放置中心xy.x - n)
	位置y = 随机(放置中心xy.y + n, 放置中心xy.y - n)
	放置方块(位置x, 位置y)
	
4.4 对了,这个方法还有个好处,就是比如2x2的范围不是在0点开始,那么只要加上偏移取个范围,再在计算块位置列表时加两个判断就好了.

4.5 我按照自己的思路测试了一个完整的流程(支持多个排除区域),发现即使求了最大公因,思路也只在范围长度➗限制长度结果是奇数的时候奏效.

4.6 不过还是夸自己一下,因为自己本来就是无知之士,草野之夫,目前做的还不错.

```

```
5. [不行,实际测试,一组排除区域时,只有四个角可以随机,因为我的算法导致整个含有这组坐标的点都不可随机了]根据4的失败和2的分割法思路(想想就脑袋疼,没去实现)以及网上搜索到的排除随机数的方法,加上头脑发酵,我又觉得行了.只是目前看来只适合方形,命名为区间随机法!
#取出XY的可能范围,这步需要自动计算(最大数和最大数之间是个范围,最小数和最小数之间是个范围呗?),不难但是麻烦,方便起见直接出结果.
xranges = ([-50,-2],[2,50])
yranges = ([-50,-2],[2,50])
计次循环 i= 1 到 10:
	x范围 = xranges[随机[1, xrange.长度]]
	y范围 = yranges[随机[1, yrange.长度]]
	位置x = 随机(x范围[1], x范围[2])
	位置y = 随机(y范围[1], y范围[2])
	放置方块(位置x, 位置y)
看着真**简单啊,就喜欢这样的,很爽.
不过还不是平均随机,接近平均随机的话,可能需要求出各组范围的面积或体积(好像不管是几维,结果都是长度,因为范围只是一个轴上的嘛),然后得出一个随机权重.
其实,即使4能实现,也没法有效处理随机区域外的排除区域,而这个方法恰好解决了这个弊端.还更简单高效.
```

试过方法4之后,忽然觉得随机这种东西,有些情况里即使不那么随机,看起来也是挺随机的...

#### 3.100x100浮点范围内随机放置10个物体,但中心2x2浮点范围内不放置(不包括2),且放置过的位置不能再放置

#### 4. 100x100浮点范围内随机放置10个物体,但中心2x2浮点范围内不放置(不包括2),且放置过的位置的2x2范围内不能再放置

#### 5.半径为50的球形浮点范围内随机放置10个物体

```
艹
```



#### 6.100x100浮点范围内随机放置10个物体,但中心半径为2的球形浮点范围内不放置(不包括2)

```
卧槽
```

#### 7.100x100且四个角有距离为1圆角的浮点范围内随机放置10个物体

```
欸我艹
```



#### 8.100x100且四个角有距离为1圆角的浮点范围随机放置10个物体,但中心半径为1的球形浮点范围内不放置(不包括2)

```
......
```
#### 9.100x100浮点范围内随机放置10个物体,但放置过的位置不能再放置(难度1,放不下了可以不放,难度二,不论有多少个,只要有可能,就必须全部放下)

#### 10.100x100且四个角有距离为1圆角的浮点范围随机放置10个物体,但中心半径为1的球形浮点范围内不放置(不包括2),且放置过的位置,半径为1的球形范围内不能再放置(不论有多少个,只要有可能,就必须全部放下)

### 寻路算法^运动规划算法^

寻路算法学一遍忘一遍.记下来看看

### 烧草算法

### 骨架算法

#### 细化算法

查烧草算法的时候,在别处发现的一个算法.

[OpenCV学习(13) 细化算法(1)](https://www.cnblogs.com/mikewolf2002/p/3321732.html)

[OpenCV学习(14) 细化算法(2)](https://www.cnblogs.com/mikewolf2002/p/3322108.html)

[OpenCV学习(12) 图像的腐蚀与膨胀(3)](https://www.cnblogs.com/mikewolf2002/p/3321372.html)

#### 烧草算法

这个玩意理解了原理,但是不知道怎么实现和优化,他在自动绑定上,自动生成骨骼方面很有用.

