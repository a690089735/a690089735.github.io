<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../../../style/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../../../../scripts/prettify.js"></script><script src="../../../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="pandoc" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><script type="text/javascript" src="../../../../scripts/utils/adsk.redirect.js"></script>
      <title>Geometry remapping for hardware rendering</title>
   </head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Geometry remapping for hardware rendering</h1>
         </div>

<div class='section'><a id="geometry-remapping-for-hardware-rendering"></a></div>
<p>The following information focuses on the remapping of geometry data that can occur:</p>
<ul>
<li><p>From the point of creation of polygonal meshes, either internally or via the <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnMesh</a></span> API interface,</p></li>
<li><p>To the point where geometry is provided for hardware rendering.</p></li>
</ul>
<p>The main goal is to describe how the vertex data provided at render time can be mapped back to the original geometry. In particular, we consider the case where the requirement is to remap data back to a series of original quadrilateral (quad) faces. Such is the case for Ptex texture mapping.</p>
<p>To start, basic triangulation logic and uniform subdivision logic used for the Smooth Mesh Preview display option is described. This information can aid in understanding the algorithm performed by custom remapping which matches what is performed internally by Maya. This information pertains to the logic in Maya 2016 and is applicable for both VP1 (Legacy Default Viewport) and VP2 (Viewport 2.0).</p>
<p>Secondly, access to remapping data at shading time is examined. The main advantage of using remapped data is that the plug-in does not need to keep up with the complexity of internal logic changes within Maya. The provided data has already undergone all internal data manipulation in the same manner as other per-vertex attributes (such as positions and normals).</p>
<p>The internal remapping logic is current as of Maya 2016 and is subject to change over time. Reverse-engineering this logic is not recommended. In addition, the index remapping logic used for triangulation and sculpting performance, as well as adaptive subdivision, add additional complexity and non-determinism for VP2.</p>
<p>Access to equivalent remapping data for both VP1 and VP2 hardware shader interfaces are also examined.</p>
<div class='section'><a id="remapping-logic"></a><h2 id="remapping-logic">Remapping logic</h2></div>
<div class='section'><a id="triangulation"></a><h3 id="triangulation">Triangulation</h3></div>
<p>Triangulation occurs in order to produce geometric indexing, which can be used when hardware rendering. The choice of which local vertex indices are used for splitting is determined by the triangulation logic. Knowledge of which split is used can aid in determining the mapping of a pair of triangles back to the original quad.</p>
<p>By default, the logic used for polygonal shapes attempt to provide the <em>best shaped</em> triangles. However, for remapping, the overriding goal is to obtain predictability as to how the splitting occurs. As such, the <span class='code'>quadSplit</span> attribute on mesh shapes can be set to improve predictability.</p>
<p>The <span class='code'>quadSplit</span> option determines how quads are split into two triangles. If <strong>Left</strong> is selected, then the new edge will be between the 2nd and 4th vertex, while <strong>Right</strong> splits between the 1st and 4th vertex. <strong>Best Shape</strong> attempts to pick the best split based on the shape of the quad, but this may change as the shape deforms across an animation.</p>
<p>Thus, selecting either a Left or Right split will provide greater predictability.</p>
<div class='figure'><img src='dev_help/images/GeomRemap_Triangulation_MeshControls.png' title='' /></div>
<p>A Left split is shown in the images below. The dotted line shows where the split occurred.</p>
<div class='figure'><img src='dev_help/images/GeomRemap_Triangulation_QuadSplit.png' title='' /></div>
<p>If Best Shape is still desired, the reference logic for a quad is given below. The general algorithm handles general N-sided polygons, which may have holes, but is not included here.</p>
<div class="codeBlock"><pre class="prettyprint">v0 = quad vertex 0
v1 = quad vertex 1
v2 = quad vertex 2
v3 = quad vertex 3

dist02 = distance between v0 and v2
dist13 = distance between v1 and v3

// Use small tolerance so exact squares triangulate consistently
// one way rather than randomly due to rounding errors
fudgeFactor = 0.999f
canSplit = false
split02 = false

if( dist02 &lt; fudgeFactor*dist13 )
{
    n1 = normal of triangle 1, 2, 0
    n2 = normal of triangle 2, 3, 0

    if( angle between n1 and n2 is less than 90 degrees )
    {
        if( area of triangle1 &lt; 7 * area of triangle2 &amp;&amp;
                    area of triangle2 &lt; 7 * area of triangle1 )
        {
            canSplit = true
            split02 = true
        } 
    }
}
else
{
    n1 = normal of triangle 0, 1, 3
    n2 = normal of triangle 3, 1, 2

    if( angle between n1 and n2 is less than 90 degrees )
    {
        if( area of triangle1 &lt; 7 * area of triangle2 &amp;&amp;
                area of triangle2 &lt; 7 * area of triangle1 )
        {
            canSplit = true
            split02 = false
        } 
    }
}

if( canSplit )
{
    if( split02 )
    {
        set triangle 1 = 1,2,0
        set triangle 2 = 0,2,3
    }
    else
    { 
        set triangle 1 = 0,1,3
        set triangle 2 = 3,1,2
    }
}
else 
{
   // Fall back to general triangulation algorithm    
}
</pre></div><div class='section'><a id="mfnmesh-considerations"></a><h3 id="mfnmesh-considerations">MFnMesh considerations</h3></div>
<p>The triangulation option on <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnMesh</a></span> differs from those used internally and will always use a <strong>best shape</strong> option.</p>
<p>Remapping of indexing does not occur if the triangulation method on <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnMesh</a></span> is not called, and the interfaces that provide data for storage on an <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnMesh</a></span> do not reshuffle any data passed in. If the triangulation method is not called, then the internal triangulation logic will take into account the <span class='code'>quadSplit</span> option.</p>
<div class='section'><a id="smooth-mesh-preview-considerations"></a><h3 id="smooth-mesh-preview-considerations">Smooth Mesh Preview considerations</h3></div>
<p>It should be noted that, for Smooth Mesh Preview, the <span class='code'>quadSplit</span> option is not used.</p>
<div class='section'><a id="subdivision"></a><h2 id="subdivision">Subdivision</h2></div>
<p>The Smooth Mesh Preview option on polygonal shapes is another occasion where the original geometric data may be remapped. As the geometry provided at rendering will have a smoothing algorithm applied to produce a new set of geometry, additional logic is required to not only handle indexing on existing vertices, but also new vertices that have been introduced along with the corresponding new indexing.</p>
<p>The following sections discuss the mapping logic (rules) for uniform subdivision when using either OpenSubiv (OSD) or legacy Catmull-Clark logic. In particular, the <strong>winding order</strong> of vertices and faces and the <strong>local parametric (UV)</strong> location of new vertices is covered. The local parameterization can be remapped to texture coordinates as required for texture map lookups.</p>
<p>We refer to the original geometry as the <strong>base</strong> geometry. For example, an original face is a base face.</p>
<div class='section'><a id="maya-uniform-opensubdiv-subdivision"></a><h3 id="maya-uniform-opensubdiv-subdivision">Maya uniform OpenSubdiv subdivision</h3></div>
<div class='figure'><img src='dev_help/images/GeomRemap_OSD_windingOrder.png' title='' /></div>
<p>The figure above shows a base face (left image) and the start and winding order of the subdivided faces and vertices when 1 level of subdivision is applied (center and right images).</p>
<p>Levels closer to the base level are considered as being <em>higher</em>. The subdivided face ordering is thus shown to be consistent with higher levels. The start face is in the bottom-left corner which aligns to the start vertex on the base face. Similarly, the vertices on the subdivided faces also start from the bottom-left corner. The winding order is always counter-clockwise (CCW).</p>
<p>Assuming the origin of the local UV is located at vertex 0 of the base face, it is possible to deduce the local UV&#39;s of the vertices on the subdivided faces.</p>
<p>The following is the some sample code to determine the local parametric value.</p>
<div class="codeBlock"><pre class="prettyprint">// Get the UV of the bottom-left corner of the subdivided face.
//
// - subdFaceIndex, the index of subdivided face within a base face.
// - subdLevel, the Catmull-Clark subdivision level 
//
// such that: 
//
// - subdLevel &gt;= 1 
// - 0 &lt;= subdFaceIndex &lt;= 4^subdLevel
// - the UV value is encoded as an integer within [0, 2^subdLevel].
//
getSubFaceUV(subdFaceIndex, subdLevel) 
{
    uv = (0,0);

    count = pow(4, subdLevel - 1);
    ofs = pow(2, subdLevel - 1);

    // Iteratively find the index of a parent face in each subdivision level,
    // and offset the UV accordingly.
    faceIndex = subdFaceIndex;
    while (count &gt; 0) {        
        start = faceIndex / count;
        switch (start) {
            case 0:                  break;
            case 1: uv += (ofs,0);   break;
            case 2: uv += (ofs,ofs); break;
            case 3: uv += (0,ofs);   break;
        }

        faceIndex %= count;
        ofs &gt;&gt;= 1;
        count &gt;&gt;= 2;
    }    
    return uv;
}

// Get the UV of the vertex on the subdivided face.
//
// - subdFaceStartUV: the UV of the bottom-left corner of the subd face.
// - subdVertexIndex: vertex index on the subdivided face, 0~3.
//
getSubVertexUV(subdFaceStartUV, subdVertexIndex) {
    uv = (0,0);
    switch (subdVertexIndex) {
        case 0:              break;
        case 1: uv += (1,0); break;
        case 2: uv += (1,1); break;
        case 3: uv += (0,1); break;    
    }
    return subdFaceStartUV + uv;
}

subdFaceStartUV = getSubFaceUV(subdFaceIndex, subdLevel);
subdVertexUV = getSubVertexUV (subdFaceStartUV, subdVertexIndex);
subdVertexUV /= pow(2, subdLevel);
</pre></div><div class='section'><a id="maya-legacy-catmull-clark-subdivision"></a><h3 id="maya-legacy-catmull-clark-subdivision">Maya legacy Catmull-Clark subdivision</h3></div>
<p>The logic for Maya legacy subdivision is a little more complex.</p>
<div class='figure'><img src='dev_help/images/GeomRemap_Catmull_windingOrder.png' title='' /></div>
<p>The figure above shows a base face (left) and the start and winding order of the subdivided faces and vertices when 1 level of subdivision is applied (center and right images). The start of the subdivided face aligns to the second (index = 1) vertex on the base face, while the starting vertex continues to shift accordingly, based on the subdivided face number.</p>
<p>The following is the sample code. The sections of the code that differ from that of the OpenSubdiv algorithm is <strong>highlighted in bold</strong>.</p>
<div class="codeBlock"><pre class="prettyprint">// Get the UV of the bottom-left corner of the subdivided face.
// 
// - subdFaceIndex, the index of subdivided face within a base face
// - subdLevel, the Catmull-Clark subdivision level
// 
// such that:
//
// - subdLevel &gt;= 1. 
// - 0 &lt;= subdFaceIndex &lt;= 4^subdLevel,
// - the uv is encoded as integer within [0, 2^subdLevel].
//
getSubFaceUV(subdFaceIndex, subdLevel) {
    uv = (0,0);    
    start = 1;

    count = pow(4, subdLevel - 1);
    ofs = pow(2, subdLevel - 1);

    // Iteratively find the index of parent face in each subdivision level,
    // and offset the UV&#39;s accordingly.
    faceIndex = subdFaceIndex;
    while (count &gt; 0) {
        // Unlike OSD subdivided topology, the start position of the child face 
        // is related to that of the parent face.
        start = (start + faceIndex / count) % 4;
        switch (start) {
            case 0:                  break;
            case 1: uv += (ofs,0);   break;
            case 2: uv += (ofs,ofs); break;
            case 3: uv += (0,ofs);   break;
        }

        faceIndex %= count;
        ofs &gt;&gt;= 1;
        count &gt;&gt;= 2;
    }
    // The start position of the face is also returned.
    return (uv, start);
}

// Get the uv of the vertex on the subdivided face.
//
// - subdFaceStartUV, the UV of the bottom-left corner of the subdivided face.
// - subdVertexIndex, vertex index on the subdivided face, 0~3.
//
getSubVertexUV(subFaceStartIndex, subFaceStartUV, subdVertexIndex) {
    uv = (0,0);
    // Unlike OSD subdivided topology, the start of the vertex relies on 
    // the start position of the face.
    start = (subdFaceIndex - 1 + 4) % 4;
    switch ((start + subdVertexIndex) % 4) {
        case 0:              break;
        case 1: uv += (1,0); break;
        case 2: uv += (1,1); break;
        case 3: uv += (0,1); break;    
    }
    return subFaceStartUV + uv;
}

(subdFaceStartUV, start) = getSubFaceUV(subdFaceIndex, subdLevel);
subdVertexUV = getSubVertexUV(start, subdFaceStartUV, subdVertexIndex);
subdVertexUV /= pow(2, subdLevel);
</pre></div><div class='section'><a id="data-remapping-interfaces"></a><h2 id="data-remapping-interfaces">Data remapping interfaces</h2></div>
<p>For both Viewport 1 and Viewport 2.0, it is possible to retrieve remapped data by specifying the requirement for the following data buffers via the appropriate hardware shader interface. The following remapping data is currently available:</p>
<ul>
<li><p>Vertex ids</p></li>
<li><p>Face ids</p></li>
<li><p>Per face local parameterization</p></li>
</ul>
<p>The data can be used directly instead of computing the remapping at draw time using the logic previously described. In addition, the data is cached and is only updated as required when topological operations affect the polygonal shape.</p>
<p>When an object’s geometry has not been smoothed for display:</p>
<ul>
<li>The original face ids are returned in ascending order.</li>
<li><p>The original vertex ids are returned per face.</p></li>
<li><p>The local parameterization degenerates to a unit square per face.</p></li>
</ul>
<p>When smoothing for display is enabled:</p>
<ul>
<li><p>The base face ids are returned. The ordering is per subdivided faces in ascending order.</p></li>
<li><p>The subdivided vertex ids are returned. The ordering is per subdivided faces in ascending order. As vertices may be generated for display purposes, there will be vertex ids that do not correspond to any vertex on the base mesh. If desired, these vertices can be matched with the vertex ids on the smooth mesh geometry extracted via the <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnMesh</a></span> interface.</p></li>
<li><p>The local parameterization maps each vertex to a unit square on the base face. The ordering is per subdivided face in ascending order.</p></li>
</ul>
<p>The data buffers returned for VP1 and VP2 have consistent data and ordering, as long as the request for VP2 buffers includes a request for unshared data. Note that VP1 always returns unshared data.</p>
<p>If additional data is required for remapping, this can be done by adding additional per-vertex streams at the object level (such as color sets).</p>
<div class='section'><a id="viewport-1-mpxhwshadernode-access"></a><h3 id="viewport-1-mpxhwshadernode-access">Viewport 1: MPxHwShaderNode access</h3></div>
<p>To request additional information, the following API methods can be overridden by classes that derive from <span class='code'><a href="javascript:void(0)" data-symbol="MPxHwShaderNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_hw_shader_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxHwShaderNode</a></span>:</p>
<ul>
<li>Vertex ids can be requested by overriding the method:
<ul>
<li><span class='code'>bool <a href="javascript:void(0)" data-symbol="MPxHwShaderNode::provideVertexIDs()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_hw_shader_node.html#a8f7f3674c24e31185e58db1de5d02074&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxHwShaderNode::provideVertexIDs()</a></span></li>
</ul></li>
<li>Face ids can be requested by overriding the method:
<ul>
<li><span class='code'>bool <a href="javascript:void(0)" data-symbol="MPxHwShaderNode::provideFaceIDs()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html#afa61effad561b9564e161fe930bd038c&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxHwShaderNode::provideFaceIDs()</a></span></li>
</ul></li>
<li>Local parameterization can be requested by overriding the method:
<ul>
<li><span class='code'>bool <a href="javascript:void(0)" data-symbol="MPxHwShaderNode::provideLocalUVCoord()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html#a276892ea9def000206de6522deccc137&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxHwShaderNode::provideLocalUVCoord()</a></span></li>
</ul></li>
</ul>
<p>The information is cached and returned as CPU data buffers via the <span class='code'><a href="javascript:void(0)" data-symbol="MPxHwShaderNode::geometry()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_hw_shader_node.html#af1baeed92db0ea0cbf886dba96bc3ded&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxHwShaderNode::geometry()</a></span> or <span class='code'><a href="javascript:void(0)" data-symbol="MPxHwShaderNode::glGeometry()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html#a495a60eaa1df3815d5565e79e08c90ac&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_hw_shader_node.html#aaad4a5849a82c09fdd362affff51fcf4&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxHwShaderNode::glGeometry()</a></span> methods. The signature for <span class='code'>glGeometry()</span> is:</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MStatus</a> <a href="javascript:void(0)" data-symbol="MPxHwShaderNode::glGeometry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html#a495a60eaa1df3815d5565e79e08c90ac&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxHwShaderNode::glGeometry</a>( const <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDagPath</a>&amp; shapePath,
    int prim,
    unsigned int writable,
    int indexCount,
    const unsigned int * indexArray,
    int vertexCount,
    const int * vertexIDs,
    const float* vertexArray,
    int normalCount,
    floatArrayPtr normalArrays,
    int colorCount,
    floatArrayPtr colorArrays,
    int texCoordCount,
    floatArrayPtr texCoordArrays,
    const int * faceIDs,
    const float * localUVCoord)
</pre></div><p>Sample code to obtain this data can found in the <em>hwPhongShader</em> plug-in example. Below is a code sample from within the <span class='code'>glGeometry()</span> method implementation:</p>
<div class="codeBlock"><pre class="prettyprint">// Dump out vertexIDs
if (vertexIDs)
{
    for (int i=0; i&lt;vertexCount; i++)
    {
        printf(&quot;%d\n&quot;, vertexIDs[i]);
    }
}

// Dump out face IDs
if (faceIDs)
{
    for (int i=0; i&lt;vertexCount; i++)
    {
        printf(&quot;%d\n&quot;, faceIDs[i]);
    }
}
}

// Dump out float pairs for the local parameterization (UV)
if (localUVCoord)
{
    for (int i = 0; i &lt; vertexCount; i++)
    {
        printf(&quot;(%g, %g)\n&quot;, localUVCoord[i*2], localUVCoord[i*2 + 1]);
    }
}
</pre></div><div class='section'><a id="viewport-2.0-mpxshaderoverride-access"></a><h3 id="viewport-2.0-mpxshaderoverride-access">Viewport 2.0: MPxShaderOverride Access</h3></div>
<p>VP2 will not, by default, return completely unshared data. A new interface has been added to specify this requirement via:</p>
<ul>
<li><span class='code'>bool MPxShaderOverride::requiresUnsharedGeometricSteams()</span></li>
</ul>
<p>A plug-in can override this method to return true in order to force geometric streams to be expanded.</p>
<p>To obtain the face ids, vertex ids or local parametrization, the following <em>semantics</em> have been added (instead of a new interface on <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span>):</p>
<ul>
<li><p>vertexid : When set will return a vertex id buffer</p></li>
<li><p>faceid : When set will return a face id buffer</p></li>
<li><p>localuvcoord : When set will return a local UV coordinate buffer</p></li>
</ul>
<p>The following example code from the <em>hwPhongShader</em> plug-in example specifies three extra streams within its <span class='code'>initialize()</span> method.</p>
<div class="codeBlock"><pre class="prettyprint">// Ask for vertex IDs
<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> vertexIdDesc(
    empty,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kTexture</a>,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kFloat" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a5686197bafb177bdc82550848416a1ad&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kFloat</a>,
    1);
vertexIdDesc.setSemanticName(&quot;vertexid&quot;);
addGeometryRequirement(vertexIdDesc);

// Ask for face IDs
<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> faceIdDesc(
    empty,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kTexture</a>,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kFloat" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a5686197bafb177bdc82550848416a1ad&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kFloat</a>,
    1);
faceIdDesc.setSemanticName(&quot;faceid&quot;);
addGeometryRequirement(faceIdDesc);

// Ask for local parameterization data
<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> localUvCoordDesc(
    empty,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kTexture</a>,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kFloat" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a5686197bafb177bdc82550848416a1ad&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kFloat</a>,
    1);
faceIdDesc.setSemanticName(&quot;localuvcoord&quot;);
addGeometryRequirement(localUvCoordDesc);

</pre></div><p>Sample extraction code (also from the same plug-in) is shown here:</p>
<div class="codeBlock"><pre class="prettyprint">for (int vbIdx=0; vbIdx&lt;geometry-&gt;vertexBufferCount(); vbIdx++)
{
    const <a href="javascript:void(0)" data-symbol="MHWRender::MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBuffer</a>* vb = geometry-&gt;vertexBuffer(vbIdx);
    if (!vb) continue;

    const <a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a>&amp; desc = vb-&gt;descriptor();
    if (desc.dimension() != 1) continue;

    // Check if semantic is for the streams we’re looking for.
    <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> semanticName = desc.semanticName();

    // Dump out local parameterization. Each pair of float values gives
    // a local UV on the base face.
    if (semanticName == &quot;localuvcoord&quot;)
    {
        // Cancel constness to map buffer and dump data.
        <a href="javascript:void(0)" data-symbol="MHWRender::MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBuffer</a>* 
        nonConstVB = const_cast&lt;<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBuffer</a>*&gt;(vb);
    
        const float *ptr = (const float*)nonConstVB-&gt;map();
        for (unsigned int k = 0; k &lt; vb-&gt;vertexCount(); k++)
        {
            printf(&quot;%s[%d] = (%g, %g)\n&quot;, semanticName.asChar(), 
                k, ptr[2*k], ptr[2*k + 1]);
        }
        nonConstVB-&gt;unmap();
    }

    // Dump out vertex or face identifiers. If smoothed the vertex ids will be
    // the smoothed ids, but the face ids are always the base face ids.
    //
    if (semanticName != &quot;vertexid&quot; &amp;&amp; semanticName != &quot;faceid&quot;) continue;

    <a href="javascript:void(0)" data-symbol="MHWRender::MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBuffer</a>* nonConstVB = const_cast&lt;<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBuffer</a>*&gt;(vb);
    const float *ptr = (const float*)nonConstVB-&gt;map();
    for (unsigned int k=0; k&lt;vb-&gt;vertexCount(); k++)
    {
        printf(&quot;%s[%d] = %f\n&quot;, semanticName.asChar(), k, ptr[k] );
    }
    nonConstVB-&gt;unmap();
}
</pre></div><div class='section'><a id="viewport-2.0-mgeometryextractor-access"></a><h3 id="viewport-2.0-mgeometryextractor-access">Viewport 2.0: MGeometryExtractor Access</h3></div>
<p>Viewport 2.0 also exposes the access of vertex ids, face ids and local parameterization via the <span class='code'><a href="javascript:void(0)" data-symbol="MGeometryExtractor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MGeometryExtractor</a></span> interface. To extract completely unshared geometric data from a DAG shape, <span class='code'>kPolyGeom_NotSharing</span> needs to be specified when constructing an <span class='code'><a href="javascript:void(0)" data-symbol="MGeometryExtractor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MGeometryExtractor</a></span> instance.</p>
<p>Example code from the <em>geometryReplicator</em> plug-in is shown here.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MStatus</a> status;
MHWRender::MPolyGeomOptions options = MHWRender::kPolyGeom_Normal;
if (requiresUnsharedGeometricStreams(requirements))
{
    options = options | MHWRender::kPolyGeom_NotSharing;
}
<a href="javascript:void(0)" data-symbol="MHWRender::MGeometryExtractor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometryExtractor</a> extractor(requirements, fPath, options, &amp;status);
</pre></div><p>The following code snippet illustrates how the <em>geometryReplicator</em> plug-in determines whether unshared data is required, according to the geometry requirements.</p>
<div class="codeBlock"><pre class="prettyprint">bool requiresUnsharedGeometricStreams(const <a href="javascript:void(0)" data-symbol="MHWRender::MGeometryRequirements" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_requirements.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometryRequirements</a>&amp; requirements)
{
    // Only when vertexid, faceid or localuvcoord is required do the unshared geometric
    // streams need to be extracted
    const <a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptorList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptorList</a>&amp; descList = requirements.vertexRequirements();
    for (int reqNum = 0; reqNum &lt; descList.length(); ++reqNum)
    {
        <a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> desc;
        if (descList.getDescriptor(reqNum, desc) &amp;&amp;
            desc.semantic() == <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kTexture</a>)
        {
            const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> semanticName = desc.semanticName();
            if (semanticName == &quot;vertexid&quot; ||
                semanticName == &quot;faceid&quot; ||
                semanticName == &quot;localuvcoord&quot;)
            {
                    return true;
            }
        }
    }
    return false;
}
</pre></div><p>Similar to <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span>, there is no new interface on <span class='code'><a href="javascript:void(0)" data-symbol="MGeometryExtractor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MGeometryExtractor</a></span> that requests vertex ids, face ids or local parameterization. Instead <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBufferDescriptor</a></span> should be specified with the following semantic names to populate these vertex buffers:</p>
<ul>
<li>“vertexid” : When set, will return a vertex id buffer</li>
<li>“faceid” : When set, will return a face id buffer</li>
<li>“localuvcoord” : When set, will return a local uv coordinate buffer</li>
</ul>
<p>Although these semantic names are not specified directly in the <em>geometryReplicator</em> plug-in, they will be included in the geometry requirements if a <em>geometryReplicator</em> node is assigned a <em>hwPhongShader</em>. The following example illustrates how to specify any of them explicitly.</p>
<div class="codeBlock"><pre class="prettyprint">// Request vertex IDs (or face IDs, local parameterization)
<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> vertexIdDesc(
    empty,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kTexture</a>,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kFloat" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a5686197bafb177bdc82550848416a1ad&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kFloat</a>,
    1);
vertexIdDesc.setSemanticName(&quot;vertexid&quot;);

// Create a vertex buffer via MGeometry interface, extract and fill the data.
<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBuffer</a> vertexBuffer = geometry.createVertexBuffer(vertexIdDesc);
unsigned int vertexCount = extractor.vertexCount();
float* data = (float*)vertexBuffer-&gt;acquire(vertexCount, true);
if (data &amp;&amp; extractor.populateVertexBuffer(data, vertexCount, vertexIdDesc))
{
    vertexBuffer-&gt;commit(data);
}
</pre></div><div class='section'><a id="accessing-data-via-index-buffers"></a><h3 id="accessing-data-via-index-buffers">Accessing data via index buffers</h3></div>
<p>Index buffers that are provided at render time can be used to access the data buffers on a per triangle basis.</p>
<p>As VP1 has no consolidation, and vertices are unshared, every 3 indices reference a vertex id for a triangle in ascending face order.</p>
<p>For VP2, consolidation may result in a set of sub-ranges in the index buffer. Each range delineates the data used for each object that was consolidated. To avoid ambiguous mapping, unshared data should always be requested. Refer to <a href='#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Effect-Overrides.html#consolidation-considerations' title=''>Consolidation considerations</a> for more details on range handling.</p>
<p>The <em>hwPhongShader</em> plug-in includes sample code that demonstrates how to extract indexing information for both VP1 and VP2. For VP2, range handling sample debugging code is provided.</p>
<div class='section'><a id="example-1-unsmoothed-quad"></a><h3 id="example-1-unsmoothed-quad">Example 1: Unsmoothed quad</h3></div>
<div class='figure'><img src='dev_help/images/GeomRemap_UnsmoothedQuad.png' title='' /></div>
<p>To examine the remapping that occurs, the <em>hwPhongShader</em> plug-in which uses the API to extract additional data buffers is used for an example. In this case, an instance of that shader is assigned to a shape with a single quad as shown above. The base face id and base vertex ids are shown, as well as the start vertex (dot) and winding order (curved arrow).</p>
<p>The render time buffers would look like this:</p>
<table class='ruled'>
<tr class="header">
<th align="left">Vertex Id (CCW winding)</th>
<th align="left">Face id</th>
<th align="left">Local UV</th>
</tr>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0,0)</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">(0,1)</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">0</td>
<td align="left">(1,1)</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">0</td>
<td align="left">(1,0)</td>
</tr>
</table>
<div class='section'><a id="example-2-smoothed-level-1-quad---opensubdiv-catmull-clark"></a><h3 id="example-2-smoothed-level-1-quad---opensubdiv-catmull-clark">Example 2: Smoothed Level 1 Quad - OpenSubdiv Catmull-Clark</h3></div>
<div class='figure'><img src='dev_help/images/GeomRemap_SmoothedLevel1Quad_OpenSubd.png' title='' /></div>
<p>The topology shown above demonstrates one level of smoothing using OpenSubdiv. The start and winding order per sub-face and sub vertex is consistent for all levels with the base face.</p>
<p>The data buffers would appear as follows. Note that:</p>
<ul>
<li><p>The Sub-Face Id column is added to show its correlation to the topology shown above, but is not provided as a separate vertex buffer.</p></li>
<li><p>Vertex ids 6 to 8 are not part of the base mesh.</p>
<p>Vertex ids 4, 5, 6, 7, 8 are vertices introduced as part of smoothing. The base mesh has vertices 0, 1, 2, 3. The dotted lines show where the subdivision occurred due to the smoothing operation.</p></li>
<li><p><strong>The local parameterization simply provides values to show the interpolation relative to the base vertices</strong>, and is not related to the actual placement of the vertex within the base face. For example, if vertex 8 was actually positioned close to vertex 0, the local UV value would still be (0.5,0.5), such as in this geometry:</p>
<div class='figure'><img src='dev_help/images/GeomRemap_SmoothedLevel1Quad_OpenSubd2.png' title='' /></div></li>
</ul>
<table class='ruled'>
<tr class="header">
<th align="left">Vertex Id (CCW)</th>
<th align="left">Face Id</th>
<th align="left">Sub-Face Id</th>
<th align="left">Local UV</th>
</tr>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0,0)</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0,0.5)</td>
</tr>
<tr class="odd">
<td align="left">8</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0.5,0.5)</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0.5,0)</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">(0,0.5)</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">(0,1)</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">(0.5,1)</td>
</tr>
<tr class="even">
<td align="left">8</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">(0.5,0.5)</td>
</tr>
<tr class="odd">
<td align="left">8</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">(0.5,0.5)</td>
</tr>
<tr class="even">
<td align="left">6</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">(0.5,1)</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">(1,1)</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">(1,0.5)</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">(0.5,0)</td>
</tr>
<tr class="even">
<td align="left">8</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">(0.5,0.5)</td>
</tr>
<tr class="odd">
<td align="left">7</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">(1,0.5)</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">(1,0)</td>
</tr>
</table>
<p>The provided index buffer can be used to access information per triangle.</p>
<p>As noted, the triangle split may not match the value specified for the <span class='code'>quadSpit</span> attribute on the polygonal shape. If we are given this triangulation:</p>
<div class='figure'><img src='dev_help/images/GeomRemap_SmoothedLevel1Quad_Triangulation.png' title='' /></div>
<p>Then the index buffer would look something like this.</p>
<table class='ruled'>
<tr class="header">
<th align="left">Triangle Number</th>
<th align="left">Vertex Id</th>
</tr>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">5</td>
</tr>
<tr class="odd">
<td align="left">0</td>
<td align="left">4</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">4</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">5</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">8</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">5</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">8</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">8</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">6</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">8</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">7</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">7</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">6</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">3</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">4</td>
</tr>
<tr class="even">
<td align="left">6</td>
<td align="left">8</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">7</td>
<td align="left">8</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">7</td>
</tr>
</table>
<div class='section'><a id="example-3-smoothed-level-1-quad-legacy-catmull-clark"></a><h3 id="example-3-smoothed-level-1-quad-legacy-catmull-clark">Example 3: Smoothed Level 1 Quad – Legacy Catmull-Clark</h3></div>
<div class='figure'><img src='dev_help/images/GeomRemap_SmoothedLevel1Quad_LegacyCatmull.png' title='' /></div>
<p>The topology above demonstrates one level of smoothing using the Legacy Catmull-Clark subdivision method. The shifting of the start of sub-faces and sub-vertices can be seen.</p>
<p>The data buffers would be as follows. As in Example 2, the Sub-Face Id column is added to show its correlation to the topology shown above, and is not provided as a buffer.</p>
<p>The shift in sub-face and sub-vertex start positions reflects what is shown in the diagram.</p>
<table class='ruled'>
<tr class="header">
<th align="left">Vertex Id (CCW)</th>
<th align="left">Face Id</th>
<th align="left">Sub-Face Id</th>
<th align="left">Local UV</th>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0,0.5)</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0,1)</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0.5,1)</td>
</tr>
<tr class="even">
<td align="left">8</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0.5,0.5)</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">(0.5,1)</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">(1,1)</td>
</tr>
<tr class="odd">
<td align="left">7</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">(1,0.5)</td>
</tr>
<tr class="even">
<td align="left">8</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">(0.5,0.5)</td>
</tr>
<tr class="odd">
<td align="left">7</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">(1,0.5)</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">(1,0)</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">(0.5,0)</td>
</tr>
<tr class="even">
<td align="left">8</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">(0.5,0.5)</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">(0.5,0)</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">(0,0)</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">(0,0.5)</td>
</tr>
<tr class="even">
<td align="left">8</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">(0.5,0.5)</td>
</tr>
</table>
<p>Legacy Catmull-Clark has different indexing than OpenSubdiv Catmull-Clark, based on the fact that its start face and start vertices differ. Therefore, using the same example, the triangulation appears as follows:</p>
<div class='figure'><img src='dev_help/images/GeomRemap_SmoothedLevel1Quad_LegacyCatmull_Triangulate.png' title='' /></div>
<p>The indexing would be as follows:</p>
<table class='ruled'>
<tr class="header">
<th align="left">Triangle number</th>
<th align="left">Vertex Id</th>
</tr>
<tr class="odd">
<td align="left">0</td>
<td align="left">4</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">0</td>
<td align="left">8</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">8</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">6</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">6</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">3</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">8</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">8</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">7</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">7</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">8</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">8</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">5</td>
</tr>
<tr class="even">
<td align="left">6</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">8</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">8</td>
</tr>
<tr class="odd">
<td align="left">7</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">4</td>
</tr>
</table>
<div class='section'><a id="example-4-smoothed-level-2-quad-legacy-catmull-clark"></a><h3 id="example-4-smoothed-level-2-quad-legacy-catmull-clark">Example 4: Smoothed Level 2 Quad – Legacy Catmull-Clark</h3></div>
<p>The following image shows a subdivision of level 2 using the Legacy Catmull-Clark method, and illustrates a repeat of the subdivision pattern.</p>
<div class='figure'><img src='dev_help/images/GeomRemap_SmoothedLevel2Quad_LegacyCatmull.png' title='' /></div>
<p>With the following data trace from the <em>hwPhongShader</em> plug-in:</p>
<table cellpadding="0" cellspacing="0" class="ruled">
<colgroup>
<col />
<col />
<col />
<col />
</colgroup>
<tbody>
<tr class="ruled-heading">
<th class="table-heading">
<em class="strong">Vertex Id (CCW)</em>
</th>
<th class="table-heading">
<em class="strong">Face Id</em>
</th>
<th class="table-heading">
<em class="strong">Sub-Face Id</em>
</th>
<th class="table-heading">
<em class="strong">Local UV</em>
</th>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
10
</td>
<td class="table-body">
0
</td>
<td class="table-body">
0
</td>
<td class="table-body">
(0, 0.75)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
1
</td>
<td class="table-body">
0
</td>
<td class="table-body">
0
</td>
<td class="table-body">
(0, 1)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
13
</td>
<td class="table-body">
0
</td>
<td class="table-body">
0
</td>
<td class="table-body">
(0.25, 1)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
21
</td>
<td class="table-body">
0
</td>
<td class="table-body">
0
</td>
<td class="table-body">
(0.25, 0.75)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
13
</td>
<td class="table-body">
0
</td>
<td class="table-body">
1
</td>
<td class="table-body">
(0.25, 1)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
6
</td>
<td class="table-body">
0
</td>
<td class="table-body">
1
</td>
<td class="table-body">
(0.5, 1)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
18
</td>
<td class="table-body">
0
</td>
<td class="table-body">
1
</td>
<td class="table-body">
(0.5, 0.75)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
21
</td>
<td class="table-body">
0
</td>
<td class="table-body">
1
</td>
<td class="table-body">
(0.25, 0.75)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
18
</td>
<td class="table-body">
0
</td>
<td class="table-body">
2
</td>
<td class="table-body">
(0.5, 0.75)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
8
</td>
<td class="table-body">
0
</td>
<td class="table-body">
2
</td>
<td class="table-body">
(0.5, 0.5)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
17
</td>
<td class="table-body">
0
</td>
<td class="table-body">
2
</td>
<td class="table-body">
(0.25, 0.5)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
21
</td>
<td class="table-body">
0
</td>
<td class="table-body">
2
</td>
<td class="table-body">
(0.25, 0.75)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
17
</td>
<td class="table-body">
0
</td>
<td class="table-body">
3
</td>
<td class="table-body">
(0.25, 0.5)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
4
</td>
<td class="table-body">
0
</td>
<td class="table-body">
3
</td>
<td class="table-body">
(0, 0.5)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
10
</td>
<td class="table-body">
0
</td>
<td class="table-body">
3
</td>
<td class="table-body">
(0, 0.75)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
21
</td>
<td class="table-body">
0
</td>
<td class="table-body">
3
</td>
<td class="table-body">
(0.25, 0.75)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
14
</td>
<td class="table-body">
0
</td>
<td class="table-body">
4
</td>
<td class="table-body">
(0.75, 1)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
3
</td>
<td class="table-body">
0
</td>
<td class="table-body">
4
</td>
<td class="table-body">
(1, 1)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
16
</td>
<td class="table-body">
0
</td>
<td class="table-body">
4
</td>
<td class="table-body">
(1, 0.75)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
22
</td>
<td class="table-body">
0
</td>
<td class="table-body">
4
</td>
<td class="table-body">
(0.75, 0.75)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
16
</td>
<td class="table-body">
0
</td>
<td class="table-body">
5
</td>
<td class="table-body">
(1, 0.75)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
7
</td>
<td class="table-body">
0
</td>
<td class="table-body">
5
</td>
<td class="table-body">
(1, 0.5)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
19
</td>
<td class="table-body">
0
</td>
<td class="table-body">
5
</td>
<td class="table-body">
(0.75, 0.5)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
22
</td>
<td class="table-body">
0
</td>
<td class="table-body">
5
</td>
<td class="table-body">
(0.75, 0.75)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
19
</td>
<td class="table-body">
0
</td>
<td class="table-body">
6
</td>
<td class="table-body">
(0.75, 0.5)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
8
</td>
<td class="table-body">
0
</td>
<td class="table-body">
6
</td>
<td class="table-body">
(0.5, 0.5)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
18
</td>
<td class="table-body">
0
</td>
<td class="table-body">
6
</td>
<td class="table-body">
(0.5, 0.75)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
22
</td>
<td class="table-body">
0
</td>
<td class="table-body">
6
</td>
<td class="table-body">
(0.75, 0.75)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
18
</td>
<td class="table-body">
0
</td>
<td class="table-body">
7
</td>
<td class="table-body">
(0.5, 0.75)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
6
</td>
<td class="table-body">
0
</td>
<td class="table-body">
7
</td>
<td class="table-body">
(0.5, 1)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
14
</td>
<td class="table-body">
0
</td>
<td class="table-body">
7
</td>
<td class="table-body">
(0.75, 1)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
22
</td>
<td class="table-body">
0
</td>
<td class="table-body">
7
</td>
<td class="table-body">
(0.75, 0.75)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
15
</td>
<td class="table-body">
0
</td>
<td class="table-body">
8
</td>
<td class="table-body">
(1, 0.25)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
2
</td>
<td class="table-body">
0
</td>
<td class="table-body">
8
</td>
<td class="table-body">
(1, 0)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
12
</td>
<td class="table-body">
0
</td>
<td class="table-body">
8
</td>
<td class="table-body">
(0.75, 0)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
23
</td>
<td class="table-body">
0
</td>
<td class="table-body">
8
</td>
<td class="table-body">
(0.75, 0.25)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
12
</td>
<td class="table-body">
0
</td>
<td class="table-body">
9
</td>
<td class="table-body">
(0.75, 0)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
5
</td>
<td class="table-body">
0
</td>
<td class="table-body">
9
</td>
<td class="table-body">
(0.5, 0)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
20
</td>
<td class="table-body">
0
</td>
<td class="table-body">
9
</td>
<td class="table-body">
(0.5, 0.25)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
23
</td>
<td class="table-body">
0
</td>
<td class="table-body">
9
</td>
<td class="table-body">
(0.75, 0.25)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
20
</td>
<td class="table-body">
0
</td>
<td class="table-body">
10
</td>
<td class="table-body">
(0.5, 0.25)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
8
</td>
<td class="table-body">
0
</td>
<td class="table-body">
10
</td>
<td class="table-body">
(0.5, 0.5)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
19
</td>
<td class="table-body">
0
</td>
<td class="table-body">
10
</td>
<td class="table-body">
(0.75, 0.5)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
23
</td>
<td class="table-body">
0
</td>
<td class="table-body">
10
</td>
<td class="table-body">
(0.75, 0.25)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
19
</td>
<td class="table-body">
0
</td>
<td class="table-body">
11
</td>
<td class="table-body">
(0.75, 0.5)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
7
</td>
<td class="table-body">
0
</td>
<td class="table-body">
11
</td>
<td class="table-body">
(1, 0.5)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
15
</td>
<td class="table-body">
0
</td>
<td class="table-body">
11
</td>
<td class="table-body">
(1, 0.25)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
23
</td>
<td class="table-body">
0
</td>
<td class="table-body">
11
</td>
<td class="table-body">
(0.75, 0.25)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
11
</td>
<td class="table-body">
0
</td>
<td class="table-body">
12
</td>
<td class="table-body">
(0.25, 0)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
0
</td>
<td class="table-body">
0
</td>
<td class="table-body">
12
</td>
<td class="table-body">
(0, 0)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
9
</td>
<td class="table-body">
0
</td>
<td class="table-body">
12
</td>
<td class="table-body">
(0, 0.25)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
24
</td>
<td class="table-body">
0
</td>
<td class="table-body">
12
</td>
<td class="table-body">
(0.25, 0.25)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
9
</td>
<td class="table-body">
0
</td>
<td class="table-body">
13
</td>
<td class="table-body">
(0, 0.25)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
4
</td>
<td class="table-body">
0
</td>
<td class="table-body">
13
</td>
<td class="table-body">
(0, 0.5)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
17
</td>
<td class="table-body">
0
</td>
<td class="table-body">
13
</td>
<td class="table-body">
(0.25, 0.5)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
24
</td>
<td class="table-body">
0
</td>
<td class="table-body">
13
</td>
<td class="table-body">
(0.25, 0.25)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
17
</td>
<td class="table-body">
0
</td>
<td class="table-body">
14
</td>
<td class="table-body">
(0.25, 0.5)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
8
</td>
<td class="table-body">
0
</td>
<td class="table-body">
14
</td>
<td class="table-body">
(0.5, 0.5)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
20
</td>
<td class="table-body">
0
</td>
<td class="table-body">
14
</td>
<td class="table-body">
(0.5, 0.25)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
24
</td>
<td class="table-body">
0
</td>
<td class="table-body">
14
</td>
<td class="table-body">
(0.25, 0.25)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
20
</td>
<td class="table-body">
0
</td>
<td class="table-body">
15
</td>
<td class="table-body">
(0.5, 0.25)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
5
</td>
<td class="table-body">
0
</td>
<td class="table-body">
15
</td>
<td class="table-body">
(0.5, 0)
</td>
</tr>
<tr class="ruled-odd-row">
<td class="table-body">
11
</td>
<td class="table-body">
0
</td>
<td class="table-body">
15
</td>
<td class="table-body">
(0.25, 0)
</td>
</tr>
<tr class="ruled-even-row">
<td class="table-body">
24
</td>
<td class="table-body">
0
</td>
<td class="table-body">
15
</td>
<td class="table-body">
(0.25, 0.25)
</td>
</tr>
</tbody>
</table>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
