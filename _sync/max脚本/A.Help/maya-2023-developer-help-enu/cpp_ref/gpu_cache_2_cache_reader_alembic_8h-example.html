<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
      <title>C++ API Reference: gpuCache/CacheReaderAlembic.h</title>
      
	  
      
      
      
      
      
      
      
    

</head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2_cache_reader_alembic_8h-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
      <div>
         <div class="head">
            <h1>C++ API Reference: gpuCache/CacheReaderAlembic.h</h1>
         </div>

<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->

  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="cpp_ref/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="cpp_ref/search/close.png" alt=""></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<!-- window showing the filter options -->


<!-- iframe showing the search results (closed by default) -->


<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/CacheReaderAlembic.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _CacheReaderAlembic_h_</span></div>
<div class="line"><span class="preprocessor">#define _CacheReaderAlembic_h_</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Includes</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/cxx17_enter_legacy_scope.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcCoreAbstract/TimeSampling.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/Abc/IArchive.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcGeom/INuPatch.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcGeom/IPolyMesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcGeom/ISubD.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcGeom/IXform.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcMaterial/IMaterial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/AbcMaterial/MaterialAssignment.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/cxx17_exit_legacy_scope.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;CacheReader.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MString.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MTime.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFileObject.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMeshData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNurbsSurface.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNurbsSurfaceData.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"><span class="comment">// Forward Declarations</span></div>
<div class="line"><span class="keyword">class </span>AlembicCacheReader;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>CacheReaderAlembicPrivate {</div>
<div class="line"></div>
<div class="line"><span class="comment">// Forward Declarations</span></div>
<div class="line"><span class="keyword">class </span>AlembicCacheMeshReader;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> Alembic::Abc::index_t           index_t; </div>
<div class="line"><span class="keyword">typedef</span> Alembic::Abc::chrono_t          chrono_t;</div>
<div class="line"><span class="keyword">typedef</span> Alembic::AbcGeom::IXformSchema  IXformSchema;</div>
<div class="line"><span class="keyword">typedef</span> Alembic::AbcGeom::XformSample   XformSample;</div>
<div class="line"><span class="keyword">typedef</span> Alembic::AbcGeom::XformOp       XformOp;</div>
<div class="line"><span class="keyword">typedef</span> Alembic::AbcCoreAbstract::TimeSamplingPtr TimeSamplingPtr;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS BaseTypeOfElem</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ElemType&gt;</div>
<div class="line"><span class="keyword">struct </span>BaseTypeOfElem</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// When the element type is already a POD...</span></div>
<div class="line">    <span class="keyword">typedef</span> ElemType value_type;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kDimensions = 1;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Alembic stores index buffer as signed integers, while this</span></div>
<div class="line"><span class="comment">// plug-in handles them as unsigned integers...</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>BaseTypeOfElem&lt;int32_t&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// When the element type is already a POD...</span></div>
<div class="line">    <span class="keyword">typedef</span> uint32_t value_type;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kDimensions = 1;</div>
<div class="line">};</div>
<div class="line">    </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>BaseTypeOfElem&lt;Imath::Vec2&lt;T&gt; &gt; </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> T value_type;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kDimensions = 2;</div>
<div class="line">};</div>
<div class="line">    </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>BaseTypeOfElem&lt;Imath::Vec3&lt;T&gt; &gt; </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> T value_type;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kDimensions = 3;</div>
<div class="line">};</div>
<div class="line">    </div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicArray</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// A wrapper around alembic sample arrays</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayProperty&gt;</div>
<div class="line"><span class="keyword">class </span>AlembicArray :</div>
<div class="line">    <span class="keyword">public</span> ReadableArray&lt;</div>
<div class="line">    typename BaseTypeOfElem&lt;</div>
<div class="line">        typename ArrayProperty::traits_type::value_type</div>
<div class="line">        &gt;::value_type</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">    <span class="comment">/*----- member functions -----*/</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ArrayProperty::sample_ptr_type ArraySamplePtr;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ArrayProperty::traits_type traits_type;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseTypeOfElem&lt;typename traits_type::value_type&gt;::value_type T;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Array&lt;T&gt;::Digest Digest;</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kDimensions =</div>
<div class="line">        BaseTypeOfElem&lt;typename traits_type::value_type&gt;::kDimensions;</div>
<div class="line">        </div>
<div class="line">    <span class="comment">// Returns a pointer to an Array that has the same content as the</span></div>
<div class="line">    <span class="comment">// buffer passed-in as determined by the computed digest hash-key.</span></div>
<div class="line">    <span class="keyword">static</span> std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; create(</div>
<div class="line">        <span class="keyword">const</span> ArraySamplePtr&amp; arraySamplePtr, <span class="keyword">const</span> Digest&amp; digest );</div>
<div class="line"></div>
<div class="line">    ~AlembicArray() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">const</span> T* <span class="keyword">get</span>() <span class="keyword">const</span> <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">    <span class="comment">/*----- member functions -----*/</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// The constructor is declare private to force user to go through</span></div>
<div class="line">    <span class="comment">// the create() factory member function.</span></div>
<div class="line">    <span class="keyword">struct </span>MakeSharedEnabler;</div>
<div class="line"> </div>
<div class="line">    AlembicArray(</div>
<div class="line">        <span class="keyword">const</span> ArraySamplePtr&amp; arraySamplePtr, <span class="keyword">const</span> Digest&amp; digest</div>
<div class="line">    )</div>
<div class="line">        : ReadableArray&lt;T&gt;(</div>
<div class="line">            arraySamplePtr-&gt;size() * kDimensions, digest),</div>
<div class="line">          fArraySamplePtr(arraySamplePtr)</div>
<div class="line">    {</div>
<div class="line">        assert(traits_type::dataType().getExtent() == kDimensions);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*----- data members -----*/</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> ArraySamplePtr    fArraySamplePtr;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS PropertyCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PROPERTY, <span class="keyword">typename</span> KEY, <span class="keyword">typename</span> VALUE, <span class="keyword">typename</span> DERIVED&gt;</div>
<div class="line"><span class="keyword">class </span>PropertyCache </div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> PROPERTY    Property;</div>
<div class="line">    <span class="keyword">typedef</span> KEY         Key;</div>
<div class="line">    <span class="keyword">typedef</span> VALUE       Value;</div>
<div class="line">    <span class="keyword">typedef</span> DERIVED     Derived;</div>
<div class="line"></div>
<div class="line">    PropertyCache()</div>
<div class="line">        : fValidityInterval(TimeInterval::kInvalid)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> reset()</div>
<div class="line">    {</div>
<div class="line">        fProperty = Property();</div>
<div class="line">        fValidityInterval = TimeInterval(TimeInterval::kInvalid);</div>
<div class="line">        fValue = Value();</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    <span class="keywordtype">bool</span> valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> fProperty.valid();</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    <span class="keywordtype">void</span> init(<span class="keyword">const</span> Property&amp; property)</div>
<div class="line">    {</div>
<div class="line">        this-&gt;fProperty = property;</div>
<div class="line">            </div>
<div class="line">        <span class="keyword">const</span> index_t numSamples       = this-&gt;fProperty.getNumSamples();</div>
<div class="line">        <span class="keyword">const</span> TimeSamplingPtr sampling = this-&gt;fProperty.getTimeSampling();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (this-&gt;fProperty.isConstant()) {</div>
<div class="line">            <span class="comment">// Delay the read of constant properties until the first call to setTime()</span></div>
<div class="line">            fValidityInterval = TimeInterval(TimeInterval::kInvalid);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// We need to read-in all the sample keys in</span></div>
<div class="line">            <span class="comment">// sequential order to determine which keys are</span></div>
<div class="line">            <span class="comment">// truly unique. This has to be done at init time</span></div>
<div class="line">            <span class="comment">// because later on, it is possible that the samples</span></div>
<div class="line">            <span class="comment">// be asked in random order and it will be difficult</span></div>
<div class="line">            <span class="comment">// to determine the validity interval of the returned</span></div>
<div class="line">            <span class="comment">// sample.</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// There is always a sample at index 0!</span></div>
<div class="line">            this-&gt;fUniqueSampleIndexes.push_back(0);</div>
<div class="line">            this-&gt;fTimeBoundaries.push_back(-std::numeric_limits&lt;chrono_t&gt;::infinity());</div>
<div class="line">            Key prevKey;</div>
<div class="line">            <span class="keyword">static_cast&lt;</span>Derived*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;getKey(prevKey, 0);</div>
<div class="line">            <span class="keywordflow">for</span> (index_t i=1; i&lt;numSamples; ++i) {</div>
<div class="line">                Key key;</div>
<div class="line">                <span class="keyword">static_cast&lt;</span>Derived*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;getKey(key, i);</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (key != prevKey) {</div>
<div class="line">                    this-&gt;fUniqueSampleIndexes.push_back(i);</div>
<div class="line">                    <span class="comment">// We store the time at which a sample stop being</span></div>
<div class="line">                    <span class="comment">// valid. This is reprented by the mid-way point</span></div>
<div class="line">                    <span class="comment">// between 2 samples.</span></div>
<div class="line">                    this-&gt;fTimeBoundaries.push_back(</div>
<div class="line">                        0.5 * (sampling-&gt;getSampleTime(i-1) + sampling-&gt;getSampleTime(i))</div>
<div class="line">                    );</div>
<div class="line">                    prevKey = key;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            this-&gt;fTimeBoundaries.push_back(+std::numeric_limits&lt;chrono_t&gt;::infinity());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> setTime(chrono_t time)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (fProperty.isConstant())</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Delayed read of constant properties.</span></div>
<div class="line">            <span class="keywordflow">if</span> (!fValidityInterval.valid()) {</div>
<div class="line">                <span class="keyword">static_cast&lt;</span>Derived*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;readValue(0);</div>
<div class="line">                <span class="comment">// If an IXform node is constant identity, getNumSamples() returns 0</span></div>
<div class="line">                fValidityInterval = TimeInterval(TimeInterval::kInfinite);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (fValidityInterval.contains(time)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        std::vector&lt;chrono_t&gt;::const_iterator bgn = fTimeBoundaries.begin();</div>
<div class="line">        std::vector&lt;chrono_t&gt;::const_iterator end = fTimeBoundaries.end();</div>
<div class="line">        std::vector&lt;chrono_t&gt;::const_iterator it = std::upper_bound(</div>
<div class="line">            bgn, end, time);</div>
<div class="line">        assert(it != bgn);</div>
<div class="line">        </div>
<div class="line">        index_t idx = fUniqueSampleIndexes[std::distance(bgn, it) - 1];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Do this first for exception safety.</span></div>
<div class="line">        <span class="keyword">static_cast&lt;</span>Derived*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;readValue(idx);</div>
<div class="line">            </div>
<div class="line">        <span class="comment">// Ok, we have successfully read the value. We can</span></div>
<div class="line">        <span class="comment">// now update the time information.</span></div>
<div class="line">        fValidityInterval = TimeInterval(*(it-1), *it);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Value&amp; getValue()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> fValue;</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    TimeInterval getValidityInterval()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> fValidityInterval;</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    Property              fProperty;</div>
<div class="line">    std::vector&lt;index_t&gt;  fUniqueSampleIndexes;</div>
<div class="line">    std::vector&lt;chrono_t&gt; fTimeBoundaries;</div>
<div class="line">        </div>
<div class="line">    TimeInterval          fValidityInterval;</div>
<div class="line">    Value                 fValue;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ScalarPropertyCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PROPERTY&gt;</div>
<div class="line"><span class="keyword">class </span>ScalarPropertyCache </div>
<div class="line">    : <span class="keyword">public</span> PropertyCache&lt;</div>
<div class="line">        PROPERTY,</div>
<div class="line">        typename PROPERTY::value_type,</div>
<div class="line">        typename PROPERTY::value_type,</div>
<div class="line">        ScalarPropertyCache&lt;PROPERTY&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> PropertyCache&lt;</div>
<div class="line">        PROPERTY,</div>
<div class="line">        <span class="keyword">typename</span> PROPERTY::value_type,</div>
<div class="line">        <span class="keyword">typename</span> PROPERTY::value_type,</div>
<div class="line">        ScalarPropertyCache&lt;PROPERTY&gt;</div>
<div class="line">    &gt; BaseClass;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::Key Key;</div>
<div class="line">        </div>
<div class="line">    <span class="keywordtype">void</span> readValue(index_t idx)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// For scalar properties, the value is the key...</span></div>
<div class="line">        getKey(this-&gt;fValue, idx);</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    <span class="keywordtype">void</span> getKey(Key&amp; key, index_t idx)</div>
<div class="line">    {</div>
<div class="line">        this-&gt;fProperty.get(key, idx);</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS XformPropertyCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>XformPropertyCache </div>
<div class="line">    : <span class="keyword">public</span> PropertyCache&lt;</div>
<div class="line">        IXformSchema,</div>
<div class="line">        MMatrix,</div>
<div class="line">        MMatrix,</div>
<div class="line">        XformPropertyCache</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> readValue(index_t idx)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// For xform properties, the value is the key...</span></div>
<div class="line">        getKey(fValue, idx);</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    <span class="keywordtype">void</span> getKey(Key&amp; key, index_t idx)</div>
<div class="line">    {</div>
<div class="line">        XformSample sample;</div>
<div class="line">        fProperty.get(sample, idx);</div>
<div class="line">        key = toMatrix(sample);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Helper function to extract the transformation matrix out of</span></div>
<div class="line">    <span class="comment">// an XformSample.</span></div>
<div class="line">    <span class="keyword">static</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> toMatrix(<span class="keyword">const</span> XformSample&amp; sample)</div>
<div class="line">    {</div>
<div class="line">        Alembic::Abc::M44d matrix = sample.getMatrix();</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>(matrix.x);</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">};</div>
<div class="line">    </div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ArrayPropertyCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PROPERTY&gt;</div>
<div class="line"><span class="keyword">class </span>ArrayPropertyCache </div>
<div class="line">    : <span class="keyword">public</span> PropertyCache&lt;</div>
<div class="line">        PROPERTY,</div>
<div class="line">        Alembic::AbcCoreAbstract::ArraySampleKey,</div>
<div class="line">        std::shared_ptr&lt;</div>
<div class="line">            ReadableArray&lt;</div>
<div class="line">                typename BaseTypeOfElem&lt;</div>
<div class="line">                    typename PROPERTY::traits_type::value_type</div>
<div class="line">                    &gt;::value_type&gt; &gt;,</div>
<div class="line">        ArrayPropertyCache&lt;PROPERTY&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{   </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> PropertyCache&lt;</div>
<div class="line">        PROPERTY,</div>
<div class="line">        Alembic::AbcCoreAbstract::ArraySampleKey,</div>
<div class="line">        std::shared_ptr&lt;</div>
<div class="line">            ReadableArray&lt;</div>
<div class="line">                <span class="keyword">typename</span> BaseTypeOfElem&lt;</div>
<div class="line">                    <span class="keyword">typename</span> PROPERTY::traits_type::value_type</div>
<div class="line">                    &gt;::value_type&gt; &gt;,</div>
<div class="line">        ArrayPropertyCache&lt;PROPERTY&gt;</div>
<div class="line">    &gt; BaseClass;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::Property Property;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::Key Key;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::Value Value;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Property::sample_ptr_type ArraySamplePtr;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Property::traits_type traits_type;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseTypeOfElem&lt;typename traits_type::value_type&gt;::value_type BaseType;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kDimensions =</div>
<div class="line">        BaseTypeOfElem&lt;typename traits_type::value_type&gt;::kDimensions;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> readValue(index_t idx)</div>
<div class="line">    {</div>
<div class="line">        Key key;</div>
<div class="line">        getKey(key, idx);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Can&#39;t figure out how this can differs... It seems like a</span></div>
<div class="line">        <span class="comment">// provision for a future feature. Unfortunately, I can&#39;t</span></div>
<div class="line">        <span class="comment">// figure out if the key digest would be relative the read</span></div>
<div class="line">        <span class="comment">// or the orig POD!</span></div>
<div class="line">        assert(key.origPOD == key.readPOD);</div>
<div class="line">        assert(key.origPOD == traits_type::dataType().getPod());</div>
<div class="line">        assert(<span class="keyword">sizeof</span>(BaseType) == PODNumBytes(traits_type::dataType().getPod()));</div>
<div class="line">        assert(kDimensions == traits_type::dataType().getExtent());</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = size_t(key.numBytes / <span class="keyword">sizeof</span>(BaseType));</div>
<div class="line">            </div>
<div class="line">        <span class="comment">// First, let&#39;s try to an array out of the global</span></div>
<div class="line">        <span class="comment">// registry.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Important, we first have to get rid of the previously</span></div>
<div class="line">        <span class="comment">// referenced value outside of the lock or else we are</span></div>
<div class="line">        <span class="comment">// risking a dead-lock on Linux and Mac (std::mutex is</span></div>
<div class="line">        <span class="comment">// non-recursive on these platforms).</span></div>
<div class="line">        this-&gt;fValue = Value();</div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(ArrayRegistry&lt;BaseType&gt;::mutex());</div>
<div class="line">            this-&gt;fValue = ArrayRegistry&lt;BaseType&gt;::lookupReadable(key.digest, size);</div>
<div class="line">        </div>
<div class="line">            <span class="keywordflow">if</span> (this-&gt;fValue) <span class="keywordflow">return</span>;</div>
<div class="line">        }            </div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample not found. Read it.</span></div>
<div class="line">        ArraySamplePtr sample;</div>
<div class="line">        this-&gt;fProperty.get(sample, idx);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">        Key key2 = sample-&gt;getKey();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> size2 = (sample-&gt;size() *</div>
<div class="line">                             Property::traits_type::dataType().getExtent());</div>
<div class="line">        assert(key == key2);</div>
<div class="line">        assert(size == size2);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Insert the read sample into the cache.</span></div>
<div class="line">        this-&gt;fValue = AlembicArray&lt;Property&gt;::create(sample, key.digest);</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    <span class="keywordtype">void</span> getKey(Key&amp; key, index_t idx)</div>
<div class="line">    {</div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">        <span class="keywordtype">bool</span> result =</div>
<div class="line"><span class="preprocessor">#endif                </span></div>
<div class="line">            this-&gt;fProperty.getKey(key, idx);</div>
<div class="line">        <span class="comment">// There should always be a key...</span></div>
<div class="line">        assert(result);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PROPERTY&gt;</div>
<div class="line"><span class="keyword">class </span>ArrayPropertyCacheWithConverter</div>
<div class="line">    : <span class="keyword">public</span> PropertyCache&lt;</div>
<div class="line">        PROPERTY,</div>
<div class="line">        Alembic::AbcCoreAbstract::ArraySampleKey,</div>
<div class="line">        std::shared_ptr&lt;</div>
<div class="line">            ReadableArray&lt;</div>
<div class="line">                typename BaseTypeOfElem&lt;</div>
<div class="line">                    typename PROPERTY::traits_type::value_type</div>
<div class="line">                    &gt;::value_type&gt; &gt;,</div>
<div class="line">        ArrayPropertyCacheWithConverter&lt;PROPERTY&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> PropertyCache&lt;</div>
<div class="line">        PROPERTY,</div>
<div class="line">        Alembic::AbcCoreAbstract::ArraySampleKey,</div>
<div class="line">        std::shared_ptr&lt;</div>
<div class="line">            ReadableArray&lt;</div>
<div class="line">                <span class="keyword">typename</span> BaseTypeOfElem&lt;</div>
<div class="line">                    <span class="keyword">typename</span> PROPERTY::traits_type::value_type</div>
<div class="line">                    &gt;::value_type&gt; &gt;,</div>
<div class="line">        ArrayPropertyCacheWithConverter&lt;PROPERTY&gt;</div>
<div class="line">    &gt; BaseClass;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::Property Property;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::Key Key;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::Value Value;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Property::sample_ptr_type ArraySamplePtr;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Property::traits_type traits_type;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseTypeOfElem&lt;typename traits_type::value_type&gt;::value_type BaseType;</div>
<div class="line">    <span class="keyword">typedef</span> Alembic::Util::Digest Digest;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;ReadableArray&lt;BaseType&gt; &gt;</div>
<div class="line">    (*Converter)(<span class="keyword">const</span> <span class="keyword">typename</span> PROPERTY::sample_ptr_type&amp; sample);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kDimensions =</div>
<div class="line">        BaseTypeOfElem&lt;typename traits_type::value_type&gt;::kDimensions;</div>
<div class="line"></div>
<div class="line">    ArrayPropertyCacheWithConverter(Converter converter) </div>
<div class="line">        : fConverter(converter)</div>
<div class="line">    {}</div>
<div class="line">        </div>
<div class="line">    <span class="keywordtype">void</span> readValue(index_t idx)</div>
<div class="line">    {</div>
<div class="line">        Key key;</div>
<div class="line">        getKey(key, idx);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Can&#39;t figure out how this can differs... It seems like a</span></div>
<div class="line">        <span class="comment">// provision for a future feature. Unfortunately, I can&#39;t</span></div>
<div class="line">        <span class="comment">// figure out if the key digest would be relative the read</span></div>
<div class="line">        <span class="comment">// or the orig POD!</span></div>
<div class="line">        assert(key.origPOD == key.readPOD);</div>
<div class="line">        assert(key.origPOD == traits_type::dataType().getPod());</div>
<div class="line">        assert(<span class="keyword">sizeof</span>(BaseType) == PODNumBytes(traits_type::dataType().getPod()));</div>
<div class="line">        assert(kDimensions == traits_type::dataType().getExtent());</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = size_t(key.numBytes / <span class="keyword">sizeof</span>(BaseType));</div>
<div class="line">            </div>
<div class="line">        <span class="comment">// First, let&#39;s try to an array out of the global</span></div>
<div class="line">        <span class="comment">// registry.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Important, we first have to get rid of the previously</span></div>
<div class="line">        <span class="comment">// referenced value outside of the lock or else we are</span></div>
<div class="line">        <span class="comment">// risking a dead-lock on Linux and Mac (std::mutex is</span></div>
<div class="line">        <span class="comment">// non-recursive on these platforms).</span></div>
<div class="line">        this-&gt;fValue = Value();</div>
<div class="line">        <span class="keyword">typename</span> ConvertionMap::const_iterator it = fsConvertionMap.find(key.digest);</div>
<div class="line">        <span class="keywordflow">if</span> (it != fsConvertionMap.end()) {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(ArrayRegistry&lt;BaseType&gt;::mutex());</div>
<div class="line">            this-&gt;fValue = ArrayRegistry&lt;BaseType&gt;::lookupReadable(it-&gt;second, size);</div>
<div class="line">        </div>
<div class="line">            <span class="keywordflow">if</span> (this-&gt;fValue) <span class="keywordflow">return</span>;</div>
<div class="line">        }            </div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample not found. Read it.</span></div>
<div class="line">        ArraySamplePtr sample;</div>
<div class="line">        this-&gt;fProperty.get(sample, idx);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG        </span></div>
<div class="line">        Key key2 = sample-&gt;getKey();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> size2 = (sample-&gt;size() *</div>
<div class="line">                             Property::traits_type::dataType().getExtent());</div>
<div class="line">        assert(key == key2);</div>
<div class="line">        assert(size == size2);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Insert the read sample into the cache.</span></div>
<div class="line">        this-&gt;fValue = fConverter(sample);</div>
<div class="line"></div>
<div class="line">        fsConvertionMap[key.digest] = this-&gt;fValue-&gt;digest();</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    <span class="keywordtype">void</span> getKey(Key&amp; key, index_t idx)</div>
<div class="line">    {</div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">        <span class="keywordtype">bool</span> result =</div>
<div class="line"><span class="preprocessor">#endif                </span></div>
<div class="line">            this-&gt;fProperty.getKey(key, idx);</div>
<div class="line">        <span class="comment">// There should always be a key...</span></div>
<div class="line">        assert(result);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span>DigestHash</div>
<div class="line">    {</div>
<div class="line">        std::size_t operator()(Digest <span class="keyword">const</span>&amp; v)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            std::size_t seed = 0;</div>
<div class="line">            GPUCache::hash_combine(seed, v.words[0]);</div>
<div class="line">            GPUCache::hash_combine(seed, v.words[1]);</div>
<div class="line">            <span class="keywordflow">return</span> seed;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> std::unordered_map&lt;Digest, Digest, DigestHash&gt; ConvertionMap;</div>
<div class="line">    <span class="keyword">static</span> ConvertionMap fsConvertionMap;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Converter fConverter;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS DataProvider</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// An abstract class to wrap the details of different data sources.</span></div>
<div class="line"><span class="comment">// Currently, we have four kinds of Alembic geometries:</span></div>
<div class="line"><span class="comment">//     1) IPolyMesh from gpuCache command</span></div>
<div class="line"><span class="comment">//     2) IPolyMesh from arbitrary Alembic exporter such as AbcExport</span></div>
<div class="line"><span class="comment">//     3) INuPatch  from arbitrary Alembic exporter such as AbcExport</span></div>
<div class="line"><span class="comment">//     4) ISubD     from arbitrary Alembic exporter such as AbcExport</span></div>
<div class="line"><span class="comment">// Of course, 1) is much faster than 2).</span></div>
<div class="line"><span class="comment">// Caller is responsible for locking.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>DataProvider</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~DataProvider();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if all the properties are valid</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> valid() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The following two methods are used when reading hierarchy.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Fill minimal property caches that will display a bounding box place holder</span></div>
<div class="line">    <span class="keywordtype">void</span> fillBBoxAndVisSample(chrono_t time);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the validity interval of a bounding box place holder sample</span></div>
<div class="line">    TimeInterval getBBoxAndVisValidityInterval()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fBBoxAndVisValidityInterval; }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The following two methods are used when reading shapes.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Fill property caches with the data at the specified index</span></div>
<div class="line">    <span class="keywordtype">void</span> fillTopoAndAttrSample(chrono_t time);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the combined validity interval of the the property</span></div>
<div class="line">    <span class="comment">// caches for the last updated index.</span></div>
<div class="line">    TimeInterval getValidityInterval()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fValidityInterval; }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check for the visibility</span></div>
<div class="line">    <span class="keywordtype">bool</span> isVisible() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Retrieve the current bounding box proxy sample from property cache</span></div>
<div class="line">    std::shared_ptr&lt;const ShapeSample&gt;</div>
<div class="line">    getBBoxPlaceHolderSample(<span class="keywordtype">double</span> seconds);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Retrieve the current sample from property cache</span></div>
<div class="line">    <span class="keyword">virtual</span> std::shared_ptr&lt;const ShapeSample&gt;</div>
<div class="line">    getSample(<span class="keywordtype">double</span> seconds) = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the bounding box and validity interval for the current</span></div>
<div class="line">    <span class="comment">// sample, i.e. the time of the last call to sample.</span></div>
<div class="line">    <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> getBoundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keyword">const</span> Imath::Box&lt;Imath::V3d&gt; boundingBox =</div>
<div class="line">            fBoundingBoxCache.getValue();</div>
<div class="line">        <span class="keywordflow">if</span> (boundingBox.isEmpty()) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>(         </div>
<div class="line">            <a name="_a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(boundingBox.min.x, boundingBox.min.y, boundingBox.min.z),</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(boundingBox.max.x, boundingBox.max.y, boundingBox.max.z));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TimeInterval getBoundingBoxValidityInterval()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> fBoundingBoxCache.getValidityInterval(); }</div>
<div class="line"></div>
<div class="line">    TimeInterval getAnimTimeRange()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> fAnimTimeRange; }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    DataProvider(<span class="keyword">const</span> DataProvider&amp;);</div>
<div class="line">    <span class="keyword">const</span> DataProvider&amp; operator= (<span class="keyword">const</span> DataProvider&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> INFO&gt;</div>
<div class="line">    DataProvider(Alembic::AbcGeom::IGeomBaseSchema&lt;INFO&gt;&amp; abcGeom,</div>
<div class="line">                 Alembic::Abc::TimeSamplingPtr            timeSampling,</div>
<div class="line">                 <span class="keywordtype">size_t</span> numSamples,</div>
<div class="line">                 <span class="keywordtype">bool</span>   needUVs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update Bounding Box and Visibility property caches</span></div>
<div class="line">    TimeInterval updateBBoxAndVisCache(chrono_t time);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the property caches</span></div>
<div class="line">    <span class="keyword">virtual</span> TimeInterval updateCache(chrono_t time);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Whether UV coordinates should be read or generated.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> fNeedUVs;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Exact animation time range</span></div>
<div class="line">    TimeInterval fAnimTimeRange;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The valid range of bbox and visibility in property caches</span></div>
<div class="line">    TimeInterval fBBoxAndVisValidityInterval;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The valid range of the current data in property caches</span></div>
<div class="line">    TimeInterval fValidityInterval;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Shape Visibility</span></div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt;  fVisibilityCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Bounding Box</span></div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::IBox3dProperty&gt; fBoundingBoxCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Parent Visibility</span></div>
<div class="line">    std::vector&lt;ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt; &gt; fParentVisibilityCache;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS PolyDataProvider</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Base class for all polygon data sources.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>PolyDataProvider : <span class="keyword">public</span> DataProvider</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ~PolyDataProvider() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if all the properties are valid</span></div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    PolyDataProvider(<span class="keyword">const</span> PolyDataProvider&amp;);</div>
<div class="line">    <span class="keyword">const</span> PolyDataProvider&amp; operator= (<span class="keyword">const</span> PolyDataProvider&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCHEMA&gt;</div>
<div class="line">    PolyDataProvider(SCHEMA&amp;                         abcMesh,</div>
<div class="line">                     <span class="keywordtype">bool</span>                            needUVs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the property caches</span></div>
<div class="line">    TimeInterval updateCache(chrono_t time) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Polygons</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fFaceCountsCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IP3fArrayProperty&gt;   fPositionsCache;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS RawDataProvider</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class reads mesh data that is written by gpuCache command.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>RawDataProvider : <span class="keyword">public</span> PolyDataProvider</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    RawDataProvider(Alembic::AbcGeom::IPolyMeshSchema&amp; abcMesh,</div>
<div class="line">                    <span class="keywordtype">bool</span> needUVs);</div>
<div class="line">    ~RawDataProvider() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if all the properties are valid</span></div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Retrieve the current sample from property cache</span></div>
<div class="line">    std::shared_ptr&lt;const ShapeSample&gt;</div>
<div class="line">    getSample(<span class="keywordtype">double</span> seconds) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    RawDataProvider(<span class="keyword">const</span> RawDataProvider&amp;);</div>
<div class="line">    <span class="keyword">const</span> RawDataProvider&amp; operator= (<span class="keyword">const</span> RawDataProvider&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Convert triangles winding from CW to CCW</span></div>
<div class="line">    <span class="keyword">static</span> std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt;</div>
<div class="line">    correctPolygonWinding(<span class="keyword">const</span> Alembic::Abc::Int32ArraySamplePtr&amp; indices);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the property caches</span></div>
<div class="line">    TimeInterval updateCache(chrono_t time) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    ArrayPropertyCacheWithConverter&lt;Alembic::Abc::IInt32ArrayProperty&gt; fFaceIndicesCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fWireIndicesCache;  <span class="comment">// required</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fGroupSizesCache;   <span class="comment">// optional</span></div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::IC4fProperty&gt;       fDiffuseColorCache; <span class="comment">// required</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IN3fArrayProperty&gt;   fNormalsCache;      <span class="comment">// currently, required</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IV2fArrayProperty&gt;   fUVsCache;          </div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS Triangulator</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class reads mesh data that is written by an arbitrary Alembic exporter.</span></div>
<div class="line"><span class="comment">// Triangulate a polygon mesh and convert multi-indexed streams to single-indexed streams.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>Triangulator : <span class="keyword">public</span> PolyDataProvider</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Triangulator(Alembic::AbcGeom::IPolyMeshSchema&amp; abcMesh,</div>
<div class="line">                 <span class="keywordtype">bool</span> needUVs);</div>
<div class="line">    ~Triangulator() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if all the properties are valid</span></div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Retrieve the current sample from property cache</span></div>
<div class="line">    std::shared_ptr&lt;const ShapeSample&gt;</div>
<div class="line">    getSample(<span class="keywordtype">double</span> seconds) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    Triangulator(<span class="keyword">const</span> Triangulator&amp;);</div>
<div class="line">    <span class="keyword">const</span> Triangulator&amp; operator= (<span class="keyword">const</span> Triangulator&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the property caches</span></div>
<div class="line">    TimeInterval updateCache(chrono_t time) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Polygon Indices</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fFaceIndicesCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Normals</span></div>
<div class="line">    Alembic::AbcGeom::GeometryScope                        fNormalsScope;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IN3fArrayProperty&gt;    fNormalsCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IUInt32ArrayProperty&gt; fNormalIndicesCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// UVs</span></div>
<div class="line">    Alembic::AbcGeom::GeometryScope                        fUVsScope;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IV2fArrayProperty&gt;    fUVsCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IUInt32ArrayProperty&gt; fUVIndicesCache;</div>
<div class="line">        </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> SIZE&gt;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt; convertMultiIndexedStream(</div>
<div class="line">        std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt; attribArray,</div>
<div class="line">        std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; indexArray);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> check();</div>
<div class="line">    <span class="keywordtype">void</span> computeNormals();</div>
<div class="line">    <span class="keywordtype">void</span> convertMultiIndexedStreams();</div>
<div class="line">    <span class="keywordtype">void</span> remapVertAttribs();</div>
<div class="line">    <span class="keywordtype">void</span> computeWireIndices();</div>
<div class="line">    <span class="keywordtype">void</span> triangulate();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in check();</span></div>
<div class="line">    Alembic::AbcGeom::GeometryScope                 fCheckedNormalsScope;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fCheckedNormals;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fCheckedNormalIndices;</div>
<div class="line">    Alembic::AbcGeom::GeometryScope                 fCheckedUVsScope;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fCheckedUVs;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fCheckedUVIndices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in computeNormals()</span></div>
<div class="line">    Alembic::AbcGeom::GeometryScope                 fComputedNormalsScope;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fComputedNormals;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fComputedNormalIndices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in convertMultiIndexedStreams()</span></div>
<div class="line">    <span class="keywordtype">size_t</span>                                          fNumVertices;</div>
<div class="line">    GPUCache::shared_array&lt;unsigned int&gt;               fVertAttribsIndices;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fMappedFaceIndices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in remapVertAttribs()</span></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fMappedPositions;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fMappedNormals;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fMappedUVs;</div>
<div class="line">        </div>
<div class="line">    <span class="comment">// compute in computeWireIndices()</span></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fWireIndices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in triangulate()</span></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fTriangleIndices;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS NurbsTessellator</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class reads NURBS data that is written by an arbitrary Alembic exporter.</span></div>
<div class="line"><span class="comment">// NURBS with trimmed curves are tessellated by MFnNurbsSurface</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>NurbsTessellator : <span class="keyword">public</span> DataProvider</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    NurbsTessellator(Alembic::AbcGeom::INuPatchSchema&amp; abcNurbs,</div>
<div class="line">                     <span class="keywordtype">bool</span> needUVs);</div>
<div class="line">        </div>
<div class="line">    ~NurbsTessellator() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if all the properties are valid</span></div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Retrieve the current sample from property cache</span></div>
<div class="line">    std::shared_ptr&lt;const ShapeSample&gt;</div>
<div class="line">    getSample(<span class="keywordtype">double</span> seconds) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    NurbsTessellator(<span class="keyword">const</span> NurbsTessellator&amp;);</div>
<div class="line">    <span class="keyword">const</span> NurbsTessellator&amp; operator= (<span class="keyword">const</span> NurbsTessellator&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the property caches</span></div>
<div class="line">    TimeInterval updateCache(chrono_t time) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// NURBS required properties</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IP3fArrayProperty&gt;       fPositionsCache;</div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::IInt32Property&gt;         fNumUCache;</div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::IInt32Property&gt;         fNumVCache;</div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::IInt32Property&gt;         fUOrderCache;</div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::IInt32Property&gt;         fVOrderCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::AbcGeom::IFloatArrayProperty&gt; fUKnotCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::AbcGeom::IFloatArrayProperty&gt; fVKnotCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// NURBS optional properties</span></div>
<div class="line">    <span class="comment">//   Currently, normals and UVs are ignored..</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::AbcGeom::IFloatArrayProperty&gt; fPositionWeightsCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Optional trim curves</span></div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::IInt32Property&gt;         fTrimNumLoopsCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt;     fTrimNumCurvesCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt;     fTrimNumVerticesCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt;     fTrimOrderCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::AbcGeom::IFloatArrayProperty&gt; fTrimKnotCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::AbcGeom::IFloatArrayProperty&gt; fTrimUCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::AbcGeom::IFloatArrayProperty&gt; fTrimVCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::AbcGeom::IFloatArrayProperty&gt; fTrimWCache;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> check();</div>
<div class="line">    <span class="keywordtype">void</span> setNurbs(<span class="keywordtype">bool</span> rebuild, <span class="keywordtype">bool</span> positionsChanged);</div>
<div class="line">    <span class="keywordtype">void</span> tessellate();</div>
<div class="line">    <span class="keywordtype">void</span> convertToPoly();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in check()</span></div>
<div class="line">    <span class="keywordtype">bool</span> fSurfaceValid;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in setNubs()</span></div>
<div class="line">    <a name="_a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface_data.html">MFnNurbsSurfaceData</a> fNurbsData;</div>
<div class="line">    <a name="_a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_nurbs_surface.html">MFnNurbsSurface</a>     fNurbs;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in tessellate()</span></div>
<div class="line">    <a name="_a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh_data.html">MFnMeshData</a> fPolyMeshData;</div>
<div class="line">    <a name="_a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html">MFnMesh</a>     fPolyMesh;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in convertToPoly()</span></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fTriangleIndices;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fWireIndices;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fPositions;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fNormals;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fUVs;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubDSmoother</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class reads SubD data that is written by an arbitrary Alembic exporter.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>SubDSmoother : <span class="keyword">public</span> PolyDataProvider</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SubDSmoother(Alembic::AbcGeom::ISubDSchema&amp;     abcSubd,</div>
<div class="line">                 <span class="keyword">const</span> <span class="keywordtype">bool</span>                         needUVs);</div>
<div class="line">    ~SubDSmoother() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if all the properties are valid</span></div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Retrieve the current sample from property cache</span></div>
<div class="line">    std::shared_ptr&lt;const ShapeSample&gt;</div>
<div class="line">    getSample(<span class="keywordtype">double</span> seconds) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    SubDSmoother(<span class="keyword">const</span> SubDSmoother&amp;);</div>
<div class="line">    <span class="keyword">const</span> SubDSmoother&amp; operator= (<span class="keyword">const</span> SubDSmoother&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the property caches</span></div>
<div class="line">    TimeInterval updateCache(chrono_t time) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Polygon Indices</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fFaceIndicesCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Crease Edges</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fCreaseIndicesCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fCreaseLengthsCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IFloatArrayProperty&gt; fCreaseSharpnessesCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Crease Vertices</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fCornerIndicesCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IFloatArrayProperty&gt; fCornerSharpnessesCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Invisible Faces</span></div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IInt32ArrayProperty&gt; fHolesCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// UVs</span></div>
<div class="line">    Alembic::AbcGeom::GeometryScope                        fUVsScope{Alembic::AbcGeom::kUnknownScope};</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IV2fArrayProperty&gt;    fUVsCache;</div>
<div class="line">    ArrayPropertyCache&lt;Alembic::Abc::IUInt32ArrayProperty&gt; fUVIndicesCache;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> check();</div>
<div class="line">    <span class="keywordtype">void</span> rebuildSubD();</div>
<div class="line">    <span class="keywordtype">void</span> setPositions();</div>
<div class="line">    <span class="keywordtype">void</span> setCreaseEdges();</div>
<div class="line">    <span class="keywordtype">void</span> setCreaseVertices();</div>
<div class="line">    <span class="keywordtype">void</span> setInvisibleFaces();</div>
<div class="line">    <span class="keywordtype">void</span> setUVs();</div>
<div class="line">    <span class="keywordtype">void</span> convertToPoly();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in check()</span></div>
<div class="line">    Alembic::AbcGeom::GeometryScope                 fCheckedUVsScope;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fCheckedUVs;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fCheckedUVIndices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in rebuildSubD()</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh_data.html">MFnMeshData</a> fSubDData;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html">MFnMesh</a>     fSubD;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute in convertToPoly()</span></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fTriangleIndices;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; fWireIndices;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fPositions;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fNormals;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;                fUVs;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">    </div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheObjectReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Abstract reader interface for reading an Alembic object along with</span></div>
<div class="line"><span class="comment">// all of its children.</span></div>
<div class="line"><span class="keyword">class </span>AlembicCacheObjectReader</div>
<div class="line">    : <span class="keyword">public</span> std::enable_shared_from_this&lt;AlembicCacheObjectReader&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span>  std::shared_ptr&lt;AlembicCacheObjectReader&gt; Ptr;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/*----- static member functions -----*/</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> Ptr create(Alembic::Abc::IObject&amp; abcObj, <span class="keywordtype">bool</span> needUVs);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">/*----- member functions -----*/</span></div>
<div class="line"></div>
<div class="line">    AlembicCacheObjectReader() {}</div>
<div class="line">    <span class="keyword">virtual</span> ~AlembicCacheObjectReader() = 0;</div>
<div class="line">    AlembicCacheObjectReader(<span class="keyword">const</span> AlembicCacheObjectReader&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    AlembicCacheObjectReader&amp; operator=(<span class="keyword">const</span> AlembicCacheObjectReader&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> valid() <span class="keyword">const</span> = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read and append a sample of the given mesh at the given time</span></div>
<div class="line">    <span class="comment">// and sample index value.</span></div>
<div class="line">    <span class="comment">// This method only reads hierarchy information:</span></div>
<div class="line">    <span class="comment">// xform, bounding box, visibility, ...</span></div>
<div class="line">    <span class="keyword">virtual</span> TimeInterval sampleHierarchy(<span class="keywordtype">double</span> seconds,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; rootMatrix, TimeInterval rootMatrixInterval) = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read and append a sample of the given mesh at the given time</span></div>
<div class="line">    <span class="comment">// and sample index value.</span></div>
<div class="line">    <span class="comment">// This method reads the mesh buffers.</span></div>
<div class="line">    <span class="keyword">virtual</span> TimeInterval sampleShape(<span class="keywordtype">double</span> seconds) = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the read hierarchy.</span></div>
<div class="line">    <span class="keyword">virtual</span> SubNode::MPtr <span class="keyword">get</span>() <span class="keyword">const</span> = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the bounding box and validity interval for the current</span></div>
<div class="line">    <span class="comment">// sample, i.e. the time of the last call to sample.</span></div>
<div class="line">    <span class="comment">// The bounding box is in the axis of root sub-node.</span></div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> getBoundingBox() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> TimeInterval getBoundingBoxValidityInterval() <span class="keyword">const</span> = 0;  </div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the exact animation time range.</span></div>
<div class="line">    <span class="keyword">virtual</span> TimeInterval getAnimTimeRange() <span class="keyword">const</span> = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Save this object reader and reset its content for reuse.</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> saveAndReset(AlembicCacheReader&amp; cacheReader) = 0;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheTopReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>AlembicCacheTopReader : <span class="keyword">public</span> AlembicCacheObjectReader</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AlembicCacheTopReader(Alembic::Abc::IObject <span class="keywordtype">object</span>, <span class="keywordtype">bool</span> needUVs);</div>
<div class="line">    ~AlembicCacheTopReader() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line">    TimeInterval sampleHierarchy(<span class="keywordtype">double</span> seconds, </div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; rootMatrix, TimeInterval rootMatrixInterval) <span class="keyword">override</span>;</div>
<div class="line">    TimeInterval sampleShape(<span class="keywordtype">double</span> seconds) <span class="keyword">override</span>;</div>
<div class="line">    SubNode::MPtr <span class="keyword">get</span>() <span class="keyword">const</span> <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> getBoundingBox() <span class="keyword">const override</span>;</div>
<div class="line">    TimeInterval getBoundingBoxValidityInterval() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    TimeInterval getAnimTimeRange() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> saveAndReset(AlembicCacheReader&amp; cacheReader) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Bounding box and its interval</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> fBoundingBox;</div>
<div class="line">    TimeInterval fBoundingBoxValidityInterval;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The sub node data currently being filled-in.</span></div>
<div class="line">    XformData::MPtr fXformData;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Readers of children nodes.</span></div>
<div class="line">    std::vector&lt;AlembicCacheObjectReader::Ptr&gt; fChildren;</div>
<div class="line"></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheXformReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>AlembicCacheXformReader : <span class="keyword">public</span> AlembicCacheObjectReader</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AlembicCacheXformReader(Alembic::Abc::IObject <span class="keywordtype">object</span>, <span class="keywordtype">bool</span> needUVs);</div>
<div class="line">    ~AlembicCacheXformReader() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line">    TimeInterval sampleHierarchy(<span class="keywordtype">double</span> seconds, </div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; rootMatrix, TimeInterval rootMatrixInterval) <span class="keyword">override</span>;</div>
<div class="line">    TimeInterval sampleShape(<span class="keywordtype">double</span> seconds) <span class="keyword">override</span>;</div>
<div class="line">    SubNode::MPtr <span class="keyword">get</span>() <span class="keyword">const</span> <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> getBoundingBox() <span class="keyword">const override</span>;</div>
<div class="line">    TimeInterval getBoundingBoxValidityInterval() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    TimeInterval getAnimTimeRange() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> saveAndReset(AlembicCacheReader&amp; cacheReader) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> fillTopoAndAttrSample(chrono_t time);</div>
<div class="line">    <span class="keywordtype">bool</span> isVisible() <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line"></div>
<div class="line">    <span class="comment">// Alembic readers</span></div>
<div class="line">    <span class="keyword">const</span> std::string                 fName;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The valid range of the current data in property caches</span></div>
<div class="line">    TimeInterval fValidityInterval;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Transform</span></div>
<div class="line">    XformPropertyCache fXformCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Transform Visibility</span></div>
<div class="line">    ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt;  fVisibilityCache;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Bounding box and its interval</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> fBoundingBox;</div>
<div class="line">    TimeInterval fBoundingBoxValidityInterval;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The sub node data currently being filled-in.</span></div>
<div class="line">    XformData::MPtr fXformData;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Readers of children nodes.</span></div>
<div class="line">    std::vector&lt;AlembicCacheObjectReader::Ptr&gt; fChildren;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheMeshReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>AlembicCacheMeshReader : <span class="keyword">public</span> AlembicCacheObjectReader</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AlembicCacheMeshReader(Alembic::Abc::IObject <span class="keywordtype">object</span>, <span class="keywordtype">bool</span> needUVs);</div>
<div class="line">    ~AlembicCacheMeshReader() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line">    TimeInterval sampleHierarchy(<span class="keywordtype">double</span> seconds, </div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; rootMatrix, TimeInterval rootMatrixInterval) <span class="keyword">override</span>;</div>
<div class="line">    TimeInterval sampleShape(<span class="keywordtype">double</span> seconds) <span class="keyword">override</span>;</div>
<div class="line">    SubNode::MPtr <span class="keyword">get</span>() <span class="keyword">const</span> <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> getBoundingBox() <span class="keyword">const override</span>;</div>
<div class="line">    TimeInterval getBoundingBoxValidityInterval() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    TimeInterval getAnimTimeRange() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> saveAndReset(AlembicCacheReader&amp; cacheReader) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Alembic readers</span></div>
<div class="line">    <span class="keyword">const</span> std::string                 fName;</div>
<div class="line">    <span class="keyword">const</span> std::string                 fFullName;</div>
<div class="line">    std::unique_ptr&lt;DataProvider&gt;     fDataProvider;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Bounding box and its interval</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> fBoundingBox;</div>
<div class="line">    TimeInterval fBoundingBoxValidityInterval;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The sub node data currently being filled-in.</span></div>
<div class="line">    ShapeData::MPtr fShapeData;</div>
<div class="line">    <span class="keywordtype">size_t</span>          fNumTransparentSample;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheMaterialReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>AlembicCacheMaterialReader</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AlembicCacheMaterialReader(Alembic::Abc::IObject abcObj);</div>
<div class="line">    ~AlembicCacheMaterialReader();</div>
<div class="line">    AlembicCacheMaterialReader(<span class="keyword">const</span> AlembicCacheMaterialReader&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    AlembicCacheMaterialReader&amp; operator=(<span class="keyword">const</span> AlembicCacheMaterialReader&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line">    TimeInterval sampleMaterial(<span class="keywordtype">double</span> seconds);</div>
<div class="line">    MaterialGraph::MPtr <span class="keyword">get</span>() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Alembic readers</span></div>
<div class="line">    <span class="keyword">const</span> std::string fName;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Templated classes to translate Alembic properties.</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ABC_PROP&gt; </div>
<div class="line">    <span class="keyword">class </span>ScalarMaterialProp</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        ScalarMaterialProp(Alembic::Abc::ICompoundProperty&amp; parent,</div>
<div class="line">                           <span class="keyword">const</span> std::string&amp; name,</div>
<div class="line">                           MaterialNode::MPtr&amp; node)</div>
<div class="line">            : fName(name)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Create Alembic input property</span></div>
<div class="line">            ABC_PROP abcProp(parent, name);</div>
<div class="line">            assert(abcProp.valid());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Create reader cache</span></div>
<div class="line">            fCache.reset(<span class="keyword">new</span> ScalarPropertyCache&lt;ABC_PROP&gt;());</div>
<div class="line">            fCache-&gt;init(abcProp);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Find existing property.</span></div>
<div class="line">            fProp = node-&gt;findProperty(name.c_str());</div>
<div class="line">            assert(!fProp || fProp-&gt;type() == propertyType&lt;ABC_PROP&gt;());</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (fProp &amp;&amp; fProp-&gt;type() != propertyType&lt;ABC_PROP&gt;()) {</div>
<div class="line">                <span class="comment">// Something goes wrong..</span></div>
<div class="line">                fCache.reset();</div>
<div class="line">                fProp.reset();</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// This is not a known property.</span></div>
<div class="line">            <span class="keywordflow">if</span> (!fProp) {</div>
<div class="line">                fProp = node-&gt;createProperty(name.c_str(), propertyType&lt;ABC_PROP&gt;());</div>
<div class="line">                assert(fProp-&gt;type() == propertyType&lt;ABC_PROP&gt;());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        TimeInterval sample(<span class="keywordtype">double</span> seconds)</div>
<div class="line">        {</div>
<div class="line">            TimeInterval validityInterval(TimeInterval::kInfinite);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (fCache &amp;&amp; fCache-&gt;valid()) {</div>
<div class="line">                fCache-&gt;setTime(seconds);</div>
<div class="line">                validityInterval &amp;= fCache-&gt;getValidityInterval();</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (seconds == validityInterval.startTime()) {</div>
<div class="line">                    setMaterialProperty&lt;ABC_PROP&gt;(fCache, fProp, seconds);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> validityInterval;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        std::string                                       fName;</div>
<div class="line">        std::shared_ptr&lt;ScalarPropertyCache&lt;ABC_PROP&gt; &gt; fCache;</div>
<div class="line">        MaterialProperty::MPtr                            fProp;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">static</span> MaterialProperty::Type propertyType()</div>
<div class="line">    { assert(0); <span class="keywordflow">return</span> MaterialProperty::kFloat; }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">static</span> <span class="keywordtype">void</span> setMaterialProperty(</div>
<div class="line">        std::shared_ptr&lt;ScalarPropertyCache&lt;T&gt; &gt;&amp; cache,</div>
<div class="line">        MaterialProperty::MPtr prop,</div>
<div class="line">        <span class="keywordtype">double</span> seconds)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The list of animated property caches</span></div>
<div class="line">    std::vector&lt;ScalarMaterialProp&lt;Alembic::Abc::IBoolProperty&gt; &gt;    fBoolCaches;</div>
<div class="line">    std::vector&lt;ScalarMaterialProp&lt;Alembic::Abc::IInt32Property&gt; &gt;   fInt32Caches;</div>
<div class="line">    std::vector&lt;ScalarMaterialProp&lt;Alembic::Abc::IFloatProperty&gt; &gt;   fFloatCaches;</div>
<div class="line">    std::vector&lt;ScalarMaterialProp&lt;Alembic::Abc::IV2fProperty&gt; &gt;     fFloat2Caches;</div>
<div class="line">    std::vector&lt;ScalarMaterialProp&lt;Alembic::Abc::IV3fProperty&gt; &gt;     fFloat3Caches;</div>
<div class="line">    std::vector&lt;ScalarMaterialProp&lt;Alembic::Abc::IC3fProperty&gt; &gt;     fRGBCaches;</div>
<div class="line">    std::vector&lt;ScalarMaterialProp&lt;Alembic::Abc::IWstringProperty&gt; &gt; fStringCaches;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The valid range of the current data in property caches</span></div>
<div class="line">    TimeInterval fValidityInterval;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The material graph currently being filled-in.</span></div>
<div class="line">    MaterialGraph::MPtr fMaterialGraph;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Template explicit specialization must be in namespace scope.</span></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> MaterialProperty::Type AlembicCacheMaterialReader::propertyType&lt;Alembic::Abc::IBoolProperty&gt;()</div>
<div class="line">{ <span class="keywordflow">return</span> MaterialProperty::kBool; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> MaterialProperty::Type AlembicCacheMaterialReader::propertyType&lt;Alembic::Abc::IInt32Property&gt;()</div>
<div class="line">{ <span class="keywordflow">return</span> MaterialProperty::kInt32; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> MaterialProperty::Type AlembicCacheMaterialReader::propertyType&lt;Alembic::Abc::IFloatProperty&gt;()</div>
<div class="line">{ <span class="keywordflow">return</span> MaterialProperty::kFloat; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> MaterialProperty::Type AlembicCacheMaterialReader::propertyType&lt;Alembic::Abc::IV2fProperty&gt;()</div>
<div class="line">{ <span class="keywordflow">return</span> MaterialProperty::kFloat2; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> MaterialProperty::Type AlembicCacheMaterialReader::propertyType&lt;Alembic::Abc::IV3fProperty&gt;()</div>
<div class="line">{ <span class="keywordflow">return</span> MaterialProperty::kFloat3; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> MaterialProperty::Type AlembicCacheMaterialReader::propertyType&lt;Alembic::Abc::IC3fProperty&gt;()</div>
<div class="line">{ <span class="keywordflow">return</span> MaterialProperty::kRGB; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> MaterialProperty::Type AlembicCacheMaterialReader::propertyType&lt;Alembic::Abc::IWstringProperty&gt;()</div>
<div class="line">{ <span class="keywordflow">return</span> MaterialProperty::kString; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> AlembicCacheMaterialReader::setMaterialProperty&lt;Alembic::Abc::IBoolProperty&gt;(</div>
<div class="line">    std::shared_ptr&lt;ScalarPropertyCache&lt;Alembic::Abc::IBoolProperty&gt; &gt;&amp; cache,</div>
<div class="line">    MaterialProperty::MPtr prop,</div>
<div class="line">    <span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    prop-&gt;setBool(seconds, cache-&gt;getValue());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> AlembicCacheMaterialReader::setMaterialProperty&lt;Alembic::Abc::IInt32Property&gt;(</div>
<div class="line">    std::shared_ptr&lt;ScalarPropertyCache&lt;Alembic::Abc::IInt32Property&gt; &gt;&amp; cache,</div>
<div class="line">    MaterialProperty::MPtr prop,</div>
<div class="line">    <span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    prop-&gt;setInt32(seconds, cache-&gt;getValue());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> AlembicCacheMaterialReader::setMaterialProperty&lt;Alembic::Abc::IFloatProperty&gt;(</div>
<div class="line">    std::shared_ptr&lt;ScalarPropertyCache&lt;Alembic::Abc::IFloatProperty&gt; &gt;&amp; cache,</div>
<div class="line">    MaterialProperty::MPtr prop,</div>
<div class="line">    <span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    prop-&gt;setFloat(seconds, cache-&gt;getValue());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> AlembicCacheMaterialReader::setMaterialProperty&lt;Alembic::Abc::IV2fProperty&gt;(</div>
<div class="line">    std::shared_ptr&lt;ScalarPropertyCache&lt;Alembic::Abc::IV2fProperty&gt; &gt;&amp; cache,</div>
<div class="line">    MaterialProperty::MPtr prop,</div>
<div class="line">    <span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    Alembic::Abc::V2f value = cache-&gt;getValue();</div>
<div class="line">    prop-&gt;setFloat2(seconds, value.x, value.y);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> AlembicCacheMaterialReader::setMaterialProperty&lt;Alembic::Abc::IV3fProperty&gt;(</div>
<div class="line">    std::shared_ptr&lt;ScalarPropertyCache&lt;Alembic::Abc::IV3fProperty&gt; &gt;&amp; cache,</div>
<div class="line">    MaterialProperty::MPtr prop,</div>
<div class="line">    <span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    Alembic::Abc::V3f value = cache-&gt;getValue();</div>
<div class="line">    prop-&gt;setFloat3(seconds, value.x, value.y, value.z);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> AlembicCacheMaterialReader::setMaterialProperty&lt;Alembic::Abc::IC3fProperty&gt;(</div>
<div class="line">    std::shared_ptr&lt;ScalarPropertyCache&lt;Alembic::Abc::IC3fProperty&gt; &gt;&amp; cache,</div>
<div class="line">    MaterialProperty::MPtr prop,</div>
<div class="line">    <span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    Alembic::Abc::C3f value = cache-&gt;getValue();</div>
<div class="line">    prop-&gt;setColor(seconds, <a name="_a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>(value.x, value.y, value.z));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> AlembicCacheMaterialReader::setMaterialProperty&lt;Alembic::Abc::IWstringProperty&gt;(</div>
<div class="line">    std::shared_ptr&lt;ScalarPropertyCache&lt;Alembic::Abc::IWstringProperty&gt; &gt;&amp; cache,</div>
<div class="line">    MaterialProperty::MPtr prop,</div>
<div class="line">    <span class="keywordtype">double</span> seconds)</div>
<div class="line">{</div>
<div class="line">    std::wstring value = cache-&gt;getValue();</div>
<div class="line">    prop-&gt;setString(seconds, value.c_str());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace CacheReaderAlembicPrivate</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS AlembicCacheReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>AlembicCacheReader : <span class="keyword">public</span> CacheReader</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> std::shared_ptr&lt;CacheReader&gt; create(<span class="keyword">const</span> <a name="_a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file);</div>
<div class="line"></div>
<div class="line">    ~AlembicCacheReader() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> valid() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> validateGeomPath(</div>
<div class="line">        <span class="keyword">const</span> <a name="_a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; validatedGeomPath) <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    SubNode::Ptr readScene(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <span class="keywordtype">bool</span> needUVs) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    SubNode::Ptr readHierarchy(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <span class="keywordtype">bool</span> needUVs) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    SubNode::Ptr readShape(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <span class="keywordtype">bool</span> needUVs) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    MaterialGraphMap::Ptr readMaterials() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> readAnimTimeRange(TimeInterval&amp; range) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> saveReader(<span class="keyword">const</span> std::string&amp; fullName, </div>
<div class="line">                    CacheReaderAlembicPrivate::AlembicCacheObjectReader::Ptr&amp; reader);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>AlembicCacheMeshReader;</div>
<div class="line">    <span class="keyword">struct </span>MakeSharedEnabler;</div>
<div class="line"></div>
<div class="line">    AlembicCacheReader(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a> fFile;</div>
<div class="line">    <span class="keyword">mutable</span> Alembic::Abc::IArchive fAbcArchive;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> std::unordered_map&lt;std::string,CacheReaderAlembicPrivate::AlembicCacheObjectReader::Ptr&gt; ObjectReaderMap;</div>
<div class="line">    ObjectReaderMap fSavedReaders;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace GPUCache</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
