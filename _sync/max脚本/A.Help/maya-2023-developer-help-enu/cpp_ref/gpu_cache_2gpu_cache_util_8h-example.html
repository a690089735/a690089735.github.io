<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
      <title>C++ API Reference: gpuCache/gpuCacheUtil.h</title>
      
	  
      
      
      
      
      
      
      
    

</head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_util_8h-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
      <div>
         <div class="head">
            <h1>C++ API Reference: gpuCache/gpuCacheUtil.h</h1>
         </div>

<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->

  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="cpp_ref/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="cpp_ref/search/close.png" alt=""></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<!-- window showing the filter options -->


<!-- iframe showing the search results (closed by default) -->


<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/gpuCacheUtil.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _gpuCacheUtil_h_</span></div>
<div class="line"><span class="preprocessor">#define _gpuCacheUtil_h_</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Includes</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlugArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDagNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlug.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatVector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatVectorArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatPoint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatPointArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MStringResource.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_set&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheSample.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheGeometry.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheMaterialNodes.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef _DEBUG</span></div>
<div class="line"><span class="preprocessor">    #define MStatAssert(status) assert(status)</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">    #define MStatAssert(status) ((void)status)</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Check the visibility of a shape node</span></div>
<div class="line"><span class="comment">// including visibility plug and display layer</span></div>
<div class="line"><span class="keyword">class </span>ShapeVisibilityChecker</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ShapeVisibilityChecker(<span class="keyword">const</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; shapeNode)</div>
<div class="line">        : fShape(shapeNode)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> isVisible()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Check visibility plug</span></div>
<div class="line">        <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> visibilityPlug = fShape.findPlug(<span class="stringliteral">&quot;visibility&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line">        assert(!visibilityPlug.<a name="a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>());</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!visibilityPlug.<a name="a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a69b4092a85b4edf58b7d50f331cc38cf">asBool</a>()) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check display layer</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> drawOverridePlug = fShape.findPlug(<span class="stringliteral">&quot;drawOverride&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line">        assert(!drawOverridePlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>());</div>
<div class="line"></div>
<div class="line">        <a name="_a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html">MPlugArray</a> displayLayers;</div>
<div class="line">        drawOverridePlug.<a name="a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#acf1340576a4a0a78a0045e67ee4155bf">connectedTo</a>(displayLayers, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; displayLayers.length(); i++) {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> displayLayerNode = displayLayers[i].node();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (displayLayerNode.<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a3973c8e6d9fab0774657cca3fe7b118c">MFn::kDisplayLayer</a>)) {</div>
<div class="line">                <span class="comment">// Found a display layer</span></div>
<div class="line">                <a name="_a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a> displayLayer(displayLayerNode);</div>
<div class="line">                visibilityPlug = displayLayer.<a name="a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(<span class="stringliteral">&quot;visibility&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">                assert(!visibilityPlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>());</div>
<div class="line">                <span class="keywordflow">if</span> (!visibilityPlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a69b4092a85b4edf58b7d50f331cc38cf">asBool</a>()) {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Forbidden and not implemented.</span></div>
<div class="line">    ShapeVisibilityChecker(<span class="keyword">const</span> ShapeVisibilityChecker&amp;);</div>
<div class="line">    <span class="keyword">const</span> ShapeVisibilityChecker&amp; operator=(<span class="keyword">const</span> ShapeVisibilityChecker&amp;);</div>
<div class="line"></div>
<div class="line">    <a name="_a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dag_node.html">MFnDagNode</a> fShape;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class is used for generating wireframe indices.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> INDEX_TYPE&gt;</div>
<div class="line"><span class="keyword">class </span>WireIndicesGenerator</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> INDEX_TYPE index_type;</div>
<div class="line"></div>
<div class="line">    WireIndicesGenerator(<span class="keywordtype">size_t</span> numFaceCounts, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* faceCounts,</div>
<div class="line">                         <span class="keywordtype">size_t</span> numFaceIndices, <span class="keyword">const</span> index_type* faceIndices,</div>
<div class="line">                         <span class="keyword">const</span> index_type* mappedFaceIndices)</div>
<div class="line">      : fNumFaceCounts(numFaceCounts), fFaceCounts(faceCounts),</div>
<div class="line">        fNumFaceIndices(numFaceIndices), fFaceIndices(faceIndices),</div>
<div class="line">        fMappedFaceIndices(mappedFaceIndices),</div>
<div class="line">        fNumWires(0)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> compute()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (fNumFaceCounts == 0 || fNumFaceIndices == 0) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// pre-allocate buffers for the worst case</span></div>
<div class="line">        <span class="keywordtype">size_t</span> maxNumWires = fNumFaceIndices;</div>
<div class="line">        std::unordered_set&lt;WirePair, typename WirePair::Hash, typename WirePair::EqualTo&gt;</div>
<div class="line">                wireSet(<span class="keywordtype">size_t</span>(maxNumWires / 0.75f));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// insert all wires to the set</span></div>
<div class="line">        <span class="keywordtype">size_t</span> polyIndex = 0;</div>
<div class="line">        <span class="keywordtype">size_t</span> endOfPoly = fFaceCounts[polyIndex];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; fNumFaceIndices; i++) {</div>
<div class="line">            <span class="comment">// find the two vertices of the wireframe</span></div>
<div class="line">            <span class="comment">// v1 and v2 (face indices before splitting vertices) are hashed to</span></div>
<div class="line">            <span class="comment">// remove duplicated wireframe lines.</span></div>
<div class="line">            <span class="comment">// mappedV1 and mappedV2 are the actual indices to remapped</span></div>
<div class="line">            <span class="comment">// positions/normals/UVs</span></div>
<div class="line">            index_type v1, v2, mappedV1, mappedV2;</div>
<div class="line">            v1       = fFaceIndices[i];</div>
<div class="line">            mappedV1 = fMappedFaceIndices[i];</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">size_t</span> v2Index;</div>
<div class="line">            <span class="keywordflow">if</span> (i + 1 == endOfPoly) {</div>
<div class="line">                <span class="comment">// wrap at the end of the polygon</span></div>
<div class="line">                v2Index = i + 1 - fFaceCounts[polyIndex];</div>
<div class="line">                <span class="keywordflow">if</span> (++polyIndex &lt; fNumFaceCounts) {</div>
<div class="line">                    endOfPoly += fFaceCounts[polyIndex];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                v2Index = i + 1;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            v2       = fFaceIndices[v2Index];</div>
<div class="line">            mappedV2 = fMappedFaceIndices[v2Index];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// insert</span></div>
<div class="line">            wireSet.insert(WirePair(v1, v2, mappedV1, mappedV2));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// the number of wireframes</span></div>
<div class="line">        <span class="keywordtype">size_t</span> numWires = wireSet.size();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// allocate buffers for wireframe indices</span></div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; wireIndices(<span class="keyword">new</span> index_type[numWires * 2]);</div>
<div class="line">        <span class="keywordtype">size_t</span> wireCount = 0;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> WirePair&amp; pair : wireSet) {</div>
<div class="line">            wireIndices[wireCount * 2 + 0] = pair.fMappedV1;</div>
<div class="line">            wireIndices[wireCount * 2 + 1] = pair.fMappedV2;</div>
<div class="line">            wireCount++;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fNumWires    = numWires;</div>
<div class="line">        fWireIndices = wireIndices;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>                           numWires()    { <span class="keywordflow">return</span> fNumWires; }</div>
<div class="line">    GPUCache::shared_array&lt;index_type&gt;&amp; wireIndices() { <span class="keywordflow">return</span> fWireIndices; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    WireIndicesGenerator(<span class="keyword">const</span> WireIndicesGenerator&amp;);</div>
<div class="line">    <span class="keyword">const</span> WireIndicesGenerator&amp; operator= (<span class="keyword">const</span> WireIndicesGenerator&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This class represents an unordered pair for wireframe indices</span></div>
<div class="line">    <span class="keyword">struct </span>WirePair</div>
<div class="line">    {</div>
<div class="line">        WirePair(index_type v1, index_type v2, </div>
<div class="line">                 index_type mappedV1, index_type mappedV2)</div>
<div class="line">            : fV1(v1), fV2(v2), fMappedV1(mappedV1), fMappedV2(mappedV2)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">struct </span>Hash</div>
<div class="line">        {</div>
<div class="line">            std::size_t operator()(<span class="keyword">const</span> WirePair&amp; pair)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                std::size_t seed = 0;</div>
<div class="line">                <span class="keywordflow">if</span> (pair.fV1 &lt; pair.fV2) {</div>
<div class="line">                    GPUCache::hash_combine(seed, pair.fV1);</div>
<div class="line">                    GPUCache::hash_combine(seed, pair.fV2);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> {</div>
<div class="line">                    GPUCache::hash_combine(seed, pair.fV2);</div>
<div class="line">                    GPUCache::hash_combine(seed, pair.fV1);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> seed;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">struct </span>EqualTo</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> WirePair&amp; x, <span class="keyword">const</span> WirePair&amp; y)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                <span class="keywordflow">if</span> (x.fV1 &lt; x.fV2) {</div>
<div class="line">                    <span class="keywordflow">if</span> (y.fV1 &lt; y.fV2) {</div>
<div class="line">                        <span class="keywordflow">return</span> (x.fV1 == y.fV1 &amp;&amp; x.fV2 == y.fV2);</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> {</div>
<div class="line">                        <span class="keywordflow">return</span> (x.fV1 == y.fV2 &amp;&amp; x.fV2 == y.fV1);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="keywordflow">if</span> (y.fV1 &lt; y.fV2) {</div>
<div class="line">                        <span class="keywordflow">return</span> (x.fV2 == y.fV1 &amp;&amp; x.fV1 == y.fV2);</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> {</div>
<div class="line">                        <span class="keywordflow">return</span> (x.fV2 == y.fV2 &amp;&amp; x.fV1 == y.fV1);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        index_type fV1, fV2;</div>
<div class="line">        index_type fMappedV1, fMappedV2;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Input</span></div>
<div class="line">    <span class="keywordtype">size_t</span>              fNumFaceCounts;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* fFaceCounts;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>              fNumFaceIndices;</div>
<div class="line">    <span class="keyword">const</span> index_type*   fFaceIndices;</div>
<div class="line">    <span class="keyword">const</span> index_type*   fMappedFaceIndices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output</span></div>
<div class="line">    <span class="keywordtype">size_t</span>                          fNumWires;</div>
<div class="line">    GPUCache::shared_array&lt;index_type&gt; fWireIndices;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class converts multi-indexed streams to single-indexed streams.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> INDEX_TYPE, <span class="keywordtype">size_t</span> MAX_NUM_STREAMS = 16&gt;</div>
<div class="line"><span class="keyword">class </span>MultiIndexedStreamsConverter</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> INDEX_TYPE index_type;</div>
<div class="line"></div>
<div class="line">    MultiIndexedStreamsConverter(<span class="keywordtype">size_t</span> numFaceIndices, <span class="keyword">const</span> index_type* faceIndices)</div>
<div class="line">        : fNumFaceIndices(numFaceIndices), fFaceIndices(faceIndices), fNumStreams(0),</div>
<div class="line">          fNumVertices(0)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// position stream</span></div>
<div class="line">        addMultiIndexedStream(faceIndices);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> addMultiIndexedStream(<span class="keyword">const</span> index_type* indices)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// indices can be NULL, sequence 0,1,2,3,4,5... is assumed</span></div>
<div class="line">        fStreams[fNumStreams++] = indices;</div>
<div class="line">        assert(fNumStreams &lt;= MAX_NUM_STREAMS);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> compute()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// pre-allocate buffers for the worst case</span></div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; indicesRegion(</div>
<div class="line">            <span class="keyword">new</span> index_type[fNumStreams * fNumFaceIndices]);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// the hash map to find unique combination of multi-indices</span></div>
<div class="line">        <span class="keyword">typedef</span> std::unordered_map&lt;IndexTuple,size_t,typename IndexTuple::Hash,typename IndexTuple::EqualTo&gt; IndicesMap;</div>
<div class="line">        IndicesMap indicesMap(<span class="keywordtype">size_t</span>(fNumFaceIndices / 0.75f));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// fill the hash map with multi-indices</span></div>
<div class="line">        <span class="keywordtype">size_t</span> vertexAttribIndex = 0;  <span class="comment">// index to the remapped vertex attribs</span></div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; mappedFaceIndices(<span class="keyword">new</span> index_type[fNumFaceIndices]);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; fNumFaceIndices; i++) {</div>
<div class="line">            <span class="comment">// find the location in the region to copy multi-indices</span></div>
<div class="line">            index_type* indices = &amp;indicesRegion[i * fNumStreams];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// make a tuple consists of indices for positions, normals, UVs..</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fNumStreams; j++) {</div>
<div class="line">                indices[j] = fStreams[j] ? fStreams[j][i] : (index_type)i;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// try to insert the multi-indices tuple to the hash map</span></div>
<div class="line">            IndexTuple tuple(indices, fNumStreams, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)i);</div>
<div class="line">            std::pair&lt;typename IndicesMap::iterator,bool&gt; ret = indicesMap.insert(std::make_pair(tuple, 0));</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (ret.second) {</div>
<div class="line">                <span class="comment">// a success insert, allocate a vertex attrib index to the multi-index combination</span></div>
<div class="line">                ret.first-&gt;second = vertexAttribIndex++;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// remap face indices</span></div>
<div class="line">            mappedFaceIndices[i] = (index_type)ret.first-&gt;second;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// the number of unique combination is the size of vertex attrib arrays</span></div>
<div class="line">        <span class="keywordtype">size_t</span> numVertex = vertexAttribIndex;</div>
<div class="line">        assert(vertexAttribIndex == indicesMap.size());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// allocate memory for the indices into faceIndices</span></div>
<div class="line">        GPUCache::shared_array&lt;unsigned int&gt; vertAttribsIndices(<span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[numVertex]);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// build the indices (how the new vertex maps to the poly vert)</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">typename</span> IndicesMap::value_type&amp; pair : indicesMap) {</div>
<div class="line">            vertAttribsIndices[pair.second] = pair.first.faceIndex();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fMappedFaceIndices  = mappedFaceIndices;</div>
<div class="line">        fVertAttribsIndices = vertAttribsIndices;</div>
<div class="line">        fNumVertices        = numVertex;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                       numStreams()         { <span class="keywordflow">return</span> fNumStreams; }</div>
<div class="line">    <span class="keywordtype">size_t</span>                             numVertices()        { <span class="keywordflow">return</span> fNumVertices; }</div>
<div class="line">    GPUCache::shared_array&lt;unsigned int&gt;&amp; vertAttribsIndices() { <span class="keywordflow">return</span> fVertAttribsIndices; }</div>
<div class="line">    GPUCache::shared_array&lt;index_type&gt;&amp;   mappedFaceIndices()  { <span class="keywordflow">return</span> fMappedFaceIndices; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    MultiIndexedStreamsConverter(<span class="keyword">const</span> MultiIndexedStreamsConverter&amp;);</div>
<div class="line">    <span class="keyword">const</span> MultiIndexedStreamsConverter&amp; operator= (<span class="keyword">const</span> MultiIndexedStreamsConverter&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This class represents a multi-index combination</span></div>
<div class="line">    <span class="keyword">class </span>IndexTuple</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        IndexTuple(index_type* indices, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceIndex)</div>
<div class="line">            : fIndices(indices), fSize(size), fFaceIndex(faceIndex)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> index_type&amp; operator[](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            assert(index &lt; fSize);</div>
<div class="line">            <span class="keywordflow">return</span> fIndices[index];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceIndex()<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> fFaceIndex;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">struct </span>Hash</div>
<div class="line">        {</div>
<div class="line">            std::size_t operator()(<span class="keyword">const</span> IndexTuple&amp; tuple)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                std::size_t seed = 0;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; tuple.fSize; i++) {</div>
<div class="line">                    GPUCache::hash_combine(seed, tuple.fIndices[i]);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> seed;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">struct </span>EqualTo</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> IndexTuple&amp; x, <span class="keyword">const</span> IndexTuple&amp; y)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                <span class="keywordflow">if</span> (x.fSize == y.fSize) {</div>
<div class="line">                    <span class="keywordflow">return</span> memcmp(x.fIndices, y.fIndices, <span class="keyword">sizeof</span>(index_type) * x.fSize) == 0;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        index_type*  fIndices;</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fFaceIndex;</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fSize;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Input</span></div>
<div class="line">    <span class="keywordtype">size_t</span>            fNumFaceIndices;       </div>
<div class="line">    <span class="keyword">const</span> index_type* fFaceIndices;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> index_type* fStreams[MAX_NUM_STREAMS];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      fNumStreams;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output</span></div>
<div class="line">    <span class="keywordtype">size_t</span>                            fNumVertices;</div>
<div class="line">    GPUCache::shared_array&lt;unsigned int&gt; fVertAttribsIndices;</div>
<div class="line">    GPUCache::shared_array&lt;index_type&gt;   fMappedFaceIndices;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// This class drops indices for a vertex attrib</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> INDEX_TYPE, <span class="keywordtype">size_t</span> SIZE&gt;</div>
<div class="line"><span class="keyword">class </span>IndicesDropper</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> INDEX_TYPE index_type;</div>
<div class="line"></div>
<div class="line">    IndicesDropper(<span class="keyword">const</span> <span class="keywordtype">float</span>* attribArray, <span class="keyword">const</span> index_type* indexArray, <span class="keywordtype">size_t</span> numVerts)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// map the indexed array to direct array</span></div>
<div class="line">        GPUCache::shared_array&lt;float&gt; mappedAttribs(<span class="keyword">new</span> <span class="keywordtype">float</span>[numVerts * SIZE]);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numVerts; i++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; SIZE; j++) {</div>
<div class="line">                mappedAttribs[i * SIZE + j] = attribArray[indexArray[i] * SIZE + j];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fMappedAttribs = mappedAttribs;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    GPUCache::shared_array&lt;float&gt;&amp; mappedAttribs() { <span class="keywordflow">return</span> fMappedAttribs; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    IndicesDropper(<span class="keyword">const</span> IndicesDropper&amp;);</div>
<div class="line">    <span class="keyword">const</span> IndicesDropper&amp; operator= (<span class="keyword">const</span> IndicesDropper&amp;);</div>
<div class="line"></div>
<div class="line">    GPUCache::shared_array&lt;float&gt; fMappedAttribs;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class remaps multi-indexed vertex attribs (drop indices).</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> INDEX_TYPE, <span class="keywordtype">size_t</span> MAX_NUM_STREAMS = 16&gt;</div>
<div class="line"><span class="keyword">class </span>MultiIndexedStreamsRemapper</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> INDEX_TYPE index_type;</div>
<div class="line"></div>
<div class="line">    MultiIndexedStreamsRemapper(<span class="keyword">const</span> index_type* faceIndices,</div>
<div class="line">            <span class="keywordtype">size_t</span> numNewVertices, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* vertAttribsIndices)</div>
<div class="line">        : fFaceIndices(faceIndices), fNumNewVertices(numNewVertices),</div>
<div class="line">          fVertAttribsIndices(vertAttribsIndices), fNumStreams(0)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> addMultiIndexedStream(<span class="keyword">const</span> <span class="keywordtype">float</span>* attribs, <span class="keyword">const</span> index_type* indices, <span class="keywordtype">bool</span> faceVarying, <span class="keywordtype">int</span> stride)</div>
<div class="line">    {</div>
<div class="line">        fAttribs[fNumStreams]     = attribs;</div>
<div class="line">        fIndices[fNumStreams]     = indices;</div>
<div class="line">        fFaceVarying[fNumStreams] = faceVarying;</div>
<div class="line">        fStride[fNumStreams]      = stride;</div>
<div class="line">        fNumStreams++;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> compute()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// remap vertex attribs</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fNumStreams; i++) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>*      attribs     = fAttribs[i];</div>
<div class="line">            <span class="keyword">const</span> index_type* indices     = fIndices[i];</div>
<div class="line">            <span class="keywordtype">bool</span>              faceVarying = fFaceVarying[i];</div>
<div class="line">            <span class="keywordtype">int</span>               stride      = fStride[i];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// allocate memory for remapped vertex attrib arrays</span></div>
<div class="line">            GPUCache::shared_array&lt;float&gt; mappedVertAttrib(</div>
<div class="line">                <span class="keyword">new</span> <span class="keywordtype">float</span>[fNumNewVertices * stride]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; fNumNewVertices; j++) {</div>
<div class="line">                <span class="comment">// new j-th vertices maps to polyVertIndex-th poly vert</span></div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertIndex = fVertAttribsIndices[j];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// if the scope is varying/vertex, need to convert poly vert</span></div>
<div class="line">                <span class="comment">// index to vertex index</span></div>
<div class="line">                index_type pointOrPolyVertIndex = faceVarying ?</div>
<div class="line">                            polyVertIndex : fFaceIndices[polyVertIndex];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// look up the vertex attrib index</span></div>
<div class="line">                index_type attribIndex = indices ?</div>
<div class="line">                            indices[pointOrPolyVertIndex] : pointOrPolyVertIndex;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (stride == 3) {</div>
<div class="line">                    mappedVertAttrib[j * 3 + 0] = attribs[attribIndex * 3 + 0];</div>
<div class="line">                    mappedVertAttrib[j * 3 + 1] = attribs[attribIndex * 3 + 1];</div>
<div class="line">                    mappedVertAttrib[j * 3 + 2] = attribs[attribIndex * 3 + 2];</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (stride == 2) {</div>
<div class="line">                    mappedVertAttrib[j * 2 + 0] = attribs[attribIndex * 2 + 0];</div>
<div class="line">                    mappedVertAttrib[j * 2 + 1] = attribs[attribIndex * 2 + 1];</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> {</div>
<div class="line">                    assert(0);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            fMappedVertAttribs[i] = mappedVertAttrib;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    GPUCache::shared_array&lt;float&gt;&amp; mappedVertAttribs(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)</div>
<div class="line">    {</div>
<div class="line">        assert(index &lt; fNumStreams);</div>
<div class="line">        <span class="keywordflow">return</span> fMappedVertAttribs[index];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    MultiIndexedStreamsRemapper(<span class="keyword">const</span> MultiIndexedStreamsRemapper&amp;);</div>
<div class="line">    <span class="keyword">const</span> MultiIndexedStreamsRemapper&amp; operator= (<span class="keyword">const</span> MultiIndexedStreamsRemapper&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Input</span></div>
<div class="line">    <span class="keyword">const</span> index_type*   fFaceIndices;</div>
<div class="line">    <span class="keywordtype">size_t</span>              fNumNewVertices;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* fVertAttribsIndices;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>*      fAttribs[MAX_NUM_STREAMS];</div>
<div class="line">    <span class="keyword">const</span> index_type* fIndices[MAX_NUM_STREAMS];</div>
<div class="line">    <span class="keywordtype">bool</span>              fFaceVarying[MAX_NUM_STREAMS];</div>
<div class="line">    <span class="keywordtype">int</span>               fStride[MAX_NUM_STREAMS];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      fNumStreams;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output, NULL means no change</span></div>
<div class="line">    GPUCache::shared_array&lt;float&gt; fMappedVertAttribs[MAX_NUM_STREAMS];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class triangulates polygons.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> INDEX_TYPE&gt;</div>
<div class="line"><span class="keyword">class </span>PolyTriangulator</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> INDEX_TYPE index_type;</div>
<div class="line"></div>
<div class="line">    PolyTriangulator(<span class="keywordtype">size_t</span> numFaceCounts, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* faceCounts,</div>
<div class="line">                     <span class="keyword">const</span> index_type* faceIndices, <span class="keywordtype">bool</span> faceIndicesCW,</div>
<div class="line">                     <span class="keyword">const</span> <span class="keywordtype">float</span>* positions, <span class="keyword">const</span> <span class="keywordtype">float</span>* normals)</div>
<div class="line">        : fNumFaceCounts(numFaceCounts), fFaceCounts(faceCounts),</div>
<div class="line">          fFaceIndices(faceIndices), fFaceIndicesCW(faceIndicesCW),</div>
<div class="line">          fPositions(positions), fNormals(normals),</div>
<div class="line">          fNumTriangles(0)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> compute()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// empty mesh</span></div>
<div class="line">        <span class="keywordflow">if</span> (fNumFaceCounts == 0) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// scan the polygons to estimate the buffer size</span></div>
<div class="line">        <span class="keywordtype">size_t</span> maxPoints      = 0;  <span class="comment">// the max number of vertices in one polygon</span></div>
<div class="line">        <span class="keywordtype">size_t</span> totalTriangles = 0;  <span class="comment">// the number of triangles in the mesh</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; fNumFaceCounts; i++) {</div>
<div class="line">            <span class="keywordtype">size_t</span> numPoints = fFaceCounts[i];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// ignore degenerate polygon</span></div>
<div class="line">            <span class="keywordflow">if</span> (numPoints &lt; 3) {</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// max number of points in a polygon</span></div>
<div class="line">            maxPoints = std::max(numPoints, maxPoints);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// the number of triangles expected in the polygon</span></div>
<div class="line">            <span class="keywordtype">size_t</span> numTriangles = numPoints - 2;</div>
<div class="line">            totalTriangles += numTriangles;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">size_t</span> maxTriangles = maxPoints - 2;  <span class="comment">// the max number of triangles in a polygon</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// allocate buffers for the worst case</span></div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt;     indices(<span class="keyword">new</span> index_type[maxPoints]);</div>
<div class="line">        GPUCache::shared_array&lt;unsigned short&gt; triangles(<span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[maxTriangles * 3]);</div>
<div class="line">        GPUCache::shared_array&lt;float&gt;          aPosition(<span class="keyword">new</span> <span class="keywordtype">float</span>[maxPoints * 2]);</div>
<div class="line">        GPUCache::shared_array&lt;float&gt;          aNormal;</div>
<div class="line">        <span class="keywordflow">if</span> (fNormals) {</div>
<div class="line">            aNormal.reset(<span class="keyword">new</span> <span class="keywordtype">float</span>[maxPoints * 3]);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; triangleIndices(<span class="keyword">new</span> index_type[totalTriangles * 3]);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// triangulate each polygon</span></div>
<div class="line">        <span class="keywordtype">size_t</span> triangleCount  = 0;  <span class="comment">// the triangles</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, polyVertOffset = 0; i &lt; fNumFaceCounts; polyVertOffset += fFaceCounts[i], i++) {</div>
<div class="line">            <span class="keywordtype">size_t</span> numPoints = fFaceCounts[i];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// ignore degenerate polygon</span></div>
<div class="line">            <span class="keywordflow">if</span> (numPoints &lt; 3) {</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// no need to triangulate a triangle</span></div>
<div class="line">            <span class="keywordflow">if</span> (numPoints == 3) {</div>
<div class="line">                <span class="keywordflow">if</span> (fFaceIndicesCW) {</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 0] = fFaceIndices[polyVertOffset + 2];</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 1] = fFaceIndices[polyVertOffset + 1];</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 2] = fFaceIndices[polyVertOffset + 0];</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> {</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 0] = fFaceIndices[polyVertOffset + 0];</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 1] = fFaceIndices[polyVertOffset + 1];</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 2] = fFaceIndices[polyVertOffset + 2];</div>
<div class="line">                }</div>
<div class="line">                triangleCount++;</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// 1) correct the polygon winding from CW to CCW</span></div>
<div class="line">            <span class="keywordflow">if</span> (fFaceIndicesCW)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numPoints; j++) {</div>
<div class="line">                    <span class="keywordtype">size_t</span> jCCW = numPoints - j - 1;</div>
<div class="line">                    indices[j] = fFaceIndices[polyVertOffset + jCCW];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numPoints; j++) {</div>
<div class="line">                    indices[j] = fFaceIndices[polyVertOffset + j];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// 2) compute the face normal (Newell&#39;s Method)</span></div>
<div class="line">            <a name="_a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> faceNormal(0.0f, 0.0f, 0.0f);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numPoints; j++) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span>* thisPoint = &amp;fPositions[indices[j] * 3];</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span>* nextPoint = &amp;fPositions[indices[(j + numPoints - 1) % numPoints] * 3];</div>
<div class="line">                faceNormal.<a name="a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> += (thisPoint[1] - nextPoint[1]) * (thisPoint[2] + nextPoint[2]);</div>
<div class="line">                faceNormal.<a name="a13"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html#aa4f0d3eebc3c443f9be81bf48561a217">y</a> += (thisPoint[2] - nextPoint[2]) * (thisPoint[0] + nextPoint[0]);</div>
<div class="line">                faceNormal.<a name="a14"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html#af73583b1e980b0aa03f9884812e9fd4d">z</a> += (thisPoint[0] - nextPoint[0]) * (thisPoint[1] + nextPoint[1]);</div>
<div class="line">            }</div>
<div class="line">            faceNormal.<a name="a15"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html#ab66b0c7697d96a278da9bca810f4dee1">normalize</a>();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// 3) project the vertices to 2d plane by faceNormal</span></div>
<div class="line">            <span class="keywordtype">float</span> cosa, sina, cosb, sinb, cacb, sacb;</div>
<div class="line">            sinb = -sqrtf(faceNormal[0] * faceNormal[0] + faceNormal[1] * faceNormal[1]);</div>
<div class="line">            <span class="keywordflow">if</span> (sinb &lt; -1e-5) {</div>
<div class="line">                cosb =  faceNormal[2];</div>
<div class="line">                sina =  faceNormal[1] / sinb;</div>
<div class="line">                cosa = -faceNormal[0] / sinb;</div>
<div class="line"></div>
<div class="line">                cacb = cosa * cosb;</div>
<div class="line">                sacb = sina * cosb;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                cacb = 1.0f;</div>
<div class="line">                sacb = 0.0f;</div>
<div class="line">                sinb = 0.0f;</div>
<div class="line">                sina = 0.0f;</div>
<div class="line">                <span class="keywordflow">if</span> (faceNormal[2] &gt; 0.0f) {</div>
<div class="line">                    cosa = 1.0f;</div>
<div class="line">                    cosb = 1.0f;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> {</div>
<div class="line">                    cosa = -1.0f;</div>
<div class="line">                    cosb = -1.0f;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numPoints; j++) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span>* point = &amp;fPositions[indices[j] * 3];</div>
<div class="line">                aPosition[j * 2 + 0] = cacb * point[0] - sacb * point[1] + sinb * point[2];</div>
<div class="line">                aPosition[j * 2 + 1] = sina * point[0] + cosa * point[1];</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// 4) copy normals</span></div>
<div class="line">            <span class="keywordflow">if</span> (fNormals) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numPoints; j++) {</div>
<div class="line">                    aNormal[j * 3 + 0] = fNormals[indices[j] * 3 + 0];</div>
<div class="line">                    aNormal[j * 3 + 1] = fNormals[indices[j] * 3 + 1];</div>
<div class="line">                    aNormal[j * 3 + 2] = fNormals[indices[j] * 3 + 2];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// 5) do triangulation</span></div>
<div class="line">            <span class="keywordtype">int</span> numResultTriangles = 0;</div>
<div class="line">            <a name="a16"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html#ad48b6008bf77ccf6159cd6875a6ce0d9">MFnMesh::polyTriangulate</a>(</div>
<div class="line">                aPosition.get(),</div>
<div class="line">                (<span class="keywordtype">unsigned</span> int)numPoints,</div>
<div class="line">                (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numPoints,</div>
<div class="line">                0,</div>
<div class="line">                fNormals != NULL,</div>
<div class="line">                aNormal.get(),</div>
<div class="line">                triangles.get(),</div>
<div class="line">                numResultTriangles);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (numResultTriangles == <span class="keywordtype">int</span>(numPoints - 2)) {</div>
<div class="line">                <span class="comment">// triangulation success</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; size_t(numResultTriangles); j++) {</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 0] = indices[triangles[j * 3 + 0]];</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 1] = indices[triangles[j * 3 + 1]];</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 2] = indices[triangles[j * 3 + 2]];</div>
<div class="line">                    triangleCount++;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// triangulation failure, use the default triangulation</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j &lt; numPoints - 1; j++) {</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 0] = indices[0];</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 1] = indices[j];</div>
<div class="line">                    triangleIndices[triangleCount * 3 + 2] = indices[j + 1];</div>
<div class="line">                    triangleCount++;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fNumTriangles    = totalTriangles;</div>
<div class="line">        fTriangleIndices = triangleIndices;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> numTriangles() { <span class="keywordflow">return</span> fNumTriangles; }</div>
<div class="line">    GPUCache::shared_array&lt;index_type&gt;&amp; triangleIndices() { <span class="keywordflow">return</span> fTriangleIndices; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    PolyTriangulator(<span class="keyword">const</span> PolyTriangulator&amp;);</div>
<div class="line">    <span class="keyword">const</span> PolyTriangulator&amp; operator= (<span class="keyword">const</span> PolyTriangulator&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Input</span></div>
<div class="line">    <span class="keywordtype">size_t</span>              fNumFaceCounts;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* fFaceCounts;</div>
<div class="line">    <span class="keyword">const</span> index_type*   fFaceIndices;</div>
<div class="line">    <span class="keywordtype">bool</span>                fFaceIndicesCW;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>*        fPositions;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>*        fNormals;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output</span></div>
<div class="line">    <span class="keywordtype">size_t</span>                          fNumTriangles;</div>
<div class="line">    GPUCache::shared_array&lt;index_type&gt; fTriangleIndices;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class extracts mesh information from Maya mesh</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> INDEX_TYPE&gt;</div>
<div class="line"><span class="keyword">class </span>MayaMeshExtractor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> INDEX_TYPE index_type;</div>
<div class="line"></div>
<div class="line">    MayaMeshExtractor(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; meshObj)</div>
<div class="line">        : fPolyMesh(meshObj), fWantUVs(<span class="keyword">true</span>)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> setWantUVs(<span class="keywordtype">bool</span> wantUVs) { fWantUVs = wantUVs; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> compute()</div>
<div class="line">    {</div>
<div class="line">        <a name="_a17"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">        <span class="keywordtype">bool</span> needTriangulate = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Topology</span></div>
<div class="line">        <span class="keywordtype">size_t</span>                         numFaceCounts;</div>
<div class="line">        GPUCache::shared_array&lt;unsigned int&gt; faceCounts;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">size_t</span>                       numFaceIndices;</div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; faceIndices;</div>
<div class="line"></div>
<div class="line">        {</div>
<div class="line">            <a name="_a18"></a><a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> mayaVertexCount, mayaVertexList;</div>
<div class="line">            status = fPolyMesh.getVertices(mayaVertexCount, mayaVertexList);</div>
<div class="line">            assert(status == MS::kSuccess);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Copy Maya arrays</span></div>
<div class="line">            numFaceCounts             = mayaVertexCount.<a name="a19"></a><a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span>* srcVertexCount = &amp;mayaVertexCount[0];</div>
<div class="line">            faceCounts.reset(<span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[numFaceCounts]);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numFaceCounts; i++) {</div>
<div class="line">                faceCounts[i] = srcVertexCount[i];</div>
<div class="line">                <span class="keywordflow">if</span> (faceCounts[i] != 3) needTriangulate = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            numFaceIndices           = mayaVertexList.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span>* srcVertexList = &amp;mayaVertexList[0];</div>
<div class="line">            faceIndices.reset(<span class="keyword">new</span> index_type[numFaceIndices]);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numFaceIndices; i++) {</div>
<div class="line">                faceIndices[i] = srcVertexList[i];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Positions</span></div>
<div class="line">        GPUCache::shared_array&lt;float&gt; positions;</div>
<div class="line">        {</div>
<div class="line">            <a name="_a20"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point_array.html">MFloatPointArray</a> mayaPositions;</div>
<div class="line">            status = fPolyMesh.getPoints(mayaPositions);</div>
<div class="line">            assert(status == MS::kSuccess);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Allocate memory for positions</span></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPositions = mayaPositions.<a name="a21"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line">            positions.reset(<span class="keyword">new</span> <span class="keywordtype">float</span>[numPositions * 3]);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// just copy the positions to shared_array</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numPositions; i++) {</div>
<div class="line">                <a name="_a22"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point.html">MFloatPoint</a>&amp; point = mayaPositions[i];</div>
<div class="line">                positions[i * 3 + 0] = point.<a name="a23"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point.html#ad0da36b2558901e21e7a30f6c227a45e">x</a>;</div>
<div class="line">                positions[i * 3 + 1] = point.<a name="a24"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point.html#aa4f0d3eebc3c443f9be81bf48561a217">y</a>;</div>
<div class="line">                positions[i * 3 + 2] = point.<a name="a25"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_point.html#af73583b1e980b0aa03f9884812e9fd4d">z</a>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Normals</span></div>
<div class="line">        GPUCache::shared_array&lt;float&gt;      normals;</div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; normalIndices;</div>
<div class="line">        {</div>
<div class="line">            <a name="_a26"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> mayaNormals;</div>
<div class="line">            status = fPolyMesh.getNormals(mayaNormals);</div>
<div class="line">            assert(status == MS::kSuccess);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> mayaNormalIdCounts, mayaNormalIds;</div>
<div class="line">            status = fPolyMesh.getNormalIds(mayaNormalIdCounts, mayaNormalIds);</div>
<div class="line">            assert(status == MS::kSuccess);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Allocate memory for normals</span></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNormals   = mayaNormals.<a name="a27"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNormalIds = mayaNormalIds.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line">            normals.reset(<span class="keyword">new</span> <span class="keywordtype">float</span>[numNormals * 3]);</div>
<div class="line">            normalIndices.reset(<span class="keyword">new</span> index_type[numNormalIds]);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// just copy the normals and normalIds to shared_array</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numNormals; i++) {</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a>&amp; normal = mayaNormals[i];</div>
<div class="line">                normals[i * 3 + 0] = normal.<a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html#ad0da36b2558901e21e7a30f6c227a45e">x</a>;</div>
<div class="line">                normals[i * 3 + 1] = normal.<a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html#aa4f0d3eebc3c443f9be81bf48561a217">y</a>;</div>
<div class="line">                normals[i * 3 + 2] = normal.<a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html#af73583b1e980b0aa03f9884812e9fd4d">z</a>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numNormalIds; i++) {</div>
<div class="line">                normalIndices[i] = mayaNormalIds[i];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// UVs</span></div>
<div class="line">        GPUCache::shared_array&lt;float&gt;      UVs;</div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; uvIndices;</div>
<div class="line">        <span class="keywordflow">if</span> (fWantUVs) {</div>
<div class="line">            <a name="_a28"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> mayaUArray, mayaVArray;</div>
<div class="line">            status = fPolyMesh.getUVs(mayaUArray, mayaVArray);</div>
<div class="line">            assert(status == MS::kSuccess);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> mayaUVCounts, mayaUVIds;</div>
<div class="line">            status = fPolyMesh.getAssignedUVs(mayaUVCounts, mayaUVIds);</div>
<div class="line">            assert(status == MS::kSuccess);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Allocate memory for normals</span></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numUVs   = mayaUArray.<a name="a29"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numUVIds = mayaUVIds.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line">            <span class="keywordflow">if</span> (numUVs &gt; 0 &amp;&amp; numUVIds &gt; 0) {</div>
<div class="line">                UVs.reset(<span class="keyword">new</span> <span class="keywordtype">float</span>[numUVs * 2]);</div>
<div class="line">                uvIndices.reset(<span class="keyword">new</span> index_type[numUVIds]);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// just copy the UVs and uvIds to shared_array</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numUVs; i++) {</div>
<div class="line">                    UVs[i * 2 + 0] = mayaUArray[i];</div>
<div class="line">                    UVs[i * 2 + 1] = mayaVArray[i];</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numUVIds; i++) {</div>
<div class="line">                    uvIndices[i] = mayaUVIds[i];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Convert multi-indexed streams</span></div>
<div class="line">        <span class="keywordtype">size_t</span> numVertices = 0;</div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt;   mappedFaceIndices;</div>
<div class="line">        GPUCache::shared_array&lt;unsigned int&gt; vertAttribsIndices;</div>
<div class="line">        {</div>
<div class="line">            MultiIndexedStreamsConverter&lt;index_type&gt;</div>
<div class="line">                converter(numFaceIndices, faceIndices.get());</div>
<div class="line"></div>
<div class="line">            converter.addMultiIndexedStream(normalIndices.get());</div>
<div class="line">            <span class="keywordflow">if</span> (fWantUVs &amp;&amp; uvIndices) {</div>
<div class="line">                converter.addMultiIndexedStream(uvIndices.get());</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            converter.compute();</div>
<div class="line"></div>
<div class="line">            numVertices        = converter.numVertices();</div>
<div class="line">            mappedFaceIndices  = converter.mappedFaceIndices();</div>
<div class="line">            vertAttribsIndices = converter.vertAttribsIndices();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remap vertex streams</span></div>
<div class="line">        GPUCache::shared_array&lt;float&gt; mappedPositions;</div>
<div class="line">        GPUCache::shared_array&lt;float&gt; mappedNormals;</div>
<div class="line">        GPUCache::shared_array&lt;float&gt; mappedUVs;</div>
<div class="line">        {</div>
<div class="line">            MultiIndexedStreamsRemapper&lt;index_type&gt;</div>
<div class="line">                remapper(faceIndices.get(), numVertices, vertAttribsIndices.get());</div>
<div class="line"></div>
<div class="line">            remapper.addMultiIndexedStream(positions.get(), NULL, <span class="keyword">false</span>, 3);</div>
<div class="line">            remapper.addMultiIndexedStream(normals.get(), normalIndices.get(), <span class="keyword">true</span>, 3);</div>
<div class="line">            <span class="keywordflow">if</span> (fWantUVs &amp;&amp; UVs &amp;&amp; uvIndices) {</div>
<div class="line">                remapper.addMultiIndexedStream(UVs.get(), uvIndices.get(), <span class="keyword">true</span>, 2);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            remapper.compute();</div>
<div class="line"></div>
<div class="line">            mappedPositions = remapper.mappedVertAttribs(0);</div>
<div class="line">            mappedNormals   = remapper.mappedVertAttribs(1);</div>
<div class="line">            <span class="keywordflow">if</span> (fWantUVs &amp;&amp; UVs &amp;&amp; uvIndices) {</div>
<div class="line">                mappedUVs = remapper.mappedVertAttribs(2);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Wireframe indices</span></div>
<div class="line">        <span class="keywordtype">size_t</span> numWires = 0;</div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; wireIndices;</div>
<div class="line">        {</div>
<div class="line">            WireIndicesGenerator&lt;index_type&gt; wireIndicesGenerator(</div>
<div class="line">                numFaceCounts,  faceCounts.get(),</div>
<div class="line">                numFaceIndices, faceIndices.get(),</div>
<div class="line">                mappedFaceIndices.get());</div>
<div class="line"></div>
<div class="line">            wireIndicesGenerator.compute();</div>
<div class="line"></div>
<div class="line">            numWires    = wireIndicesGenerator.numWires();</div>
<div class="line">            wireIndices = wireIndicesGenerator.wireIndices();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Triangle indices</span></div>
<div class="line">        <span class="keywordtype">size_t</span> numTriangles = 0;</div>
<div class="line">        GPUCache::shared_array&lt;index_type&gt; triangleIndices;</div>
<div class="line">        <span class="keywordflow">if</span> (needTriangulate) {</div>
<div class="line">            PolyTriangulator&lt;index_type&gt; polyTriangulator(</div>
<div class="line">                numFaceCounts, faceCounts.get(),</div>
<div class="line">                mappedFaceIndices.get(), <span class="keyword">false</span>,</div>
<div class="line">                mappedPositions.get(), mappedNormals.get());</div>
<div class="line"></div>
<div class="line">            polyTriangulator.compute();</div>
<div class="line"></div>
<div class="line">            numTriangles    = polyTriangulator.numTriangles();</div>
<div class="line">            triangleIndices = polyTriangulator.triangleIndices();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            assert(numFaceIndices % 3 == 0);</div>
<div class="line">            numTriangles    = numFaceIndices / 3;</div>
<div class="line">            triangleIndices = mappedFaceIndices;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// done</span></div>
<div class="line">        fWireIndices     = SharedArray&lt;index_type&gt;::create(</div>
<div class="line">                wireIndices, numWires * 2);</div>
<div class="line">        fTriangleIndices = SharedArray&lt;index_type&gt;::create(</div>
<div class="line">                triangleIndices, numTriangles * 3);</div>
<div class="line"></div>
<div class="line">        fPositions = SharedArray&lt;float&gt;::create(</div>
<div class="line">                mappedPositions, numVertices * 3);</div>
<div class="line">        fNormals   = SharedArray&lt;float&gt;::create(</div>
<div class="line">                mappedNormals, numVertices * 3);</div>
<div class="line">        <span class="keywordflow">if</span> (fWantUVs &amp;&amp; mappedUVs) {</div>
<div class="line">            fUVs = SharedArray&lt;float&gt;::create(</div>
<div class="line">                    mappedUVs, numVertices * 2);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;index_type&gt; &gt;&amp; triangleIndices()</div>
<div class="line">    { <span class="keywordflow">return</span> fTriangleIndices; }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;index_type&gt; &gt;&amp; wireIndices()</div>
<div class="line">    { <span class="keywordflow">return</span> fWireIndices; }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;&amp; positions()</div>
<div class="line">    { <span class="keywordflow">return</span> fPositions; }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;&amp; normals()</div>
<div class="line">    { <span class="keywordflow">return</span> fNormals; }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;&amp; uvs()</div>
<div class="line">    { <span class="keywordflow">return</span> fUVs; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    MayaMeshExtractor(<span class="keyword">const</span> MayaMeshExtractor&amp;);</div>
<div class="line">    <span class="keyword">const</span> MayaMeshExtractor&amp; operator= (<span class="keyword">const</span> MayaMeshExtractor&amp;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Input</span></div>
<div class="line">    <a name="_a30"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_mesh.html">MFnMesh</a> fPolyMesh;</div>
<div class="line">    <span class="keywordtype">bool</span>    fWantUVs;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output</span></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;index_type&gt; &gt; fTriangleIndices;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;index_type&gt; &gt; fWireIndices;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;      fPositions;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;      fNormals;</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt;      fUVs;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// This class is used to update the TransparentPruneType of Xform sub nodes.</span></div>
<div class="line"><span class="comment">// Once a bounding box place holder sub node is loaded, its sample map and </span></div>
<div class="line"><span class="comment">// TransparentPruneType is updated to reflect the real geometry. </span></div>
<div class="line"><span class="comment">// It needs to update all the parent sub nodes&#39; TransparentPruneType.</span></div>
<div class="line"><span class="keyword">class </span>SubNodeTransparentTypeVisitor : <span class="keyword">public</span> SubNodeVisitor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SubNodeTransparentTypeVisitor() {}</div>
<div class="line">    ~SubNodeTransparentTypeVisitor()<span class="keyword"> override </span>{}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp; xform,</div>
<div class="line">                       <span class="keyword">const</span> SubNode&amp;   subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// The transparent type is unknown at first</span></div>
<div class="line">        fTransparentTypes.push_back(SubNode::kUnknown);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Recursive into children</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> SubNode::Ptr&amp; child : subNode.getChildren()) {</div>
<div class="line">            child-&gt;accept(*<span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Update the transparent type of this xform sub node</span></div>
<div class="line">        <span class="keyword">const_cast&lt;</span>SubNode&amp;<span class="keyword">&gt;</span>(subNode).setTransparentType(fTransparentTypes.back());</div>
<div class="line">        fTransparentTypes.pop_back();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> visit(<span class="keyword">const</span> ShapeData&amp; shape,</div>
<div class="line">                       <span class="keyword">const</span> SubNode&amp;   subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Update all parents&#39; transparent type</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; fTransparentTypes.size(); i++) {</div>
<div class="line">            <span class="keywordflow">if</span> (fTransparentTypes[i] == SubNode::kUnknown) {</div>
<div class="line">                <span class="comment">// Parent transparent type is unknown, use this type</span></div>
<div class="line">                fTransparentTypes[i] = subNode.transparentType();</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Parent transparent type is different, use opaque and transparent</span></div>
<div class="line">                <span class="keywordflow">if</span> (fTransparentTypes[i] != subNode.transparentType()) {</div>
<div class="line">                    fTransparentTypes[i] = SubNode::kOpaqueAndTransparent;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;SubNode::TransparentType&gt; fTransparentTypes;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// This class returns the top-level bounding box of a sub-node hierarchy.</span></div>
<div class="line"><span class="keyword">class </span>BoundingBoxVisitor :  <span class="keyword">public</span> SubNodeVisitor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    BoundingBoxVisitor(<span class="keywordtype">double</span> timeInSeconds)</div>
<div class="line">      : fTimeInSeconds(timeInSeconds)</div>
<div class="line">    {}</div>
<div class="line">    ~BoundingBoxVisitor()<span class="keyword"> override </span>{}</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Returns the current bounding box.</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a31"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>&amp; boundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> fBoundingBox; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the bounding box from a xform node.</span></div>
<div class="line">    <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp;   xform,</div>
<div class="line">                       <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keyword">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>
<div class="line">            xform.getSample(fTimeInSeconds);</div>
<div class="line">        <span class="keywordflow">if</span> (sample) {</div>
<div class="line">            fBoundingBox = sample-&gt;boundingBox();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the bounding box from a shape node.</span></div>
<div class="line">    <span class="keywordtype">void</span> visit(<span class="keyword">const</span> ShapeData&amp;   shape,</div>
<div class="line">                       <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">            shape.getSample(fTimeInSeconds);</div>
<div class="line">        <span class="keywordflow">if</span> (sample) {</div>
<div class="line">            fBoundingBox = sample-&gt;boundingBox();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Helper method to get the bounding box in one line.</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> boundingBox(<span class="keyword">const</span> SubNode::Ptr&amp; subNode,</div>
<div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">double</span>        timeInSeconds)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (subNode) {</div>
<div class="line">            BoundingBoxVisitor visitor(timeInSeconds);</div>
<div class="line">            subNode-&gt;accept(visitor);</div>
<div class="line">            <span class="keywordflow">return</span> visitor.boundingBox();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> fTimeInSeconds;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> fBoundingBox;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Extract the shape geometry paths</span></div>
<div class="line"><span class="keyword">class </span>ShapePathVisitor : <span class="keyword">public</span> SubNodeVisitor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> std::pair&lt;MString,const SubNode*&gt; ShapePathAndSubNode;</div>
<div class="line">    <span class="keyword">typedef</span> std::vector&lt;ShapePathAndSubNode&gt;  ShapePathAndSubNodeList;</div>
<div class="line"></div>
<div class="line">    ShapePathVisitor(ShapePathAndSubNodeList&amp; shapePaths)</div>
<div class="line">        : fShapePaths(shapePaths)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~ShapePathVisitor()<span class="keyword"> override </span></div>
<div class="line"><span class="keyword">    </span>{}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp; xform,</div>
<div class="line">                       <span class="keyword">const</span> SubNode&amp;   subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Remember this xform name</span></div>
<div class="line">        <span class="keywordtype">bool</span> isTop = subNode.getName() == <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (!isTop) fCurrentPath.push_back(subNode.getName());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Recursive into children</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> SubNode::Ptr&amp; child : subNode.getChildren()) {</div>
<div class="line">            child-&gt;accept(*<span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!isTop) fCurrentPath.pop_back();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> visit(<span class="keyword">const</span> ShapeData&amp; shape,</div>
<div class="line">                       <span class="keyword">const</span> SubNode&amp;   subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Construct geometry path</span></div>
<div class="line">        <a name="_a32"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> path;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; fCurrentPath.size(); i++) {</div>
<div class="line">            path += <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">            path += fCurrentPath[i];</div>
<div class="line">        }</div>
<div class="line">        path += <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">        path += subNode.getName();</div>
<div class="line"></div>
<div class="line">        fShapePaths.push_back(</div>
<div class="line">            std::make_pair(path, &amp;subNode));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ShapePathAndSubNodeList&amp; fShapePaths;</div>
<div class="line">    std::vector&lt;MString&gt;     fCurrentPath;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> ReplaceSubNodeData(<span class="keyword">const</span> SubNode::Ptr&amp; top, <span class="keyword">const</span> SubNode::Ptr&amp; node, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; path)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Split the geometry path into steps</span></div>
<div class="line">    <a name="_a33"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> steps;</div>
<div class="line">    path.<a name="a34"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(<span class="charliteral">&#39;|&#39;</span>, steps);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Invalid path</span></div>
<div class="line">    <span class="keywordflow">if</span> (steps.<a name="a35"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the first step</span></div>
<div class="line">    SubNode::Ptr firstNode;</div>
<div class="line">    <span class="keywordflow">if</span> (top-&gt;getName() == <span class="stringliteral">&quot;|&quot;</span>) {</div>
<div class="line">        <span class="comment">// Dummy top node case</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> SubNode::Ptr&amp; child : top-&gt;getChildren()) {</div>
<div class="line">            <span class="keywordflow">if</span> (child-&gt;getName() == steps[0]) {</div>
<div class="line">                firstNode = child;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (top-&gt;getName() == steps[0]) {</div>
<div class="line">            firstNode = top;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Can&#39;t find the first sub node</span></div>
<div class="line">    <span class="keywordflow">if</span> (!firstNode) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the sub node by stepping through the path</span></div>
<div class="line">    SubNode::Ptr current = firstNode;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; steps.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++) {</div>
<div class="line">        <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> SubNode::Ptr&amp; child : current-&gt;getChildren()) {</div>
<div class="line">            <span class="keywordflow">if</span> (child-&gt;getName() == steps[i]) {</div>
<div class="line">                current = child;</div>
<div class="line">                found = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Not found</span></div>
<div class="line">        <span class="keywordflow">if</span> (!found) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Found a sub node</span></div>
<div class="line">    assert(current);</div>
<div class="line">    assert(node);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cast to mutable pointer.</span></div>
<div class="line">    <span class="comment">// Currently, this is the only exception that we need to change </span></div>
<div class="line">    <span class="comment">// sub node (actually sub node data) outside reader.</span></div>
<div class="line">    SubNode::MPtr mCurrent = std::const_pointer_cast&lt;SubNode&gt;(current);</div>
<div class="line">    SubNode::MPtr mNode    = std::const_pointer_cast&lt;SubNode&gt;(node);</div>
<div class="line">    SubNode::swapNodeData(mCurrent, mNode);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// This function will validate a geom path given a SubNode hierarchy.</span></div>
<div class="line"><span class="comment">// It will return true if the given geom path was valid, false otherwise.</span></div>
<div class="line"><span class="comment">// Additionally, it will return the closest valid path.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> ValidateGeomPath(<span class="keyword">const</span> SubNode::Ptr&amp; top, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; validatedGeomPath)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>( !top )</div>
<div class="line">    {</div>
<div class="line">        validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// path: |xform1|xform2|meshShape</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> pathArray;</div>
<div class="line">    geomPath.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(<span class="charliteral">&#39;|&#39;</span>, pathArray);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> valid = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">    <span class="comment">// find the mesh in Alembic archive</span></div>
<div class="line">    validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// When there are more than 2 top-level nodes, we have a dummy node (&quot;|&quot;).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isTop = top-&gt;getParents().empty() &amp;&amp; top-&gt;getName() == <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!isTop &amp;&amp; pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Match the 1st step if the top dummy node is missing.</span></div>
<div class="line">        <span class="keywordflow">if</span> (top-&gt;getName() == pathArray[0])</div>
<div class="line">        {</div>
<div class="line">            validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>) + pathArray[0];</div>
<div class="line">            pathArray.<a name="a36"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#af05b9926a5e8e7b8e7a9e98a13c839b6">remove</a>(0); <span class="comment">// eat</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    SubNode::Ptr current = top;</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++ )</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> step = pathArray[i];</div>
<div class="line">        <span class="keywordtype">bool</span> foundChild = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;SubNode::Ptr&gt;&amp; children = current-&gt;getChildren();</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; children.size(); j++ )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>( children[j]-&gt;getName() == step )</div>
<div class="line">            {</div>
<div class="line">                current = children[j];</div>
<div class="line">                foundChild = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span>( !foundChild )</div>
<div class="line">        {</div>
<div class="line">            valid = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        validatedGeomPath += <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">        validatedGeomPath += step;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (validatedGeomPath.<a name="a37"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0) {</div>
<div class="line">        validatedGeomPath = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> valid;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// This function will return a SubNode hierarchy given an existing SubNode hierarchy and</span></div>
<div class="line"><span class="comment">// geom path. The geom path will be validated and this function will return both the</span></div>
<div class="line"><span class="comment">// closest valid path and the associated SubNode hierarchy.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This function will return true if a valid SubNode hierarchy was returned, false otherwise.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> CreateSubNodeHierarchy(<span class="keyword">const</span> SubNode::Ptr&amp; top, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; geomPath, <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; validatedGeomPath, SubNode::Ptr&amp; out)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>( !top )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Validate the geomPath</span></div>
<div class="line">    ValidateGeomPath( top, geomPath, validatedGeomPath );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// path: |xform1|xform2|meshShape</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> pathArray;</div>
<div class="line">    validatedGeomPath.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(<span class="charliteral">&#39;|&#39;</span>, pathArray);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// When there are more than 2 top-level nodes, we have a dummy node (&quot;|&quot;).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isTop = top-&gt;getParents().empty() &amp;&amp; top-&gt;getName() == <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!isTop &amp;&amp; pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#af05b9926a5e8e7b8e7a9e98a13c839b6">remove</a>(0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0 )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Early exit, geomPath is either empty or &quot;|&quot;.</span></div>
<div class="line">        out = top;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We have a geom path to consider. Generate a new SubNode hierarchy.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// In this case, we must duplicate SubNodes since up until the last step along</span></div>
<div class="line">        <span class="comment">// the geomPath, the children will differ.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// For example, let&#39;s say we have the following scene hierarchy:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// |group1|pSphere1|pSphereShape1</span></div>
<div class="line">        <span class="comment">// |group1|pCube1|pCubeShape1</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// The geomPath is:  |group1|pCube1</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// We cannot simply reference the same SubNode::Ptr for |group1, as that</span></div>
<div class="line">        <span class="comment">// SubNode contains child SubNodes for pSphere1 and pCube1. Thus, we need</span></div>
<div class="line">        <span class="comment">// to duplicate the SubNode and only reference the children of interest.</span></div>
<div class="line">        <span class="comment">// </span></div>
<div class="line">        <span class="comment">// We only need to duplicate the SubNode hierarchy up until the last path step.</span></div>
<div class="line">        <span class="comment">// For the last path step we can simply reference the same SubNode::Ptr since</span></div>
<div class="line">        <span class="comment">// we know that we want the same hierarchy under that node.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        SubNode::MPtr copyTop = SubNode::create( top-&gt;getName(), top-&gt;getData() );</div>
<div class="line">        copyTop-&gt;setTransparentType( top-&gt;transparentType() );</div>
<div class="line">        SubNode::MPtr copyCurrent = copyTop;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Walk the hierarchy and copy data.</span></div>
<div class="line">        SubNode::Ptr current = top;</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++ )</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> step = pathArray[i];</div>
<div class="line"></div>
<div class="line">            <span class="keyword">const</span> std::vector&lt;SubNode::Ptr&gt;&amp; children = current-&gt;getChildren();</div>
<div class="line">            <span class="keywordtype">bool</span> foundChild = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; children.size(); j++ )</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span>( children[j]-&gt;getName() == step )</div>
<div class="line">                {</div>
<div class="line">                    current = children[j];</div>
<div class="line">                    foundChild = <span class="keyword">true</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            assert(foundChild);</div>
<div class="line"></div>
<div class="line">            SubNode::MPtr copyChild;</div>
<div class="line">            <span class="keywordflow">if</span>( i+1 &lt; pathArray.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() )</div>
<div class="line">            {</div>
<div class="line">                copyChild = SubNode::create( current-&gt;getName(), current-&gt;getData() );</div>
<div class="line">                copyChild-&gt;setTransparentType( current-&gt;transparentType() );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// For the last path step, we can reuse the same SubNode::Ptr - no need to copy.</span></div>
<div class="line">                copyChild = std::const_pointer_cast&lt;SubNode&gt;(current);</div>
<div class="line">            }</div>
<div class="line">            SubNode::connect(copyCurrent, copyChild);</div>
<div class="line">            copyCurrent = copyChild;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        out = copyTop;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*==============================================================================</span></div>
<div class="line"><span class="comment"> * CLASS InstanceMaterialLookup</span></div>
<div class="line"><span class="comment"> *============================================================================*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Find the connect shading groups and surface materials by tracking connections.</span></div>
<div class="line"><span class="keyword">class </span>InstanceMaterialLookup</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    InstanceMaterialLookup(<span class="keyword">const</span> <a name="_a38"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a>&amp; dagPath);</div>
<div class="line">    ~InstanceMaterialLookup();</div>
<div class="line">    InstanceMaterialLookup(<span class="keyword">const</span> InstanceMaterialLookup&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    InstanceMaterialLookup&amp; operator=(<span class="keyword">const</span> InstanceMaterialLookup&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Whole object material assignment.</span></div>
<div class="line">    <span class="keywordtype">bool</span>    hasWholeObjectMaterial();</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> findWholeObjectShadingGroup();</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> findWholeObjectSurfaceMaterial();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Per-face or Per-patch material assignment.</span></div>
<div class="line">    <span class="keywordtype">bool</span> hasComponentMaterials();</div>
<div class="line">    <span class="keywordtype">bool</span> findShadingGroups(std::vector&lt;MObject&gt;&amp; shadingGroups);</div>
<div class="line">    <span class="keywordtype">bool</span> findSurfaceMaterials(std::vector&lt;MObject&gt;&amp; surfaceMaterials);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Find instObjGroups[instanceNumber] plug.</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> findInstObjGroupsPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a>&amp; dagPath);</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> findShadingGroupByPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; srcPlug);</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> findSurfaceMaterialByShadingGroup(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; shadingGroup);</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> findObjectGroupsPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; iogPlug, std::vector&lt;MPlug&gt;&amp; ogPlugs);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> fInstObjGroupsPlug;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*==============================================================================</span></div>
<div class="line"><span class="comment"> * CLASS ShadedModeColor</span></div>
<div class="line"><span class="comment"> *============================================================================*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class evaluates the material property values of a material node.</span></div>
<div class="line"><span class="comment">// The value is expected to be the same as viewport&#39;s shaded mode.</span></div>
<div class="line"><span class="keyword">class </span>ShadedModeColor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> evaluateBool(<span class="keyword">const</span> MaterialProperty::Ptr&amp; prop,</div>
<div class="line">                             <span class="keywordtype">double</span>                       timeInSeconds);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> evaluateFloat(<span class="keyword">const</span> MaterialProperty::Ptr&amp; prop,</div>
<div class="line">                               <span class="keywordtype">double</span>                       timeInSeconds);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <a name="_a39"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> evaluateDefaultColor(<span class="keyword">const</span> MaterialProperty::Ptr&amp; prop,</div>
<div class="line">                                       <span class="keywordtype">double</span>                       timeInSeconds);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> evaluateColor(<span class="keyword">const</span> MaterialProperty::Ptr&amp; prop,</div>
<div class="line">                                <span class="keywordtype">double</span>                       timeInSeconds);</div>
<div class="line">    ShadedModeColor(<span class="keyword">const</span> ShadedModeColor&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    ShadedModeColor&amp; operator=(<span class="keyword">const</span> ShadedModeColor&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> EncodeString(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> encodedMsg;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   length = msg.<a name="a40"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a9f0f85031c628ef5111739fe8573003b">numChars</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* buffer = msg.<a name="a41"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#ade6a9ba4bd9b9d2d0ae95b05a7f75522">asWChar</a>();</div>
<div class="line"></div>
<div class="line">    std::wstringstream stream;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; length; i++) {</div>
<div class="line">        <span class="keywordtype">wchar_t</span> ch = buffer[i];</div>
<div class="line">        <span class="keywordflow">switch</span> (ch) {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\n&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\n&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\t&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\t&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\b&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\b&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\r&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\r&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\f&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\f&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\v&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\v&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\a&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\a&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\\&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\\\&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\&quot;&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\\&quot;&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\&#39;&#39;</span>: stream &lt;&lt; L<span class="stringliteral">&quot;\\\&#39;&quot;</span>; <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        stream &lt;&lt; ch;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::wstring str = stream.str();</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(str.c_str());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> DisplayError(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This is the threadsafe version of MGlobal::displayError()</span></div>
<div class="line">    <a name="a42"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#a2c877a6e116f8fd3a6e76387403c023a">MGlobal::executeCommandOnIdle</a>(<span class="stringliteral">&quot;error \&quot;&quot;</span> + EncodeString(msg) + <span class="stringliteral">&quot;\&quot;&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> DisplayError(<span class="keyword">const</span> <a name="_a43"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_resource_id.html">MStringResourceId</a>&amp; <span class="keywordtype">id</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Threadsafe displayError() bundled with MStringResourceId</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> msg = <a name="a44"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_resource.html#a121315f443a9c4ea512738dc1d39414d">MStringResource::getString</a>(<span class="keywordtype">id</span>, stat);</div>
<div class="line">    DisplayError(msg);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> DisplayError(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string_resource_id.html">MStringResourceId</a>&amp; <span class="keywordtype">id</span>,</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg1,</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg2 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg3 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg4 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg5 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg6 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg7 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg8 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg9 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Threadsafe displayError() bundled with MStringResourceId and format</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> format = <a class="code" href="#!/url=./cpp_ref/class_m_string_resource.html#a121315f443a9c4ea512738dc1d39414d">MStringResource::getString</a>(<span class="keywordtype">id</span>, stat);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> msg;</div>
<div class="line">    msg.<a name="a45"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a07ae464181c795f43fa1bcc288acff91">format</a>(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);</div>
<div class="line">    DisplayError(msg);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> DisplayWarning(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This is the threadsafe version of MGlobal::displayWarning()</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_global.html#a2c877a6e116f8fd3a6e76387403c023a">MGlobal::executeCommandOnIdle</a>(<span class="stringliteral">&quot;warning \&quot;&quot;</span> + EncodeString(msg) + <span class="stringliteral">&quot;\&quot;&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> DisplayWarning(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string_resource_id.html">MStringResourceId</a>&amp; <span class="keywordtype">id</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Threadsafe displayWarning() bundled with MStringResourceId</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> msg = <a class="code" href="#!/url=./cpp_ref/class_m_string_resource.html#a121315f443a9c4ea512738dc1d39414d">MStringResource::getString</a>(<span class="keywordtype">id</span>, stat);</div>
<div class="line">    DisplayWarning(msg);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> DisplayWarning(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string_resource_id.html">MStringResourceId</a>&amp; <span class="keywordtype">id</span>,</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg1,</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg2 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg3 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg4 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg5 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg6 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg7 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg8 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; arg9 = <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;&quot;</span>))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Threadsafe displayWarning() bundled with MStringResourceId and format</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> format = <a class="code" href="#!/url=./cpp_ref/class_m_string_resource.html#a121315f443a9c4ea512738dc1d39414d">MStringResource::getString</a>(<span class="keywordtype">id</span>, stat);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> msg;</div>
<div class="line">    msg.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#a07ae464181c795f43fa1bcc288acff91">format</a>(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);</div>
<div class="line">    DisplayWarning(msg);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace GPUCache</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
