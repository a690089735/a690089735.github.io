<!DOCTYPE html><html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta name="product" content="3DSMAX">
      <meta name="release" content="2023">
      <meta name="book" content="GeneralUser">
      <meta name="created" content="2022-03-27">
      <meta name="topicid" content="GUID-CE92A47E-645D-45BE-B804-E4A4AE7704E5">
      <meta name="description" content="此主题介绍容器的典型应用场合。">
      <meta name="topic-type" content="concept">
      <title>容器工作流程</title><script language="javascript">var index = 'index3dsmaxhelp.html';</script></head>
   <body height="100%">
      <div class="body_content" id="body-content" dir="ltr"><a name="GUID-CE92A47E-645D-45BE-B804-E4A4AE7704E5"></a><div class="head">
            <h1>容器工作流程</h1>
         </div>
         <p class="blurb">此主题介绍容器的典型应用场合。 
            
         </p>
         <div class="section"><a name="WS73099CC142F487557F3ACA8D11D5F2B5BAB-7C69"></a> 
            <h2><a name="GUID-15A021CE-CFA0-4E47-8D08-FC320F312499"></a>使用容器复制和更新场景内容（本地引用）
            </h2> 
            <p><a name="WS73099CC142F487557F3ACA8D11D5F2B5BAB-7C68"></a>工作流：将对象组合到一个容器中，将它们作为单个实体进行转换，制作副本，更新副本，然后解组容器以进行单独开发。 
               		
            </p> <a name="WS1A9193826455F5FF44C205DF11D7D1722DF-4965"></a><ol type="1" start="1">
               <li> 
                  			 在场景中<span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS73099CC142F487557CB2BAEA11CFFB8ADB7-72DE">创建容器</a></span>。 
                  			 
                  <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-4477"></a>容器显示为打开状态。打开的容器完全可编辑。 
                     			 
                  </p> 
               </li>
               <li> 
                  			 向容器中<span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS1A9193826455F5FF453265C9125FAA23BBB57D4">添加场景对象</a></span>。 
                  			 
                  <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-4475"></a>所添加的对象作为容器的子级链接到容器。 
                     			 
                  </p> <a name="WS73099CC142F4875546792D6511E39D9727737CC"></a><div class="figure-anchor"><img src="../images/GUID-801E3397-0062-419E-B2DB-AD9E816287FF-low.png"><p></p>
                     <p class="figure-title">添加到一个容器中的两个单元住宅模型</p>
                  </div>  
               </li>
               <li>转换容器。 
                  			 
                  <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-4472"></a>对容器所做的任何更改会同时影响其内容。 
                     			 
                  </p> <a name="FIG_1D350A2510F94DEB99F9466B277FA928"></a><div class="figure-anchor"><img src="../images/GUID-8E664493-381B-4190-B091-2E92C28F8523-low.png"><p></p>
                     <p class="figure-title">容器的内容在场景中重新定位</p>
                  </div>  
               </li>
               <li>在“管理容器”卷展栏上，启用“关闭时自动更新”，然后<span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS1A9193826455F5FF6ABE274011CFFBAA2B2-6E4E">关闭容器</a></span>，并将其保存为 <em class="strong">Block_A.maxc</em>。 
                  			 
                  <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-4470"></a>虽然容器内容在视口中仍可见，但实际上它们已从场景中移除（例如，尝试选择内容实际会选择容器）。现在，场景将从其保存位置引用 <em class="mild">Block_A.maxc</em> 文件。 
                     			 
                  </p> 
               </li>
               <li>制作容器的两个副本，然后将每个副本重新定位到场景中所需的位置。 
                  			 
                  <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-446F"></a>所有容器引用同一个 Block_A.maxc 文件。<em class="mild"></em> 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B43"></a><div class="figure-anchor"><img src="../images/GUID-2633AC05-CD5B-4384-927D-72C9E56CA2D1-low.png"><p></p>
                     <p class="figure-title">原始 Block_A 容器（最左侧）及其两个副本（中间和右侧）</p>
                  </div>  
               </li>
               <li>打开其中一个容器，然后尝试打开另一个容器。 
                  			 
                  <p><a name="WS1A9193826455F5FF453265C9125FAA23BBB57D2"></a>系统会显示一条消息，通知您，当在另一个容器中编辑该容器的定义时，无法打开该容器。这有助于防止意外覆盖已更改的容器。 
                     			 
                  </p> 
               </li>
               <li>在场景中创建新对象，将其添加至打开的容器，然后单击“保存”。 
                  			 
                  <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-446A"></a>因为其他容器引用相同的 MAXC 文件，所以它们也会得到更新。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B9540BA"></a><div class="figure-anchor"><img src="../images/GUID-FBDFEF48-C85C-4AD8-9A0C-C22C64896DC8-low.png"><p></p>
                     <p class="figure-title">所有容器都会收到添加的对象</p>
                  </div>  
               </li>
               <li>选择打开的容器副本，使用“本地内容”卷展栏上的“另存为”以另一个名称 Block_B.maxc 保存它。<em class="strong"></em> 
                  <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-4467"></a>Block_B 容器现已解组，可以转入自己的开发流程。对它所做的任何进一步更改都不会应用于副本。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B42"></a><div class="figure-anchor"><img src="../images/GUID-49F3D530-66F0-486F-B6FB-79293E0A1502-low.png"><p></p>
                     <p class="figure-title">Block_B 容器（最右侧）已解组。它不受 Block_A 容器（左侧和中间）更新的影响。</p>
                  </div>  
               </li>
            </ol> 
         </div>
         <div class="section"><a name="WS73099CC142F487557F3ACA8D11D5F2B5BAB-7C6B"></a> 
            <h2><a name="GUID-F2A491CE-BD27-43CA-9F8D-6378142C2FDA"></a>使用容器共享和编辑外部创建的内容（原地编辑）
            </h2> 
            <p><a name="WS73099CC142F487557F3ACA8D11D5F2B5BAB-7C6A"></a>工作流：从其他人继承内容，将更改传递回原始创建者，并从所引用的容器解组以进行本地开发。 
               		
            </p> <a name="WS1A9193826455F5FF44C205DF11D7D1722DF-495A"></a><ol type="1" start="1">
               <li>用户 B 转到<span class="char_link"><a href="GUID-2E00A854-AB09-4DA7-B624-FB52478C0669.htm">“容器浏览器”</a></span>，单击<span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS1A9193826455F5FF-4855151011E3B702B9540BC">“继承容器”</a></span>，使用“继承容器”对话框打开上一过程中的 <em class="mild">Block_A.maxc</em> 文件。 
                  			 
                  <p><a name="WS73099CC142F487557230B50811D7D192C64-6CC2"></a>该容器显示在从用户 A 的场景中保存它时它所在的位置。在此时，用户 B 可以使用该容器，但不能访问其内容。 
                     			 
                  </p> <a name="FIG_3663B779CADF4D9F9C6C5D9113D8BE46"></a><div class="figure-anchor"><img src="../images/GUID-D4222A40-DF1F-40DC-9D29-406203F3256D-low.png"><p></p>
                     <p class="figure-title">用户 B（右侧）继承了用户 A（左侧）的容器</p>
                  </div>  
               </li>
               <li>用户 A 对该容器中的建筑物进行更改，并启用“关闭时自动更新”。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B40"></a><div class="figure-anchor"><img src="../images/GUID-5D423445-D2AE-4669-B261-572EA6033811-low.png"><p></p>
                     <p class="figure-title">关闭容器前对用户 A 的建筑物（左侧）所做的更改</p>
                  </div>  
               </li>
               <li>用户 A <span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS1A9193826455F5FF6ABE274011CFFBAA2B2-6E4E">关闭该容器</a></span>。用户 B 启用“关闭时自动更新”，然后自动继承最新更改。 
                  			 
                  <p><a name="WS73099CC142F487557109353211EEADCAF73-58D7"></a>容器在关闭时自动保存。只要保存该容器并且对所继承的容器启用“关闭时自动更新”，那么用户 B 就可以继承对内容所做的更改，无论用户 A 是否将其关闭。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B3F"></a><div class="figure-anchor"><img src="../images/GUID-B3F72F96-90F0-49C7-987D-6BB5BF160F8B-low.png"><p></p>
                     <p class="figure-title">从用户 A 继承更改后用户 B 的容器（右侧）</p>
                  </div>  
               </li>
               <li>用户 A 现在已使其他用户可编辑其容器。在<span class="char_link"><a href="GUID-26719F6A-B253-4134-84FB-A660B6D57417.htm#WS73099CC142F48755-1257E12111BF108800E1815">“规则”卷展栏</a></span>上，他设置了“继承时”、“允许”<img class="adsk-glyph-arrow" src="../images/ac.menuaro.gif">“仅原地编辑”，然后关闭该容器。 
                  			 
                  <p><a name="WS73099CC142F48755-751DE9951262947C01C-61D9"></a>用户 B 的容器的“更新”按钮旁的警告图标通知他需要进行更新。自动更新应用于更改的内容，但不应用于容器自身的已更改设置。 
                     			 
                  </p> 
               </li>
               <li>用户 B 转到“管理容器”卷展栏并单击“更新”。 
                  			 
                  <p><a name="WS73099CC142F48755-751DE9951262947C01C-61D8"></a>“原地编辑”按钮变为可用，因此用户 B 单击该按钮。 
                     			 
                  </p> 
                  <div><a name="WS73099CC142F48755-191A86AC126720FA354-5522"></a><div class="note-note"><span class="label label-target-language">注意:</span>为了让用户 B 编辑该容器，用户 A 必须关闭该容器。“原地编辑”容器一次只能供一个用户使用。 
                        			 
                     </div>
                  </div> 
               </li>
               <li>用户 B 进行编辑，并再次单击“原地编辑”以退出“原地编辑”模式。 
                  			 
                  <p><a name="WS73099CC142F487557230B50811D7D192C64-6CBC"></a>该容器关闭并且用户 A 的源定义被覆盖。下次作者（或参考该容器的任何其他人）加载该容器时，都会看到用户 B 所做的更改。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B3E"></a><div class="figure-anchor"><img src="../images/GUID-131810DD-DAFB-4E45-9BE9-AA259B5D0FCE-low.png"><p></p>
                     <p class="figure-title">用户 A 继承用户 B 所做的更改</p>
                  </div>  
                  <div><a name="WS73099CC142F487557230B50811D7D192C64-6CBA"></a><div class="note-note"><span class="label label-target-language">注意:</span>使用“原地编辑”时，容器功能会提供自动锁定功能，以防止编辑同一容器的人彼此覆盖所做的更改。 
                        			 
                     </div>
                  </div> 
               </li>
               <li>用户 B 需要制作该容器的副本并将副本用于其他项目。 
                  			 
                  <p><a name="WS73099CC142F487557230B50811D7D192C64-6CB9"></a>在“继承的内容”卷展栏上，她单击<span class="char_link"><a href="GUID-26719F6A-B253-4134-84FB-A660B6D57417.htm#WS73099CC142F487557579AB9211CD73FDB9E5789">合并源定义</a></span>。内容现在为本地内容，并且就像在当前场景中从头开始创建的而不是从外部来源继承的。该容器现在已解组；访问不受任何规则限制。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B3D"></a><div class="figure-anchor"><img src="../images/GUID-7735D0C3-4C17-46AA-BE04-DF81D001776E-low.png"><p></p>
                     <p class="figure-title">所复制的容器（右侧）已解组并且用于其他项目</p>
                  </div>  
               </li>
            </ol> 
         </div>
         <div class="section"><a name="WS73099CC142F487557F3ACA8D11D5F2B5BAB-7C6D"></a> 
            <h2><a name="GUID-5CEBEB13-F3CF-43A1-BB1F-34201FAD9894"></a>使用容器操纵内容和设置复杂场景中的可见性
            </h2> 
            <p><a name="WS73099CC142F487557F3ACA8D11D5F2B5BAB-7C6C"></a>工作流：关闭容器，卸载容器以从场景中移除其内容，将容器辅助对象移至场景中的其他区域，并重新加载容器以便在新位置显示其内容。 
               		
            </p> <a name="WS1A9193826455F5FF44C205DF11D7D1722DF-4943"></a><ol type="1" start="1">
               <li>在一个场景中创建三个容器，关闭这些容器，并使用具有唯一性的名称保存每个容器。 
                  			 
                  <p><a name="WS73099CC142F487551DC3623711DA7B58889-7EF3"></a>这些容器已保存到磁盘中，虽然其内容在视口中仍然可见，但实际已从场景中移除。场景性能得到提高：自动保存时间以及保存和重新加载场景文件所需的时间现已减少。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B3C"></a><div class="figure-anchor"><img src="../images/GUID-34A769C6-E20F-4B39-8D45-498CE63D9C25-low.png"><p></p>
                     <p class="figure-title">具有三个已保存本地容器的城市场景</p>
                  </div>  
               </li>
               <li>单击“卸载”临时移除所选容器的内容。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B3B"></a><div class="figure-anchor"><img src="../images/GUID-901DA3F4-17C1-43A2-A604-8A97F24D5E3A-low.png"><p></p>
                     <p class="figure-title">已卸载其在一个容器的城市场景 </p>
                  </div>  
               </li>
               <li>将所卸载的容器辅助对象移至新位置，然后单击“加载”。 
                  			 
                  <p><a name="WS73099CC142F487551DC3623711DA7B58889-7EF0"></a>该容器的内容在新位置重新显示。 
                     			 
                  </p> <a name="WS1A9193826455F5FF11D4ED1B128F2317A08139A"></a><div class="figure-anchor"><img src="../images/GUID-52024097-73B6-4306-9152-F499C1E77DCB-low.png"><p></p>
                     <p class="figure-title">沿街道移动的容器</p>
                  </div>  <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B3A"></a><div class="figure-anchor"><img src="../images/GUID-CCAF5B60-178B-47CE-A763-B0ECAF2CCBA9-low.png"><p></p>
                     <p class="figure-title">重新加载的容器内容</p>
                  </div>  
                  <p><a name="WS73099CC142F487551DC3623711DA7B58889-7EEE"></a>利用这种方式可以在复杂或数据量大的场景中快速切入和切出内容。 
                     			 
                  </p> 
               </li>
            </ol> 
         </div>
         <div class="section"><a name="WS73099CC142F487551DC3623711DA7B58889-7EED"></a> 
            <h2><a name="GUID-98743E6F-34C1-40D2-A2EC-7905546B8CEB"></a>使用容器控制内容的可编辑性（管理“合并”和“使唯一”）
            </h2> 
            <p><a name="WS73099CC142F487551DC3623711DA7B58889-7EEC"></a>工作流：创建一个容器并将另一个容器放在该容器中，允许对主容器进行编辑，然后继承嵌套的容器以防止其他人进行编辑。 
               		
            </p> <a name="WS73099CC142F487551DC3623711DA7B58889-7EEB"></a><ol type="1" start="1">
               <li>用户 A <span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS73099CC142F487557CB2BAEA11CFFB8ADB7-72DE">创建容器</a></span>并向其<span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS1A9193826455F5FF453265C9125FAA23BBB57D4">添加内容</a></span>，内容来自城市块。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B39"></a><div class="figure-anchor"><img src="../images/GUID-AA760BE9-2913-4B5D-9A23-BD37ED3C4AC9-low.png"><p></p>
                     <p class="figure-title">其中添加城市块的对象的容器（右侧）</p>
                  </div>  
               </li>
               <li>用户 A 创建另一个容器，向其添加摩天大楼，<span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS1A9193826455F5FF453265C9125FAA23BBB57D6">保存容器</a></span>，并将其添加到第一个容器中。 
                  			 
                  <p><a name="WS73099CC142F487551DC3623711DA7B58889-7EE8"></a>用户 A 现在拥有一个父容器，内部嵌套了另一个容器。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B38"></a><div class="figure-anchor"><img src="../images/GUID-23C40681-18F3-472C-9545-4F32C9B1ED38-low.png"><p></p>
                     <p class="figure-title">内部嵌套了摩天大楼容器（左侧）的主容器（右侧）</p>
                  </div>  
               </li>
               <li>用户 A 选择父容器。接下来，在<span class="char_link"><a href="GUID-26719F6A-B253-4134-84FB-A660B6D57417.htm#WS73099CC142F48755-1257E12111BF108800E1815">“规则”卷展栏上</a></span>选择“仅原地编辑”，然后保存容器。 
                  		  
               </li>
               <li>用户 A 想要防止其他人编辑摩天大楼容器，因此他选择摩天大楼容器，使用“继承内容”并拾取源定义，然后再次保存主容器。 
                  			 
                  <p><a name="WS73099CC142F48755-191A86AC126B843A87B-5D94"></a>现在，摩天大楼容器继承到了主容器中，且对其内容的访问被阻止。 
                     			 
                  </p> 
               </li>
               <li>用户 B 在其场景中继承主容器，然后单击<span class="char_link"><a href="GUID-26719F6A-B253-4134-84FB-A660B6D57417.htm#WS73099CC142F487557579AB9211CD73FDB9E5789">合并源定义</a></span>。这会将容器置于与作者场景中同样的状态下：打开的容器可编辑，但关闭的嵌套容器被引用，因此不可编辑。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B37"></a><div class="figure-anchor"><img src="../images/GUID-0A8E5404-1E19-4B76-B641-554F11FB3926-low.png"><p></p>
                     <p class="figure-title">用户 B（底部）从用户 A（顶部）继承容器</p>
                  </div>  
               </li>
               <li>用户 B 还需要访问不可编辑的容器，因此单击<span class="char_link"><a href="GUID-26719F6A-B253-4134-84FB-A660B6D57417.htm#WS73099CC142F487557579AB9211C98C460A4-7387">使所有内容唯一</a></span>。 
                  			 
                  <p><a name="WS1A9193826455F5FF-4855151011E3B702B95-3B36"></a>这会打开先前不可编辑的容器，但该容器不再引用作者的<span class="char_link"><a href="GUID-A0F9AA1A-2034-4908-BE07-0ADD532C739E.htm">源容器</a></span>。用户 B 现在可以为自己的场景本地修改容器内容。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B35"></a><div class="figure-anchor"><img src="../images/GUID-E4B3662E-D5A2-4588-A396-FBD21B5AF474-low.png"><p></p>
                     <p class="figure-title">用户 B 可在本地基于用户 A 的工作继续工作 </p>
                  </div>  
               </li>
            </ol> 
         </div>
         <div class="section"><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-493F"></a> 
            <h2><a name="GUID-6F162661-BED0-4DD3-BF1E-6A13F473E9FC"></a>使用容器控制场景中对象的显示
            </h2> 
            <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-493D"></a>工作流：设置容器显示，以便您可以处理特定容器并隐藏其余场景内容。更改显示设置而不永久更改场景的显示组织。 
               		
            </p> <a name="WS1A9193826455F5FF44C205DF11D7D1722DF-493C"></a><ol type="1" start="1">
               <li>对于场景中的每个容器，启用“显示”卷展栏 <img class="adsk-glyph-arrow" src="../images/ac.menuaro.gif">“扩展边界框”。 
                  			 
                  <p><a name="WS73099CC142F487557230B50811D7D192C64-6CB0"></a>这样更易于识别各对象所属的容器。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B34"></a><div class="figure-anchor"><img src="../images/GUID-879FE038-8447-479E-941B-8AD8C2147B49-low.png"><p></p>
                     <p class="figure-title">三个容器及其边界框，显示其内容的范围</p>
                  </div>  
               </li>
               <li>打开<span class="char_link"><a href="GUID-DD5876EA-F333-4185-AF51-EDE339B1EBF3.htm">“管理层”对话框</a></span>，使用它来设置对象的显示属性，以便仅可查看和处理某些类型的对象。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B32"></a><div class="figure-anchor"><img src="../images/GUID-0406811B-C8EF-41E3-B889-79B45861D09E-low.png"><p></p>
                     <p class="figure-title">一层灯对象可见的场景</p>
                  </div>  
               </li>
               <li>右键单击容器并将其“对象属性”设置为“按层”。 
                  		  
               </li>
               <li>在容器仍处于选定状态时，启用“覆盖对象属性”。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B31"></a><div class="figure-anchor"><img src="../images/GUID-88D37691-800B-467C-90FF-BF8E95DA3A8E-low.png"><p></p>
                     <p class="figure-title">最左侧容器的显示属性将覆盖其他隐藏对象层</p>
                  </div>  
               </li>
               <li>为所有容器启用“覆盖对象属性”。 
                  			 
                  <p><a name="WS73099CC142F487557109353211EEADCAF73-58D6"></a>可以从“容器资源管理器”或“工具”<img class="adsk-glyph-arrow" src="../images/ac.menuaro.gif">“容器”子菜单轻松覆盖选定容器的对象属性。 
                     			 
                  </p> 
               </li>
               <li>右键单击容器，选择“对象属性”，然后将“显示属性”设置为“按对象”和“透明”。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B2F"></a><div class="figure-anchor"><img src="../images/GUID-5AEDCD22-BC45-4CB9-AF2D-A5AE7A584A5A-low.png"><p></p>
                     <p class="figure-title">保留容器对象的显示属性设置为“透明”，以便查看容器后面的对象</p>
                  </div>  
               </li>
               <li>在<span class="char_link"><a href="GUID-DD5876EA-F333-4185-AF51-EDE339B1EBF3.htm">“管理层”对话框</a></span>中，单击“渲染”以禁用左右两侧容器的渲染性，以便可以快速渲染场景中的特定部分。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B2E"></a><div class="figure-anchor"><img src="../images/GUID-DFAD557B-E9DF-4CF9-8A95-3650ECE8F798-low.png"><p></p>
                     <p class="figure-title">左右两侧容器的渲染性被禁用</p>
                  </div>  
                  <p><a name="WS73099CC142F487557109353211EEADCAF73-58D5"></a>场景的可渲染内容不是由单个对象或层的设置决定的，而是由容器决定的。 
                     			 
                  </p> 
               </li>
            </ol> 
         </div>
         <div class="section"><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-492E"></a> 
            <h2><a name="GUID-DA4AD419-B201-46CD-8F2D-ABDBD11A208B"></a>平行引用
            </h2> 
            <p><a name="WS1A9193826455F5FF44C205DF11D7D1722DF-492D"></a>工作流：用户 A 从用户 B 继承容器，用户 B 从用户 A 继承容器，每个用户均单击“更新”以保持与对方的工作同步。两个用户在各自的容器上单击“允许原地编辑”以允许外部用户进行更改。 
               		
            </p> <a name="WS1A9193826455F5FF44C205DF11D7D1722DF-492B"></a><ol type="1" start="1">
               <li>用户 A 在一个容器中对一组建筑物建模。用户 B 在另一个容器中处理车辆动画。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B2D"></a><div class="figure-anchor"><img src="../images/GUID-64621CD3-EC40-47A4-8F48-8F44FD9A71B8-low.png"><p></p>
                     <p class="figure-title">用户 A 的场景（顶部）和用户 B 的场景（底部）</p>
                  </div>  
               </li>
               <li>两个用户<span class="char_link"><a href="GUID-3B83E236-5D1D-42D5-AD30-C27DE8AA15E4.htm#WS1A9193826455F5FF-4855151011E3B702B9540BC">继承</a></span>彼此的容器。 
                  			 
                  <p><a name="WS73099CC142F487551DC3623711DA7B58889-7EE1"></a>现在，用户 A 和 B 可以并行工作。他们开发自己的场景中的组件，同时可以查看同事的工作进展。 
                     			 
                  </p> <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B2C"></a><div class="figure-anchor"><img src="../images/GUID-D7B012F8-8017-4E6A-8CC3-5A439D95443E-low.png"><p></p>
                     <p class="figure-title">用户 A（顶部）和用户 B（底部）继承彼此的场景组件</p>
                  </div>  
               </li>
               <li>用户 A 选择他的<span class="char_link"><a href="GUID-135940AC-E855-4454-AD6D-6BACBB8185E0.htm">本地容器</a></span>，在<span class="char_link"><a href="GUID-26719F6A-B253-4134-84FB-A660B6D57417.htm#WS73099CC142F48755-1257E12111BF108800E1815">“规则”卷展栏上</a></span>设置了“继承时”、“允许”<img class="adsk-glyph-arrow" src="../images/ac.menuaro.gif">“仅原地编辑”，然后保存容器。 
                  		  
               </li>
               <li>用户 B 选定从用户 A 继承的容器并单击“更新”。然后，她向用户 A 的容器添加关键点以同步动画车辆的运动。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B2B"></a><div class="figure-anchor"><img src="../images/GUID-6C180DCC-006B-4DC6-9E06-0A515C7A6193-low.png"><p></p>
                     <p class="figure-title">用户 B 添加关键点以将动画扩展到用户 A 的城市部分。</p>
                  </div>  
               </li>
               <li>用户 A 单击“更新”以查看用户 B 所做的最新更改。 
                  			 <a name="WS1A9193826455F5FF-4855151011E3B702B95-3B2A"></a><div class="figure-anchor"><img src="../images/GUID-E956DC4B-45EA-4A66-A979-BDF6C8FE9FB9-low.png"><p></p>
                     <p class="figure-title">用户 A 继承用户 B 所做的更改。</p>
                  </div>  
               </li>
            </ol> 
         </div>
         <div class="footer-block"><a href=".." class="comments-anchor" target="_blank"><span class="comments-link">请将您关于此页内容的评论发送给我们</span></a></div><br><p class="footer-license-block"><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank"><img alt="Creative Commons License" style="border-width: 0;" src="../images/ccLink.png"></a>&nbsp;<em>除非另有说明，否则此作品受到 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank"> Creative Commons 署名-非商业性使用-相同方式共享 3.0 未本地化版本许可证</a>的制约。请参见 <a href="http://autodesk.com/creativecommons" target="_blank">Autodesk Creative Commons 常见问题</a>(英文)以获取更多信息。</em></p><br></div>
   </body>
</html>