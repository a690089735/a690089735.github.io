<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../../style/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../../../scripts/prettify.js"></script><script src="../../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="pandoc" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><script type="text/javascript" src="../../../scripts/utils/adsk.redirect.js"></script>
      <title>Using the Maya Python API</title>
   </head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Using the Maya Python API</h1>
         </div>

<div class='section'><a id="using-the-maya-python-api"></a></div>
<p>It is possible to write basic scripts that use the wrapper, iterator and function set classes of the Maya API. These scripts can query and manipulate the Maya model but are not fully integrated into Maya. A scripted plug-in provides a more complex solution that is tightly integrated into Maya. In this section, we discuss how to write both basic and scripted plug-in scripts along with standalone scripts.</p>
<p>As this is a Python based API, knowledge of Python is required.</p>
<div class='section'><a id="importing-modules"></a><h2 id="importing-modules">Importing modules</h2></div>
<p>The Maya Python API is contained in a number of Python modules. You must import the functionality that you wish to use in your script. Additionally, the Maya Python API lives in the Maya namespace; therefore, an extra prefix is required. To import the OpenMaya module, run the following:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya

</pre></div><div class='section'><a id="help-on-a-module-or-class"></a><h2 id="help-on-a-module-or-class">Help on a module or class</h2></div>
<p>Information can be displayed about any of the modules or classes using the <span class='code'>help</span> command. For example, if you wish to display the class information for <span class='code'><a href="javascript:void(0)" data-symbol="MVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_vector.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MVector</a></span>, use:</p>
<p><span class='code'>help(maya.OpenMaya.MVector)</span></p>
<p>It is also possible to display the information of an entire module:</p>
<p><span class='code'>help(maya.OpenMaya)</span></p>
<p>This operation will take a while to return since the OpenMaya module is very large.</p>
<div class='section'><a id="writing-scripts"></a><h2 id="writing-scripts">Writing scripts</h2></div>
<p>The Maya Python API modules contain the classes that are available for Python programming. These classes are separated into different categories and have appropriate naming conventions to signify their association. Classes include:</p>
<div class='section'><a id="mfn"></a><h3 id="mfn">MFn</h3></div>
<p>Any class with this prefix is a function set used to operate on <span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MObject</a></span>s of a particular type.</p>
<div class='section'><a id="mit"></a><h3 id="mit">MIt</h3></div>
<p>These classes are iterators and work on <span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MObject</a></span>s similar to the way a function set does. For example, <span class='code'><a href="javascript:void(0)" data-symbol="MItCurveCV" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_it_curve_c_v.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_curve_c_v.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MItCurveCV</a></span> is used to operate on an individual NURBS curve CV (there is no <span class='code'>MFnNurbsCurveCV</span>), or, iteratively, on all the CVs of a curve.</p>
<div class='section'><a id="mpx"></a><h3 id="mpx">MPx</h3></div>
<p>Classes with this prefix are all &quot;Proxies&quot;, that is, API classes designed for you to derive from and create your own object types.</p>
<div class='section'><a id="m-classes"></a><h3 id="m-classes">M classes</h3></div>
<p>Most, although not all, of these classes are &quot;Wrappers&quot;. Examples of this class are: <span class='code'><a href="javascript:void(0)" data-symbol="MVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_vector.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MVector</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MIntArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_int_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_int_array.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MIntArray</a></span>, and so forth.</p>
<p>We can use wrapper and function set classes to write scripts such as the following:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya
vector1 = maya.OpenMaya.MVector(0,1,0)
vector2 = maya.OpenMaya.MVector(1,0,0)
vector3 = maya.OpenMaya.MVector(0,0,2)
newVector = vector1 + vector2 + vector3
print &quot;newVector %f, %f, %f &quot; % (newVector.x, newVector.y, newVector.z)

</pre></div><p>It is possible to shorten the symbol names used by modifying the import command:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya as OpenMaya
vector1 = OpenMaya.MVector(0,1,0)

</pre></div><p>Scripts can access dependency graph information using the Maya Python API classes. The following is a script that finds the persp node and prints out its <span class='code'>translateX</span> attribute value:</p>
<div class="codeBlock"><pre class="prettyprint"># import the OpenMaya module
import maya.OpenMaya as OpenMaya

# function that returns a node object given a name
def nameToNode( name ):
    selectionList = OpenMaya.MSelectionList()
    selectionList.add( name )
    node = OpenMaya.MObject()
    selectionList.getDependNode( 0, node )
    return node

# function that finds a plug given a node object and plug name
def nameToNodePlug( attrName, nodeObject ):
    depNodeFn = OpenMaya.MFnDependencyNode( nodeObject )
    attrObject = depNodeFn.attribute( attrName )
    plug = OpenMaya.MPlug( nodeObject, attrObject )
    return plug

# Find the persp camera node
print &quot;Find the persp camera&quot;
perspNode = nameToNode( &quot;persp&quot; )
print &quot;APItype %d&quot; % perspNode.apiType()
print &quot;APItype string %s&quot; % perspNode.apiTypeStr()

# Print the translateX value
translatePlug = nameToNodePlug( &quot;translateX&quot;, perspNode )
print &quot;Plug name: %s&quot; % translatePlug.name()
print &quot;Plug value %g&quot; % translatePlug.asDouble())

</pre></div><p>The example above demonstrates the following:</p>
<ul>
<li>To instantiate a class, use the <span class='code'>fn = OpenMaya.MFnFunctionSet()</span> notation.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MObject</a></span>s can be created using <span class='code'>node = OpenMaya.MObject()</span>.</li>
<li>Although Python is a typeless language, you must instantiate the correct type in order to pass it as a parameter of the class.</li>
<li>Python strings are passed and returned in place of the <span class='code'><a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MString</a></span> wrapper class.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> For the sake of clarity, the example above has omitted error checking.</p>
</blockquote>
<div class='section'><a id="scripted-plug-ins"></a><h2 id="scripted-plug-ins">Scripted plug-ins</h2></div>
<p>Scripted plug-ins allow a developer to create a solution that is tightly coupled with Maya. Scripted plug-ins allow a developer to support functionality such as the undoing of commands and the building of appropriate requires lines into the Maya scene file. Another advantage of using a scripted plug-in is that its functionality is available in both MEL and Python.</p>
<div class='section'><a id="using-a-scripted-plug-in"></a><h3 id="using-a-scripted-plug-in">Using a scripted plug-in</h3></div>
<p>We have extended the Maya Plug-in Manager to support the loading and unloading of scripted plug-ins.</p>
<div class='figure'><img src='dev_help/images/plugin_manager_python_QT.png' title='' /></div>
<p>Any file ending with a <span class='code'>.py</span> extension that is on the <span class='code'>MAYA_PLUG_IN_PATH</span> is displayed in the Plug-in Manager. Select the Loaded check-box or the Auto load check box to either load or auto-load the scripted plug-in.</p>
<blockquote>
<p><strong>Note:</strong> Although, it is possible to have a non scripted plug-in <span class='code'>.py</span> script on the <span class='code'>MAYA_PLUG_IN_PATH</span>, these items will not load. Warnings will be issued that entry points cannot be found.</p>
</blockquote>
<p>The plug-in can either be loaded from the Plug-in Manager or from the MEL or Python command tabs. In MEL, use the <span class='code'>loadPlugin()</span> command. In Python, use the <span class='code'>maya.cmds.loadPlugin()</span> command</p>
<p>To run an example such as <span class='code'>helixCmd.py</span>, load the plug-in and enter the following in the Python Editor tab:</p>
<div class="codeBlock"><pre class="prettyprint">import maya
maya.cmds.spHelix().

</pre></div><p>Invoking this Python script does the following:</p>
<ul>
<li>Import the Maya module so that the <span class='code'>cmds</span> module becomes available</li>
<li>Invoke the custom command <span class='code'>spHelix()</span></li>
</ul>
<blockquote>
<p><strong>Note:</strong> - The <span class='code'>sp</span> prefix is used for &quot;scripted plug-in&quot;. - Scripted plug-ins must be loaded using the loadPlugin command. It cannot be loaded by running the source of a scripted plug-in.</p>
</blockquote>
<p>This plug-in can also be unloaded using the Python command: <span class='code'>maya.cmds.unloadPlugin(&quot;helixCmd.py&quot;)</span></p>
<p>The load and execute steps can also be invoked in the MEL editor using:</p>
<div class="codeBlock"><pre class="prettyprint">loadPlugin helixCmd.py;
spHelix();

</pre></div><div class='section'><a id="writing-a-scripted-plug-in"></a><h3 id="writing-a-scripted-plug-in">Writing a scripted plug-in</h3></div>
<p>Writing a scripted plug-in requires the definition of some specialized functions within the plug-in. The scripted plug-in must:</p>
<ul>
<li>Define <span class='code'>initializePlugin</span> and <span class='code'>uninitializePlugin</span> entry points.</li>
<li>Register and unregister the proxy class within these entry points.</li>
<li>Implement creator and initialize methods (as required) which Maya calls to build the proxy class.</li>
<li>Implement the required functionality of the proxy class. This requires importing the necessary modules.</li>
</ul>
<p>The following sections describe these pieces in more detail with examples.</p>
<div class='section'><a id="importing"></a><h4 id="importing">Importing</h4></div>
<p>Python uses the import keyword to include functionality from a module into a script. For example:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx
import sys

</pre></div><p>It is possible for a scripted plug-in to be split among several files. The import command is used to load the functionality of the secondary file into the scripted plug-in.</p>
<div class="codeBlock"><pre class="prettyprint">import polyModifier

</pre></div><p>Any secondary scripts must be located in the same directory as the scripted plug-in.</p>
<div class='section'><a id="scripted-plug-in-initialization"></a><h4 id="scripted-plug-in-initialization">Scripted plug-in initialization</h4></div>
<p>When a scripted plug-in is loaded, Maya searches for an <span class='code'>initializePlugin()</span> function in its definition. Within this function, all proxy nodes are registered:</p>
<div class="codeBlock"><pre class="prettyprint"># Initialize the script plug-in
def initializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.registerCommand( kPluginCmdName, cmdCreator )
    except:
        sys.stderr.write( &quot;Failed to register command: %s\n&quot; % kPluginCmdName )
        raise

</pre></div><p>If the <span class='code'>initializePlugin()</span> function is not found, the scripted plug-in fails to load. In addition, during the load, Maya searches for an <span class='code'>uninitializePlugin()</span> function. If this is not found, then the scripted plug-in fails to load.</p>
<div class='section'><a id="scripted-plug-in-uninitialization"></a><h4 id="scripted-plug-in-uninitialization">Scripted plug-in uninitialization</h4></div>
<p>When Maya is attempting to unload the plug-in, the previously found <span class='code'>uninitializePlugin()</span> function is called to unload the resources of the plug-in.</p>
<div class="codeBlock"><pre class="prettyprint">def uninitializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.deregisterCommand( kPluginCmdName )
    except:
        sys.stderr.write( &quot;Failed to unregister command: %s\n&quot; % kPluginCmdName )
        raise

</pre></div><div class='section'><a id="creator-functions"></a><h4 id="creator-functions">Creator functions</h4></div>
<p>Creator functions are used to return a derived version of a proxy class to Maya. Virtual methods are implemented on the derived class which are called from Maya. An example of a class definition and a creator function is:</p>
<div class="codeBlock"><pre class="prettyprint">class scriptedCommand(OpenMayaMPx.MPxCommand):
    # ...
def cmdCreator():
    return OpenMayaMPx.asMPxPtr( scriptedCommand() )

</pre></div><p>It is very important to call the <span class='code'>OpenMayaMPx.asMPxPtr()</span> on the newly created proxy object. This call transfers ownership of the object from Python to Maya. Program errors will occur if you do not make this call since Python can unreference this object and destroy it. This will leave a dangling pointer in Maya.</p>
<div class='section'><a id="class-implementation"></a><h4 id="class-implementation">Class implementation</h4></div>
<p>Implementing a proxy class requires deriving from the Maya Python API object.</p>
<div class="codeBlock"><pre class="prettyprint">class scriptedCommand(OpenMayaMPx.MPxCommand):
    def __init__(self):
        OpenMayaMPx.MPxCommand.__init__(self)
    def doIt(self,argList):
        print &quot;Hello World!&quot;

</pre></div><p>The <span class='code'>scriptedCommand</span> class is derived from <span class='code'>OpenMayaMPx.MPxCommand</span>. The constructor or <span class='code'>__init__</span> method must call the parent class <span class='code'>__init__</span> method. All class methods require <span class='code'>self</span> as the first parameter, followed by the normal argument list. This command’s <span class='code'>doIt()</span> method simply prints out &quot;Hello World!&quot;.</p>
<div class='section'><a id="initialization-functions"></a><h4 id="initialization-functions">Initialization Functions</h4></div>
<p>Initialization functions are used within scripted plug-ins that define new proxy nodes using the <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MPxNode</a></span> class. The following is an example that demonstrates how to create a simple scripted plug-in node, the output of which is the sine function.</p>
<div class="codeBlock"><pre class="prettyprint">import math, sys
import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx
kPluginNodeTypeName = &quot;spSineNode&quot;
sineNodeId = OpenMaya.MTypeId(0x8700)

# Node definition
class sineNode(OpenMayaMPx.MPxNode):
    # class variables
    input = OpenMaya.MObject()
    output = OpenMaya.MObject()
    
    def __init__(self):
        OpenMayaMPx.MPxNode.__init__(self)
        
    def compute(self,plug,dataBlock):
        if ( plug == sineNode.output ):
            dataHandle = dataBlock.inputValue( sineNode.input )
            
            inputFloat = dataHandle.asFloat()
            result = math.sin( inputFloat ) * 10.0
            outputHandle = dataBlock.outputValue( sineNode.output )
            outputHandle.setFloat( result )
            dataBlock.setClean( plug )
# creator
def nodeCreator():
    return OpenMayaMPx.asMPxPtr( sineNode() )
    
# initializer
def nodeInitializer():
    # input
    nAttr = OpenMaya.MFnNumericAttribute()
    sineNode.input = nAttr.create( &quot;input&quot;, &quot;in&quot;, OpenMaya.MFnNumericData.kFloat, 0.0 )
    nAttr.setStorable(1)
    # output
    nAttr = OpenMaya.MFnNumericAttribute()
    sineNode.output = nAttr.create( &quot;output&quot;, &quot;out&quot;, OpenMaya.MFnNumericData.kFloat, 0.0 )
    nAttr.setStorable(1)
    nAttr.setWritable(1)
    # add attributes
    sineNode.addAttribute( sineNode.input )
    sineNode.addAttribute( sineNode.output )
    sineNode.attributeAffects( sineNode.input, sineNode.output )
    
# initialize the script plug-in
def initializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.registerNode( kPluginNodeTypeName, sineNodeId, nodeCreator, nodeInitializer )
    except:
        sys.stderr.write( &quot;Failed to register node: %s&quot; % kPluginNodeTypeName )
        raise
        
# uninitialize the script plug-in
def uninitializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.deregisterNode( sineNodeId )
    except:
        sys.stderr.write( &quot;Failed to register node: %s&quot; % kPluginNodeTypeName )
        raise

</pre></div><p>The <span class='code'>nodeInitializer()</span> function is passed to <span class='code'>registerNode()</span> in the <span class='code'>initializePlugin()</span> function. As the plug-in loads, Maya calls the <span class='code'>nodeInitializer()</span> function to create the attributes of the node.</p>
<div class='section'><a id="error-conditions"></a><h4 id="error-conditions">Error Conditions</h4></div>
<p>The Maya Python API uses Python exceptions for querying and setting error states in script. In most cases, exceptions are used even though the class documentation indicates that a method has a return value. There are many situations where an exception can occur:</p>
<ol>
<li><p>A call fails and the failure state needs to be preserved:</p>
<div class="codeBlock"><pre class="prettyprint">    def uninitializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.deregisterNode( sineNodeId )
    except:
        sys.stderr.write( &quot;Failed to deregister node: %s&quot; % kPluginNodeTypeName )
        raise

</pre></div><p>In this example, if the <span class='code'>deregisterNode()</span> call failed, the <span class='code'>uninitializePlugin()</span> call passes the exception back to Maya and the plug-in fails to unload.</p></li>
<li><p>A call fails and the failure state needs to be cleared:</p>
<p>This code can be modified to catch the error and still allow the plug-in to unload if the <span class='code'>deregisterNode()</span> call fails:</p>
<div class="codeBlock"><pre class="prettyprint">def uninitializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.deregisterNode( sineNodeId )
    except:
        sys.stderr.write( &quot;Failed to deregister node: %s&quot; % kPluginNodeTypeName )
        pass

</pre></div><p>The only change being that the <span class='code'>raise</span> keyword has been changed to <span class='code'>pass</span>. This technique is useful for writing iterator code that may fail if incorrect objects are being examined.</p>
<p>3. Unknown parameter return value</p>
<p>In the Maya Python API, an unknown parameter return value is used to indicate that a method cannot handle a specific case and it is up to the caller to take care of the operation. One such method is <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode::compute()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html#a6e1aa1e50774080d5aee55f20ffa5503&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html#ae17c4b226f482e2d77c3f99375d1eea0&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MPxNode::compute()</a></span>. In this situation, the Python code would return <span class='code'>OpenMaya.kUnknownParameter.</span></p></li>
</ol>
<div class='section'><a id="exceptions-versus-mstatus"></a><h4 id="exceptions-versus-mstatus">Exceptions versus MStatus</h4></div>
<p>As noted in the previous section, the Maya Python API uses exceptions to communicate status information rather than MStatus values. When trying to divine the Pythonic behavior of an API method from its C++ documentation, the rules below hold.</p>
<p>There are two ways in which C++ API methods can return MStatus values, either as the method&#39;s return value:</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MStatus</a> someMethod(Type arg1, Type arg2, ...) 

</pre></div><p>or through an optional pointer to an MStatus variable in its parameter list, usually as the final parameter:</p>
<div class="codeBlock"><pre class="prettyprint">Type someMethod(Type arg1, Type arg2, ..., <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MStatus</a>* ReturnStatus = NULL) 

</pre></div><div class='section'><a id="method-returns-mstatus-as-its-function-value"></a><h5 id="method-returns-mstatus-as-its-function-value">Method returns MStatus as its function value</h5></div>
<p>When the method returns an <span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MStatus</a></span> as its function value, that return value is handled in Python as follows:</p>
<ul>
<li>if the status is <span class='code'>MS::kUnknownParameter</span>, then the string <span class='code'>unknown</span> is returned to Python;</li>
<li>if the status is <span class='code'>MS::kSuccess</span>, then nothing is returned and no exception is raised;</li>
<li>if the status is anything else, then nothing is returned but a <span class='code'>RuntimeError</span> exception is raised.</li>
</ul>
<p>The reason for the special handling of <span class='code'>MS::kUnknownParameter</span> is to accomodate <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode::compute()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html#a6e1aa1e50774080d5aee55f20ffa5503&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html#ae17c4b226f482e2d77c3f99375d1eea0&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MPxNode::compute()</a></span>.</p>
<p>There are no special API-specific exceptions. Maya simply uses Python&#39;s standard <span class='code'>RuntimeError</span> and passes the error string as its argument.</p>
<div class='section'><a id="method-returns-mstatus-through-a-pointer-variable"></a><h5 id="method-returns-mstatus-through-a-pointer-variable">Method returns MStatus through a pointer variable</h5></div>
<p>When an API method returns an <span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MStatus</a></span> through a pointer variable in its parameter list, then that <span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MStatus</a></span> is handled as follows:</p>
<ul>
<li>if the status is <span class='code'>MS::kSuccess</span>, then no exception is raised;</li>
<li>if the status is anything else, then nothing is returned but a <span class='code'>RuntimeError</span> exception is raised.</li>
</ul>
<p>This means that users writing plug-ins in C++ can continue to return <span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MStatus</a></span> codes as they normally would, regardless of whether their code is called from C++ or Python. Maya will internally convert those codes to Python exceptions if necessary.</p>
<p>Users writing plug-ins in Python should raise exceptions rather than return <span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MStatus</a></span> values, unless they want their <span class='code'>compute()</span> method to indicate that it is not going to handle a plug. In this case, it should return <span class='code'>maya.OpenMaya.kUnknownParameter</span>.</p>
<div class='section'><a id="classes-support-slicing"></a><h4 id="classes-support-slicing">Classes support slicing</h4></div>
<p>All of the number arrays (<span class='code'><a href="javascript:void(0)" data-symbol="MIntArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_int_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_int_array.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MIntArray</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MUintArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_uint_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_uint_array.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MUintArray</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MUint64Array" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_uint64_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_uint64_array.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MUint64Array</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MFloatArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_float_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_float_array.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MFloatArray</a></span>, and <span class='code'><a href="javascript:void(0)" data-symbol="MDoubleArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_double_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_double_array.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MDoubleArray</a></span>) support Python-style slicing. For example:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya as OpenMaya 
array = OpenMaya.MUintArray() 
for i in range(0,9):
   array.append( i )
array[2:8:2]

</pre></div><p><span class='code'># Result:[2, 4, 6] #</span></p>
<div class='section'><a id="accessing-static-mobjects-of-an-mpx-class"></a><h4 id="accessing-static-mobjects-of-an-mpx-class">Accessing static MObjects of an MPx class</h4></div>
<p>The proxy classes provide some standard information to a developer about the node that is being used. This includes attribute objects that are used to define the node. To access a static class <span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MObject</a></span> in the Maya Python API, similar code can be used:</p>
<div class="codeBlock"><pre class="prettyprint">envelope = OpenMayaMPx.cvar.MPxDeformerNode_envelope

</pre></div><p>After making this call, the envelope will be an <span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MObject</a></span> for <span class='code'>MPxDeformerNode::envelope</span>.</p>
<div class='section'><a id="messages"></a><h4 id="messages">Messages</h4></div>
<p>Message classes are supported in the Maya Python API. A Python function is passed for the callback. This function must have the exact number of parameters required by the callback message. If it does not, an exception will occur when the message is invoked and information will be written to the console. Client data in the form of a python object can also be passed with most messages. The following is an example of a message:</p>
<div class="codeBlock"><pre class="prettyprint"># Message callback
def dagParentAddedCallback( child, parent, clientData ):
    print &quot;dagParentAddedCallback...&quot;
    print &quot;\tchild %s&quot; % child.fullPathName()
    print &quot;\tparent %s&quot; % parent.fullPathName()
    print &quot;\tclient data %s&quot; % clientData

# Create the mesage
def createParentAddedCallback(stringData):
    try:
        id = OpenMaya.MDagMessage.addParentAddedCallback( dagParentAddedCallback, stringData )
    except:
        sys.stderr.write( &quot;Failed to install dag parent added callback\n&quot; )
        messageIdSet = False
    else:
        messageIdSet = True
    return id
# Call the message creator
messageId = createParentAddedCallback( &quot;_noData_&quot; )

</pre></div><div class='section'><a id="modify-parameter-values-instead-of-using-an-assignment"></a><h4 id="modify-parameter-values-instead-of-using-an-assignment">Modify Parameter Values Instead of Using an Assignment</h4></div>
<p>In Python, it is best to modify a parameter rather than use an assignment. The code below contains an assignment and demonstrates how an error can occur:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya as OpenMaya 
def vectorTest(v): 
    lv = OpenMaya.MVector(1,5,9) 
    v = lv 
    print &quot;%g %g %g&quot; % (v.x,v.y,v.z) 
v = OpenMaya.MVector() 
vectorTest(v) 
print &quot;%g %g %g&quot; % (v.x,v.y,v.z)

</pre></div><p>The second print command will emit all zeroes. In Python, either modify the parameter value or write the code so that a new value is returned. Rewrite the <span class='code'>vectorTest()</span> function as follows:</p>
<div class="codeBlock"><pre class="prettyprint">def vectorTest(v): 
    lv = OpenMaya.MVector(1,5,9) 
    v.x = lv.x
    v.y = lv.y
    v.z = lv.z
    print &quot;%g %g %g&quot; % (v.x,v.y,v.z) 

</pre></div><div class='section'><a id="references-to-basic-types"></a><h4 id="references-to-basic-types">References to Basic Types</h4></div>
<p>The Maya Python API contains many calls in which return values or parameters are references to basic types such as: int&amp;, char&amp;, float&amp; etc. In the Maya Python API, all references are treated as pointers. As a result, special calls are required to create, set and access the values of these items.</p>
<p>A utility class called <span class='code'><a href="javascript:void(0)" data-symbol="MScriptUtil" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_script_util.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MScriptUtil</a></span> that exists in the OpenMaya.py module provides methods for working with these type of parameters and return values. This class allows for creating data and then acquiring a pointer to the data so that information can be passed to class methods requiring references. See <span class='code'><a href="javascript:void(0)" data-symbol="MScriptUtil" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_script_util.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MScriptUtil</a></span> in the API Reference documentation.</p>
<p>The following example should help to clarify the usage of <span class='code'><a href="javascript:void(0)" data-symbol="MScriptUtil" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_script_util.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MScriptUtil</a></span>. It shows how to get the x, y and z values from a call to <span class='code'>MFnLattice.getDivisions()</span>:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya as OpenMaya
import maya.OpenMayaAnim as Anim
xutil = OpenMaya.MScriptUtil()
xutil.createFromInt(0)
xptr = xutil.asUintPtr()
yutil = OpenMaya.MScriptUtil()
yutil.createFromInt(0)
yptr = yutil.asUintPtr()
zutil = OpenMaya.MScriptUtil()
zutil.createFromInt(0)
zptr = zutil.asUintPtr()
it = OpenMaya.MItDependencyNodes(OpenMaya.MFn.kFFD)
while not it.isDone():
    latDefFn = Anim.MFnLatticeDeformer( it.thisNode() )
    latFn = Anim.MFnLattice( latDefFn.deformLattice() )
    latFn.getDivisions(xptr, yptr, zptr)
    x = xutil.getUint(xptr)
    y = yutil.getUint(yptr)
    z = zutil.getUint(zptr)
    doSomethingUseful(x, y, z)
    it.next()

</pre></div><p>Since <span class='code'>getUint()</span> is a static method of <span class='code'><a href="javascript:void(0)" data-symbol="MScriptUtil" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_script_util.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MScriptUtil</a></span>, an alternative way of retrieving the final values is to call it directly from the class. For example:</p>
<div class="codeBlock"><pre class="prettyprint">x = OpenMaya.MScriptUtil.getUint(xptr)

</pre></div><p>References to enumerated types should be treated as references to short ints.</p>
<div class='section'><a id="commands-with-flags"></a><h4 id="commands-with-flags">Commands with Flags</h4></div>
<p>A command which has flags must specify its syntax using an <span class='code'><a href="javascript:void(0)" data-symbol="MSyntax" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_syntax.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_syntax.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MSyntax</a></span> object and parse the flags using the <span class='code'><a href="javascript:void(0)" data-symbol="MArgParser" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_parser.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_parser.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MArgParser</a></span> or <span class='code'><a href="javascript:void(0)" data-symbol="MArgDatabase" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_database.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_database.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MArgDatabase</a></span> classes, otherwise the flags will not be accessible when the command is used from within Python. This is true regardless of whether the command is written in Python or C++. Below is an example of a scripted plug-in which implements a command with flags:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx
import sys, math
kPluginCmdName=&quot;spHelix&quot;
kPitchFlag = &quot;-p&quot;
kPitchLongFlag = &quot;-pitch&quot;
kRadiusFlag = &quot;-r&quot;
kRadiusLongFlag = &quot;-radius&quot;

# command
class scriptedCommand(OpenMayaMPx.MPxCommand):
    def __init__(self):
        OpenMayaMPx.MPxCommand.__init__(self)
    
    def doIt(self, args):
        deg = 3
        ncvs = 20
        spans = ncvs - deg
        nknots = spans+2*deg-1
        radius = 4.0
        pitch = 0.5
        
        # Parse the arguments.
        argData = OpenMaya.MArgDatabase(self.syntax(), args)
        if argData.isFlagSet(kPitchFlag):
            pitch = argData.flagArgumentDouble(kPitchFlag, 0)
        if argData.isFlagSet(kRadiusFlag):
            radius = argData.flagArgumentDouble(kRadiusFlag, 0)
        controlVertices = OpenMaya.MPointArray()
        knotSequences = OpenMaya.MDoubleArray()
        
        # Set up cvs and knots for the helix
        for i in range(0, ncvs):
            controlVertices.append( OpenMaya.MPoint( radius * math.cos(i),
                pitch * i, radius * math.sin(i) ) )
        for i in range(0, nknots):
            knotSequences.append( i )
        
        # Now create the curve
        curveFn = OpenMaya.MFnNurbsCurve()
        
        nullObj = OpenMaya.MObject()
        try:
            # This plugin normally creates the curve by passing in the
            # cv&#39;s. A function to create curves by passing in the ep&#39;s
            # has been added. Set this to False to get that behaviour.
            if True:
                curveFn.create( controlVertices, knotSequences, deg, OpenMaya.MFnNurbsCurve.kOpen, 0, 0, nullObj )
            else:
                curveFn.createWithEditPoints(controlVertices, 3, OpenMaya.MFnNurbsCurve.kOpen, False, False, False)
        except:
            sys.stderr.write( &quot;Error creating curve.\n&quot; )
            raise
# Creator
def cmdCreator():
    # Create the command
    return OpenMayaMPx.asMPxPtr( scriptedCommand() )

# Syntax creator
def syntaxCreator():
    syntax = OpenMaya.MSyntax()
    syntax.addFlag(kPitchFlag, kPitchLongFlag, OpenMaya.MSyntax.kDouble)
    syntax.addFlag(kRadiusFlag, kRadiusLongFlag, OpenMaya.MSyntax.kDouble)
    return syntax

# Initialize the script plug-in
def initializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject, &quot;Autodesk&quot;, &quot;1.0&quot;, &quot;Any&quot;)
    try:
        mplugin.registerCommand( kPluginCmdName, cmdCreator, syntaxCreator )
    except:
        sys.stderr.write( &quot;Failed to register command: %s\n&quot; % kPluginCmdName )
        raise
        
# Uninitialize the script plug-in
def uninitializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.deregisterCommand( kPluginCmdName )
    except:
        sys.stderr.write( &quot;Failed to unregister command: %s\n&quot; % kPluginCmdName )
        raise

</pre></div><p>This example includes the syntax creator function along with parsing operations in the <span class='code'>doIt()</span> method of the class.</p>
<div class='section'><a id="protected-methods"></a><h4 id="protected-methods">Protected methods</h4></div>
<p>The Maya Python API contains several methods that should only be called from the class the method belongs to. We follow the Python designation of using an _ as the first letter of the method name to indicate that protection applies to this method. Several examples of these methods exist in the <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MPxNode</a></span> class:</p>
<div class="codeBlock"><pre class="prettyprint">_forceCache()
_setMPSafe()

</pre></div><p>Please respect the method usage requirements of protected methods in the Maya Python API.</p>
<div class='section'><a id="getting-derived-object-from-mpx-base-object"></a><h4 id="getting-derived-object-from-mpx-base-object">Getting derived object from MPx base object</h4></div>
<p>Some API methods return your custom objects as instances of their base <span class='code'>MPx</span> class rather than instances of your derived class. For example, <span class='code'>MPxContext._newToolCommand()</span> returns your custom tool command as an <span class='code'><a href="javascript:void(0)" data-symbol="MPxToolCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MPxToolCommand</a></span> object and <span class='code'>MPxSurfaceShapeUI.surfaceShape()</span> returns your custom surface shape as an <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_surface_shape.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MPxSurfaceShape</a></span> object. While these base instances refer to the same internal Maya objects as the original derived instances, they are separate Python objects which do not retain any of the member variable values set in the derived instances, so calling methods or accessing member variables on the returned objects may give incorrect results.</p>
<p>You can work around this problem by taking advantage of the properties of the <span class='code'>OpenMayaMPx.asHashable()</span> function. <span class='code'>OpenMayaMPx.asHashable()</span> takes an <span class='code'>MPx</span> object and returns a hash value which uniquely identifies the underlying Maya object. It doesn&#39;t matter whether the object is an instance of the base <span class='code'>MPx</span> class or your derived class: so long as they both refer to the same underlying Maya object they will return the same hash value. This allows you to set up a dictionary which can translate a base instance into its corresponding derived instance.</p>
<p>The first step is to add an empty dictionary to the class:</p>
<div class="codeBlock"><pre class="prettyprint">class MoveToolCmd(OpenMayaMPx.MPxToolCommand):
    kTrackingDictionary = {}

</pre></div><p>In the class&#39;s <span class='code'>__init__</span> method, add an entry to the dictionary, mapping the new object&#39;s hash value to the object itself:</p>
<div class="codeBlock"><pre class="prettyprint">def __init__(self): 
    OpenMayaMPx.MPxToolCommand.__init__(self)
    MoveToolCmd.kTrackingDictionary[OpenMayaMPx.asHashable(self)] = self 


</pre></div><p>In the class&#39;s <span class='code'>__del__</span> method, remove the deleted object from the dictionary:</p>
<div class="codeBlock"><pre class="prettyprint">def __del__(self): 
    del MoveToolCmd.kTrackingDictionary[OpenMayaMPx.asHashable(self)] 


</pre></div><p>Now that you have the tracking dictionary, you can use it to retrieve the derived object from its corresponding base object:</p>
<div class="codeBlock"><pre class="prettyprint">class MoveContext(OpenMayaMPx.MPxSelectionContext): 
    ... 
    
    def doPress(self, event): 

        # Create an instance of the move tool command. 
        baseCmd = self._newToolCommand() 
        derivedCmd = MoveToolCmd.kTrackingDictionary.get( 
                        OpenMayaMPx.asHashable(baseCmd), None 
                     ) 

        # Call its methods.
        derivedCmd.setVector(0.0, 0.0, 0.0) 


</pre></div><p>When defining custom node types (<span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MPxNode</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_surface_shape.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MPxSurfaceShape</a></span>, etc) some additional effort is required. When Maya does a file open or new file operation it destroys the scene without executing the __del__ method for each node. That means that the entries for those nodes are never removed from the tracking dictionary. To get around this, callbacks must be set up in your initializePlugin method to clear their tracking dictionaries on file open and file new:</p>
<div class="codeBlock"><pre class="prettyprint">fileOpenCB = 0
fileNewCB = 0

def clearTrackingDictionaries(unused):
    MyNode.kTrackingDictionary = {} 
    MySurfaceShape.kTrackingDictionary = {}

def initializePlugin(plugin): 
    ... 
    fileOpenCB = OpenMaya.MSceneMessage.addCallback(
                     OpenMaya.MSceneMessage.kBeforeOpen, 
                     clearTrackingDictionaries 
                 )
    fileNewCB  = OpenMaya.MSceneMessage.addCallback(
                     OpenMaya.MSceneMessage.kBeforeNew, 
                     clearTrackingDictionaries 
                 )
    ...
}

def uninitializePlugin(plugin): 
    ... 
    if fileOpenCB != 0:
        OpenMaya.MSceneMessage.removeCallback(fileOpenCB) 
        fileOpenCB = 0 

    if fileNewCB != 0: 
        OpenMaya.MSceneMessage.removeCallback(fileNewCB)
        fileNewCB = 0

</pre></div><div class='section'><a id="operating-system-types"></a><h4 id="operating-system-types">Operating System Types</h4></div>
<p>There are some methods in the Maya Python API that require <span class='code'>&lt;iosteam&gt;</span> operating system types. As these are not included in Python, a <span class='code'><a href="javascript:void(0)" data-symbol="MStreamUtils" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_stream_utils.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MStreamUtils</a></span> class is available for creating and using these type of objects. Please check the Developer Kit for examples on how to use this class.</p>
<div class='section'><a id="calling-into-the-parent-class"></a><h4 id="calling-into-the-parent-class">Calling into the Parent class</h4></div>
<p>Often when writing an MPx proxy class, the scripts will require calling into the parent class. This is done using notation such as the following:</p>
<p><span class='code'>matrix = OpenMayaMPx.MPxTransformationMatrix.asMatrix(self)</span></p>
<div class='section'><a id="enum-values"></a><h4 id="enum-values">Enum values</h4></div>
<p>Enum values are accessed using a moduleName.className.value notation such as:</p>
<p><span class='code'>OpenMaya.MSyntax.kDouble</span></p>
<div class='section'><a id="using-opengl"></a><h4 id="using-opengl">Using OpenGL</h4></div>
<p>We have provided a wrapper class <span class='code'><a href="javascript:void(0)" data-symbol="MGLFunctionTable" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_g_l_function_table.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MGLFunctionTable</a></span> for using OpenGL functionality in script on all of our support platforms. To acquire a reference to this class use the following code:</p>
<div class="codeBlock"><pre class="prettyprint">glRenderer = OpenMayaRender.MHardwareRenderer.theRenderer()
glFT = glRenderer.glFunctionTable()

</pre></div><div class='section'><a id="nested-iterators-and-garbage-collection"></a><h4 id="nested-iterators-and-garbage-collection">Nested iterators and Garbage Collection</h4></div>
<p>When writing nested iterators, it is normal to have the current item of the outer loop passed into an inner loop. For example, the current item of an <span class='code'><a href="javascript:void(0)" data-symbol="MItSelectionList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_selection_list.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MItSelectionList</a></span> is passed into a <span class='code'><a href="javascript:void(0)" data-symbol="MItSurfaceCV" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_it_surface_c_v.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_surface_c_v.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../&quot;}]">MItSurfaceCV</a></span> iterator. You may encounter garbage collection issues in this case where the inner iterator is holding on to information that may no longer be valid. You can work around this by resetting the inner iterator to None once its loop has been completed. This releases the iterator’s information before the outer loop continues, which is important if current items are being rebuilt or updated.</p>
<div class='section'><a id="standalone-scripts"></a><h2 id="standalone-scripts">Standalone Scripts</h2></div>
<p>It is possible to write standalone scripts that make use of the wrapper classes and function sets to modify the Maya model. These scripts are run from the command line. A simple &quot;hello world&quot; standalone script follows:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.standalone
import maya.OpenMaya as OpenMaya
import sys
def main( argv = None ):
    try:
        maya.standalone.initialize( name=&#39;python&#39; )
    except:
        sys.stderr.write( &quot;Failed in initialize standalone application&quot; )
        raise
    sys.stderr.write( &quot;Hello world! (script output)\n&quot; )
    OpenMaya.MGlobal().executeCommand( &quot;print \&quot;Hello world! (command script output)\\n\&quot;&quot; )
    maya.standalone.uninitialize()
    
if __name__ == &quot;__main__&quot;:
    main()

</pre></div><p>After the standalone is initialized, Maya commands and API classes can be used to create and modify a Maya model. When finished, the standalone is uninitialized to allow Maya to clean up after itself. Do not attempt to use Maya commands or API classes before the call to <span class='code'>initialize()</span> or after the call to <span class='code'>uninitialize()</span>; otherwise, unstable behaviour may result.</p>
<p>A standalone script must be run using the Python executable that is supplied with Maya. For example:</p>
<p><span class='code'>$MAYA_LOCATION/bin/mayapy helloWorld.py</span></p>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
